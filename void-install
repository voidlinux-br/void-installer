#!/usr/bin/env bash
#shellcheck disable=SC2145,SC2001,SC2188,SC2015,SC2155,SC2317,SC2320,SC2291,SC2034,SC2120,SC2086,SC2319
#shellcheck disable=SC2016,SC2154,SC2207,SC2166,SC2128,SC2059,SC2140,SC2031,SC2030,SC2036,SC2119,SC2027

#  void-install
#  Created: 2022/12/24
#  Altered: 2024/03/11
#  Updated: dom 11 jan 2026 12:47:56 -04
#
#  Copyright (c) 2022-2025, Vilmar Catafesta <vcatafesta@gmail.com>
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
#  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
#  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##############################################################################
export LANGUAGE="${LANGUAGE:-pt_BR}"
export TEXTDOMAINDIR=/usr/share/locale
export TEXTDOMAIN=void-install

#todo
#usermod -a -G bluetooth $USER

#debug
red=$(tput bold)$(tput setaf 196)
green=$(tput bold)$(tput setaf 2)
pink=$(tput setaf 5)
cyan=$(tput setaf 6)
reset=$(tput sgr0)
#export PS4='${red}${0##*/}${green}[$FUNCNAME]${pink}[$LINENO]${reset} '
export PS4='${red}${0##*/}${green}[${FUNCNAME[0]:-MAIN}]${pink}[$LINENO]${reset} '
#set -x
#set -eo pipefail
shopt -s extglob

#system
readonly APP="${0##*/}"
readonly _VERSION_='3.1.11-20260111'
readonly DEPENDENCIES=(dialog rsync awk tar sed cat grep sort tr chroot blkid fdisk parted lsblk curl xz mkfs.vfat tee lvm cryptsetup gettext)
#                      cfdisk gdisk  efivar mkfs.ext2 mkfs.ext3 mkfs.ext4 mkfs.btrfs mkfs.xfs mkfs.f2fs mkfs.jfs mkfs.reiserfs)

# Mapa: [distro]="lista de pacotes"
declare -gA DISTRO_PKGS=(
	["void"]="gettext rsync parted curl xz lvm2"
	["void-live"]="gettext rsync parted curl xz lvm2"
	["voidlinux"]="gettext rsync parted curl xz lvm2"
	["chili"]="gettext rsync parted curl xz"
	["chililinux"]="gettext rsync parted curl xz"
	["arch"]="gettext rsync parted curl xz"
	["manjaro"]="gettext rsync parted curl xz"
	["debian"]="gettext-base rsync parted curl xz-utils"
)

# Mapa: [distro]="comando de instalação"
declare -gA DISTRO_MGR=(
	["void"]="xbps-install -Syf"
	["void-live"]="xbps-install -Syf"
	["voidlinux"]="xbps-install -Syf"
	["chili"]="pacman -Sy --needed --noconfirm"
	["chililinux"]="pacman -Sy --needed --noconfirm"
	["arch"]="pacman -Sy --needed --noconfirm"
	["manjaro"]="pacman -Sy --needed --noconfirm"
	["debian"]="apt-get install -y"
)

declare distro=$(uname -n)
declare LCUSTOM=false
declare LEFI=false
declare LGRUB=false
declare LDISK=false
declare LMIRROR=true
declare LSOURCE=true
declare LKEYMAP=true
declare LTIMEZONE=true
declare LAUDIO=true
declare LWM=true
declare LAUTO=true
declare LMKPARTED=false
declare LFS=false
declare LPARTITION=false
declare LBIND=false
declare LBIOS=true
declare LOSPROBER=false
declare LCHROOT=false
declare LINSTALL=false
declare HYPRLAND=false
declare LVM=false
declare LFDE=false
declare LONLY_TTY=true
declare LEXTRA=false
declare LLOCALE=true
#
declare -ga _PKGS
declare -ga _EXTRAS
declare DEFITEM
#
declare -gi njobs=73
declare -gi ncounter=0
declare -gi quiet=0
declare -gi grafico=0
#
declare -gA Amkfs
declare -gA Amntpoint
declare -gA AmntpointFDE
declare -gA AARRAY_DSK_DEVICES
declare -gA AARRAY_PART_DEVICES
declare -gA AARRAY_VG_DEVICES
#
declare -gA AsUser=(
	[cpass]='voidlinux'
	[cpassroot]='voidlinux'
	[chostname]='voidlinux'
	[cgroups]='wheel,audio,video,floppy,cdrom,optical,kvm,xbuilder'
)
#
declare -gA AConfFde=(
	[partition]=''
	[vg]='voidvm'
	[passphrase]='voidlinux'
	[verifypassphrase]='voidlinux'
	[lvroot]='25%'
	[lvswap]='2%'
	[lvvar]=''
	[lvhome]='100%'
)
declare -gA AConfDisk=(
	[_DEVICE]='/dev/sdX'
	[_FILESYSTEM]='ext4'
	[_DISKTABLE]=''
	[_BOOTLOADER]='/dev/sdX'
	[_OSPROBER]=false
)
declare -gA AConfLocale=(
	[_TIMEZONE]='America/Sao_Paulo'
	[_KEYMAP]='br-abnt2'
	[_CLOCK]='UTC'
	[_FONT]='Lat2-Terminus16'
	[_LOCALE]='pt_BR.utf8'
	[_REGION]='Portuguese Brazil'
)
declare -gA AConfMirror=(
	[_SOURCE]='network'
	[_MIRROR]='repo.fastly.voidlinux.org'
	[url_mirror]='https://repo-fastly.voidlinux.org'
	[location]='Fastly Global CDN'
)
declare -gA AConfAudio=(
	[_AUDIOSERVER]='Pipewire'
)
declare -gA AConfWifi=(
	[_NETWORK]='wifi_ssid'
	[_PASSWORD]='wifi_password'
)
declare -gA Alanguage=(
	[pt_BR]=0
	[en_US]=1
	[de_DE]=2
	[fr_FR]=3
	[es_ES]=4
	[it_IT]=5
)
declare -gA Alocale=(
	[0]=pt_BR
	[1]=en_US
	[2]=de_DE
	[3]=fr_FR
	[4]=es_ES
	[5]=it_IT
)
declare dialogRcFile="$HOME/.dialogrc"
#

detect_distro() {
	local id=""

	if [[ -r /etc/os-release ]]; then
		# Lê ID=void|arch|debian|... exatamente como a distro declara
		id=$(grep -E '^ID=' /etc/os-release | cut -d= -f2 | tr -d '"')
	elif [[ -r /usr/lib/os-release ]]; then
		id=$(grep -E '^ID=' /usr/lib/os-release | cut -d= -f2 | tr -d '"')
	else
		echo "unknown"
		return
	fi
	echo "$id"
}

readconf() {
	if [[ $LC_DEFAULT -eq 0 ]]; then
		read -r -p "$@ [S/n]"
	else
		read -r -p "$@ [Y/n]"
	fi
	[[ ${REPLY^} == "" ]] && return 0
	[[ ${REPLY^} == N ]] && return 1 || return 0
}

check_gettext() {
	# 1. Se o gettext já estiver disponível, não faz nada e retorna sucesso
	if command -v gettext >/dev/null; then
		return 0
	fi
	# 2. Segurança: Operações de pacotes exigem root
	if ((EUID != 0)); then
		echo -e "${red}erro: você não pode realizar esta operação a menos que seja root.${reset}"
		exit 1
	fi
	echo -e "Distro detectada: ${green}${DISTRO}${reset}"

	# 3. Extração dos dados dos mapas que você definiu
	local pkgs="${DISTRO_PKGS[$DISTRO]}"
	local cmd="${DISTRO_MGR[$DISTRO]}"

	# Se a distro atual não existir no mapa, precisamos avisar e parar
	if [[ -z "$cmd" ]]; then
		echo -e "${red}Erro: Nenhuma configuração de pacotes encontrada para a distro: '$DISTRO'${reset}"
		exit 1
	fi

	# 4. Prompt ao usuário (usando sua função readconf)
	# Se gettext não existe, as mensagens ainda precisam ser via echo/printf
	if readconf "${red}FALHA:${reset} ${cyan}Pacote/Comando 'gettext' não encontrado. Instalar dependências base agora?${reset}"; then
		echo -e "${blue}::${reset} Preparando ambiente para ${green}${DISTRO}${reset}..."
		# Execução dinâmica: $cmd (gerenciador) + $pkgs (lista de pacotes)
		if ! $cmd $pkgs; then
			echo -e "${red}Erro Crítico:${reset} A instalação dos pacotes básicos falhou."
			exit 1
		fi
		echo -e "${green}Sucesso:${reset} Dependências instaladas."
	else
		# Se o usuário negar a instalação de ferramentas básicas, o instalador não tem como seguir
		echo -e "${yellow}Aviso:${reset} O gettext é indispensável para as traduções. Saindo..."
		exit 1
	fi
}

###########################################################################################################
# Corte para teste do gettext
DISTRO="$(detect_distro)"
check_gettext
###########################################################################################################

sh_enablePrintk() {
	if [[ -w /proc/sys/kernel/printk ]]; then
		echo 4 >/proc/sys/kernel/printk
	fi
}

get_option() {
	echo $(grep -E "^${1}.*" $app_conf | sed -e "s|${1}||")
}

die() {
	if test $# -ge 2; then
		evaluate_retval 1
	fi
	local msg=$1
	shift
	printf "%-75s\n" "$(DOT)${bold}${red}$msg${reset}" >&2
	sh_enablePrintk
	exit 1
}

DOT() {
	printf "%s" "${blue}:: ${reset}"
}

sh_checkDependencies() {
	local d
	local errorFound=false
	declare -a missing

	for d in "${DEPENDENCIES[@]}"; do
		if [[ -z $(command -v "$d") ]]; then
			pkg="$d"
			[[ "$pkg" == 'lvm' ]] && pkg='lvm2'
			missing+=("$pkg")
			errorFound=true
			printf '%s\n' "${red}${cmsg_ERRO}${reset}: ${cmsg_CommandNotFound} ${cyan}'$d'${reset}"
		fi
	done

	if $errorFound; then
		echo "${yellow}--------------${cmsg_ImpossivelContinuar}-------------${reset}"
		echo "${cmsg_ImpossivelContinuar1}" >&2
		echo "${cmsg_ImpossivelContinuar2} \$PATH" >&2
		echo "${yellow}-----------------------------------------------${reset}"

		if [[ "$distro" = @(void|void-live|voidlinux) ]]; then
			echo
			if readconf "${yellow}${cmsg_InstCommand} '${cyan}${missing[*]}${reset}' ?"; then
				if LC_ALL=C xbps-install -Sy "${missing[@]}"; then
					errorFound=0
					sh_checkDependencies
				else
					die "${cmsg_RunNewErro}"
				fi
			fi
		else
			die "${cmsg_ERRO}: ${cmsg_InstalacaoAbortada}..."
		fi
	fi
}

sh_create_dialogrc() {
	cat >"$dialogRcFile" <<-'EOF'
		screen_color = (white,black,off)
		dialog_color = (white,black,off)
		title_color = (green,black,on)
		border_color = dialog_color
		shadow_color = (black,black,on)
		button_inactive_color = dialog_color
		button_key_inactive_color = dialog_color
		button_label_inactive_color = dialog_color
		button_active_color = (black,green,on)
		button_key_active_color = button_active_color
		button_label_active_color = (white,green,on)
		tag_key_selected_color = (white,green,on)
		item_selected_color = tag_key_selected_color
		form_text_color = (green,black,on)
		form_item_readonly_color = (cyan,black,on)
		itemhelp_color = (white,green,off)
		inputbox_color = dialog_color
		inputbox_border_color = dialog_color
		searchbox_color = dialog_color
		searchbox_title_color = title_color
		searchbox_border_color = border_color
		position_indicator_color = title_color
		menubox_color = dialog_color
		menubox_border_color = border_color
		item_color = dialog_color
		tag_color = title_color
		tag_selected_color = button_label_active_color
		tag_key_color = button_key_inactive_color
		check_color = dialog_color
		check_selected_color = button_active_color
		uarrow_color = screen_color
		darrow_color = screen_color
		form_active_text_color = button_active_color
		gauge_color = title_color
		border2_color = dialog_color
		searchbox_border2_color = dialog_color
		menubox_border2_color = dialog_color
		separate_widget = ''
		tab_len = 0
		visit_items = off
		use_shadow = off
		use_colors = on
	EOF
	export DIALOGRC="$dialogRcFile"
}

sh_update_locale() {
	local f="${dir_install}/etc/default/libc-locales"
	local cConf_file="${dir_install}/etc/locale.conf"
	local raw="${AConfLocale[_LOCALE]}"
	raw="${raw%%.*}"
	export base="${raw}.UTF-8"
	export locale="${raw}.UTF-8 UTF-8"

	sh_cmd_job "${cmsg_Ajustando} locales [/etc/default/libc-locales, /etc/locale.conf]" "
      sed -i '/^[^#]/ s/^/#/' \"$f\"
      printf '%s\n' \"$locale\" >> \"$f\"

      touch "$cConf_file"
      cat > "$cConf_file" <<-EOF
LANG=$base
LANGUAGE=$base
LC_COLLATE=C
LC_ALL=$base
EOF
   " $err_not_fatal
}

sh_update_self() {
	local repo_url="https://raw.githubusercontent.com/voidlinuxbr/void-install/main/void-install"
	local local_script="$0"
	local temp_file
	local remote_hash
	local local_hash

	# Cria um arquivo temporário para armazenar a versão remota
	temp_file=$(mktemp)
	log_msg "$(gettext 'Verificando por atualizações do script')..."

	# Baixa a versão mais recente do repositório
	if command -v curl >/dev/null 2>&1; then
		curl -sSfL "$repo_url" -o "$temp_file"
	elif command -v wget >/dev/null 2>&1; then
		wget -q "$repo_url" -O "$temp_file"
	else
		log_msg "$(gettext 'Erro: nem curl nem wget estão instalados. Atualização não pode ser realizada.')"
		rm -f "$temp_file"
		return 1
	fi

	# Calcula os hashes das versões local e remota
	remote_hash=$(sha256sum "$temp_file" | awk '{print $1}')
	local_hash=$(sha256sum "$local_script" | awk '{print $1}')

	# Compara os hashes para detectar mudanças
	if [[ "$remote_hash" != "$local_hash" ]]; then
		log_msg "$(gettext 'Nova versão encontrada. Atualizando o script...')"
		mv "$temp_file" "$local_script"
		chmod +x "$local_script"
		log_msg "$(gettext 'Atualização concluída. Recarregando o script...')"
		exec "$local_script" "$@" # Recarrega o script com os mesmos argumentos
	else
		log_msg "$(gettext 'O script já está atualizado.')"
		rm -f "$temp_file"
	fi
}

sh_choose_packages() {
	if sh_checkRepo 'https://void.chililinux.com/voidlinux/current'; then
		_EXTRAS='nano-syntax-highlighting'
		_EXTRAS+=' chili-void-grub-theme'
		_EXTRAS+=' chili-void-tools'
		_EXTRAS+=' chili-nano-config'
		_EXTRAS+=' chili-skel'
		_EXTRAS+=' chili-utils'
		_EXTRAS+=' void-utils'
		#		_EXTRAS+=' voidbr-plymouth-theme'
	fi

	if grep -qi xorg <<<"${_WINDOWMANAGER[@]}"; then
		return
	fi

	## begin packages
	declare -ga aXorg=(xorg xinit xterm xorg-fonts dbus-x11 elogind dbus-elogind polkit-elogind xdg-user-dirs xrdb)
	declare -ga aVideo=(mesa-dri linux-firmware-intel xf86-video-amdgpu xf86-video-ati mesa-nouveau-dri)
	declare -ga aPulseaudio=(pulseaudio pavucontrol pasystray gst-plugins-bad1 gst-plugins-good1 gst-plugins-ugly1 gst-plugins-base1 alsa-plugins-pulseaudio)
	declare -ga aPipewire=(pipewire wireplumber alsa-pipewire pulseaudio-utils pavucontrol libspa-bluetooth libjack-pipewire alsa-plugins-pulseaudio)
	declare -ga aDisplaymanager=(lxdm lxdm-theme-vdojo)

	if $LCUSTOM; then
		## X11
#		if ! $LONLY_TTY; then
			declare -ga aIconsAndThemes=('Adapta' 'adwaita-icon-theme' 'chili-void-beauty-icons' 'chili-void-wallpapers' 'chili-void-gnome-professional-theme' 'xfwm-axiom-theme')
			declare -ga aArchiverX=('xarchiver')
			declare -ga aBrowser=('firefox' "firefox-i18n-$(sh_get_language_without_utf8)" 'brave-bin')
			declare -ga aBluetooth=('bluez' 'bluez-alsa' 'bluedevil' 'blueman' 'bluez-cups' 'bluez-deprecated' 'gnome-bluetooth1' 'blueberry')
			declare -ga aFilemanager=('Thunar' 'thunar-archive-plugin' 'thunar-volman' 'pcmanfm' 'octoxbps')
			declare -ga aFont+=('liberation-fonts-ttf' 'dejavu-fonts-ttf' 'fonts-droid-ttf' 'fonts-croscore-ttf' 'terminus-font' 'ttf-ubuntu-font-family' 'font-iosevka')
			aFont+=('unicode-emoji' 'noto-fonts-emoji' 'font-emoji-one-color' 'unicode-emoji' 'nerd-fonts-symbols-ttf' 'font-hack-ttf')
			aFont+=('font-awesome' 'font-awesome5' 'font-awesome6' nerd-fonts-ttf)
			declare -ga aPerfumery=('conky' 'setxkbmap' 'numlockx' 'nitrogen' 'ristretto' 'mate-notification-daemon')
			declare -ga aPrinter=('cups' 'system-config-printer' 'system-config-printer-udev' 'splix' 'samsung-unified-driver' 'brother-brlaser' 'cups-pdf')
			declare -ga aTerminal=('rxvt-unicode' 'xfce4-terminal' 'cool-retro-term')
			declare -ga aEditorX=('kate' 'mousepad')
			declare -ga aMicrocode=('intel-ucode' 'linux-firmware-amd')
			declare -ga aNetworkX=('network-manager-applet' 'gvfs' 'gvfs-smb' 'gvfs-cdda')
			declare -ga aUtilityX=('mate-calc' 'xkill' 'menulibre' 'mugshot' 'ocs-url' 'remmina' 'remmina-kwallet' gparted)
#		else
			## tty
			declare -ga aDaemons=('NetworkManager' 'acpi' 'acpid' 'connman' 'irqbalance' 'avahi')
			declare -ga aArchiverTty=('unrar' 'zip' 'p7zip' 'unzip' 'bzip2')
			declare -ga aDownloader=('curl' 'wget' 'git')
			declare -ga aEditorTxt=(nano vim)
			declare -ga aUtility=('dialog' 'gettext' 'binutils' 'sed' 'grep' 'tree' 'pv' 'parted' 'rsync' 'duf' 'dfc' 'tmate' 'inetutils' 'iputils')
			aUtility+=('cifs-utils' 'ntfs-3g' 'btop' 'htop' 'parallel' 'evtest' 'bubblewrap' 'pacman' 'fakeroot' 'bsdtar' 'exa' 'cmatrix')
			aUtility+=('nvme-cli')
			declare -ga _PKGS='fastfetch pfetch bc bat fzf bash-completion vpm vsv xtools geoip geoipupdate pigz #geoip-data'
			#--repository=https://void.chililinux.com/voidlinux/current
			## end packages
#		fi
	else
#		if ! $LONLY_TTY; then
			## X11
			declare -ga aIconsAndThemes=(Adapta adwaita-icon-theme)
			declare -ga aArchiverX=()
			declare -ga aBrowser=(firefox firefox-i18n-$(sh_get_language_without_utf8))
			declare -ga aBluetooth=()
			declare -ga aFilemanager=(Thunar pcmanfm)
			declare -ga aFont+=()
			declare -ga aPerfumery=()
			declare -ga aPrinter=()
			declare -ga aTerminal=(xfce4-terminal)
			declare -ga aEditorX=()
			declare -ga aMicrocode=()
			declare -ga aNetworkX=(network-manager-applet)
			declare -ga aUtilityX=(gettext)
#		else
			## tty
			declare -ga aDaemons=(NetworkManager)
			declare -ga aArchiverTty=()
			declare -ga aDownloader=()
			declare -ga aEditorTxt=()
			declare -ga aUtility=()
			declare -ga _PKGS=''
			#--repository=https://void.chililinux.com/voidlinux/current
			## end packages
#		fi
	fi

}

declare _WINDOWMANAGER=('tty')
declare _WIFI_NETWORK="wifi_ssid"
declare _WIFI_PASSWORD="wifi_password"
#source /usr/bin/gettext.sh
#declare Interrupted="$(gettext "Interrompido!") $(pgettext "context" "Saindo...")"

declare Interrupted="$(gettext "Interrompido! Saindo...")"
trap 'printf "\n${red}$Interrupted\n"; cleanup; exit 0' INT TERM HUP

errorbeep() {
	printf '\a' # beep
}

info_msg() {
	#	notify-send "$ccabec" "$@"
	printf "\033[1m$@\n\033[m"
}

cleanup() {
	# Silencia erros no cleanup para evitar loops de erro na saída
	exec 2>/dev/null
	info_msg "$(gettext 'Removendo arquivos temporários')..."
	[[ -f "$BOOTLOG" ]] && rm -f "$BOOTLOG"
	# Só tenta desmontar se o diretório de instalação existir e estiver montado
	mountpoint -q "$dir_install" && sh_umount_fs
	exit 1
}

sh_setEnvironment() {
	[[ ! -e "$dialogRcFile" ]] && sh_create_dialogrc

	declare url_mirror='https://repo-fastly.voidlinux.org/'
	declare -g app_conf='/tmp/void-install.conf'
	declare -g dir_install='/mnt/voidlinux'
	readonly cnickefi='Void_install'
	readonly _TARBALL_ROOTFS=void-x86_64-base-custom-current.tar.xz
	readonly url_tarball="https://raw.githubusercontent.com/voidlinuxbr/void-install/refs/heads/main/${_TARBALL_ROOTFS}"
	readonly url_tarball_md5="https://raw.githubusercontent.com/voidlinuxbr/void-install/refs/heads/main/${_TARBALL_ROOTFS}.md5"
	readonly true=1
	readonly false=0
	readonly err_fatal=$true
	readonly err_not_fatal=$false
	readonly BOOTLOG="/tmp/void-install-$(sh_diahora).log"
	readonly LOGGER='/dev/tty8'
	shell='/bin/sh'

	: "${ccabec="$APP v${_VERSION_} - https://github.com/voidlinuxbr/void-install"}"
	: "${ccabecmin="$APP v${_VERSION_}"}"
	: "${DIALOG=${DIALOG:-dialog}}"
	: "${ARCH:=x86_64}"
	: "${CACHEDIR:="$(pwd -P)"/xbps-cachedir-${ARCH}}"
	: "${XBPS_INSTALL_CMD:=xbps-install}"
	: "${XBPS_INSTALL_UNPACK_ONLY:=xbps-install -Uy}"
	: "${XBPS_REMOVE_CMD:=xbps-remove}"
	: "${XBPS_QUERY_CMD:=xbps-query}"
	: "${XBPS_RINDEX_CMD:=xbps-rindex}"
	: "${XBPS_UHELPER_CMD:=xbps-uhelper}"
	: "${XBPS_RECONFIGURE_CMD:=xbps-reconfigure}"

	# flag disk info
	: "${DSK_NAME=1}"
	: "${DSK_SIZE=2}"
	: "${DSK_TRAN=3}"
	: "${DSK_MODEL=4}"
	: "${DSK_LABEL=5}"
	: "${DSK_SERIAL=6}"
	: "${DSK_PTTYPE=7}"
	: "${DSK_FSTYPE=8}"
	: "${DSK_PARTTYPENAME=9}"

	# flag languages
	: "${pt_BR=0}"
	: "${PT_BR=0}"
	: "${EN_US=1}"
	: "${DE_DE=2}"
	: "${FR_FR=3}"
	: "${LC_DEFAULT=$(sh_getLocale)}"

	# flag dialog exit status codes
	: "${D_OK=0}"
	: "${D_DONE=0}"
	: "${D_CANCEL=1}"
	: "${D_HELP=2}"
	: "${D_EXTRA=3}"
	: "${D_CONFIG=3}"
	: "${D_ITEM_HELP=4}"
	: "${D_ESC=255}"

	# flag dialog menu
	: "${LDISK=}"
	: "${LFS=}"
	: "${LPARTITION=}"
	: "${LGRUB=}"
	: "${LKEYMAP=}"
	: "${LWM=}"
	: "${LWIFI=}"
	: "${LMIRROR=}"
	: "${LSOURCE=}"
	: "${LEXTRA=}"
	: "${LAUDIO=}"
	: "${LTIMEZONE=}"
	: "${LFILE=}"

	# dialog colors
	GREEN="\Z2"
	MAGENTA="\Z5"
	REVERSE="\Zr"
	UNDERLINE="\Zu"
	BLACK="\Z0"
	YELLOW="\Z3"
	WHITE="\Z7"
	BLUE="\Z4"
	CYAN="\Z6"
	RED='\Z1'
	BOLD="\Zb"
	RESET="\Zn"
	RST='\Zn'
	: echo "$err_fatal"

	size=$(stty size)
	read -r MAXROW MAXCOL <<<"$size"
	COLUMNS=$(stty size)
	COLUMNS=${COLUMNS##* }
	if [[ "${COLUMNS}" = "0" ]]; then
		COLUMNS=80
	fi
	COL=$((COLUMNS - 8))
	SET_COL="\\033[${COL}G" # at the $COL char
	CURS_ZERO="\\033[0G"
}

sh_touchConf() {
	#		_WINDOWMANAGER=(${_WINDOWMANAGER[*]})
	cat >"$app_conf" <<-EOF
		######################################################################
		# void-install.conf
		# Gerado por void-install
		######################################################################
		WIFI_NETWORK=$_WIFI_NETWORK
		WIFI_PASSWORD=$_WIFI_PASSWORD
		PKGS="$_PKGS"
		EXTRAS="$_EXTRAS"
	EOF
	{
		declare -p LDISK
		declare -p LEFI
		declare -p LGRUB
		declare -p LBIOS
		declare -p LMKPARTED
		declare -p _WIFI_NETWORK
		declare -p _WIFI_PASSWORD
		declare -p _WINDOWMANAGER
		declare -p AsUser
		declare -p Amkfs
		declare -p Amntpoint
		declare -p AmntpointFDE
		declare -p AConfDisk
		declare -p AConfAudio
		declare -p AConfLocale
		declare -p AConfMirror
		declare -p AConfWifi
		declare -p AConfFde
		declare -p LCUSTOM
		declare -p HYPRLAND
		#	declare -p AARRAY_DSK_DEVICES
		#	declare -p AARRAY_PART_DEVICES
		#	} | sed 's/declare -/&g/' >>"$app_conf"
		#	} | sed -E 's/^declare (--|-g|-x)* //g' >>"$app_conf"
		#	} | sed 's/declare -/&g/' | sed -E 's/^declare -g-* /declare -g /g' >>"$app_conf"
	} | sed -E 's/declare -/&g/; s/^declare -g-* /declare -g /' >>"$app_conf"
}

sh_checkDisplay() {
	local msg1="$(gettext "Antes de continuar, redimensione o terminal")"
	local msg2="$(gettext "para que ele meça pelo menos 80 x 24 caracteres.")"
	local msg3="$(gettext "Caso contrário, ")"
	local msg4="$(gettext "você não poderá usar as ferramentas de partição de Disco.")"

	if [ "$(tput cols)" -lt 80 ] || [ "$(tput lines)" -lt 24 ]; then
		${DIALOG} --backtitle "$ccabec" \
			--title "$(gettext "TERMINAL MUITO PEQUENO")" \
			--msgbox "\n\
$cms1\n$cmsg2\n\
$cmsg3$cmsg4" 11 68
	fi
}

sh_lang_he() {
	grep ^he <<<"$LANG"
	return "$?"
}
export -f sh_lang_he

# Substitua a função original por esta:
sh_get_locale() {
	# Verifica se o usuário forçou uma variável (LC_ALL, LANG, etc)
	local current=${LC_ALL:-${LC_MESSAGES:-${LANG:-}}}

	# Se não houver variável, usa o fallback do sistema
	if [[ -z "$current" ]]; then
		grep _ <(locale -a) | head -1 | cut -c1-5
	else
		# Retorna apenas o código (ex: es_AR) sem o .UTF-8
		echo "${current%%.*}"
	fi
}
export -f sh_get_locale
# Cria um alias para corrigir o erro de digitação da linha 527 do script original
sh_getLocale() { sh_get_locale; }

sh_get_code_lang() {
	local LangFilter="${LANG%%.*}"
	local LangFilterLowercase="${LangFilter,,}"
	local LangClean="${LangFilterLowercase%%_*}"
	local LangCountry="${LangFilterLowercase#*_}"
	local LangFilterLowercaseModified="${LangFilterLowercase//_/-}"
	echo "$LangFilterLowercaseModified"
}
export -f sh_get_code_lang

sh_get_lang() {
	echo "$LANG"
}
export -f sh_get_lang

sh_get_language_without_utf8() {
	local LangFilter="${LANG%%.*}"
	local LangFilterModified="${LangFilter//_/-}"
	echo "$LangFilterModified"
}
export -f sh_get_language_without_utf8

sh_get_code_language() {
	local LangFilter="${LANGUAGE%%.*}"
	local LangFilterLowercase="${LangFilter,,}"
	local LangClean="${LangFilterLowercase%%_*}"
	local LangCountry="${LangFilterLowercase#*_}"
	local LangFilterLowercaseModified="${LangFilterLowercase//_/-}"
	echo "$LangFilterLowercaseModified"
}
export -f sh_get_code_language

sh_get_language() {
	echo "$LANGUAGE"
}
export -f sh_get_language

sh_catecho() {
	echo "$(<"$1")"
}
export -f sh_catecho

sh_disablePrintk() {
	if [[ -w /proc/sys/kernel/printk ]]; then
		echo 0 >/proc/sys/kernel/printk
	fi
}

sh_loadSavedConfig() {
	[[ -s "$app_conf" ]] || sh_touchConf
	if [ -f "$app_conf" ] && [ -r "$app_conf" ]; then
		# shellcheck source=/dev/null
		source "$app_conf"
	else
		die "${cmsg_falhaAbertura} $app_conf!"
	fi
	sh_setUser
	#debug $(declare -p LCUSTOM)
}

sh_setUser() {
	AsUser[cuser]=${AsUser[cuser]:-$(sh_getusernameloggeduserbyid)}
	AsUser[cfullname]=${AsUser[cfullname]:-$(sh_getfullusernameloggeduserbyGetent)}
	AsUser[cpass]=${AsUser[cpass]:-voidlinux}
	AsUser[cpassroot]=${AsUser[cpassroot]:-voidlinux}
	AsUser[chostname]=${AsUser[chostname]:-voidlinux}
	AsUser[cgroups]=${AsUser[cgroups]:-"wheel,audio,video,floppy,cdrom,optical,kvm,xbuilder"}
}

# Testa se o terminal suporta caracteres gráficos estendidos
sh_setAsciiLines() {
	#Isso força o dialog a usar caracteres ASCII básicos para as bordas.
	#if [[ "$LANG" =~ 'UTF-8' ]]; then
	if [[ "$(printf '\u250C')" =~ "┌" ]]; then
		export NCURSES_NO_UTF8_ACS=1 # Terminal suporta ACS
	else
		export NCURSES_NO_UTF8_ACS=0 # Terminal NÃO suporta ACS
	fi
}

sh_checkRoot() {
	if [[ "$(id -u)" != "0" ]]; then
		die "${red} ${cmsg_operNotRoot}"
	fi
}

sh_checkRepo() {
	local url_repo="$1"
	local response

	sh_info_msg "${cmsg_ChecandoRota} ${url_repo}"
	response=$(curl -o /dev/null -s -w "%{http_code}\n" -L "$url_repo")
	retval=$?
	if [[ "$response" -eq 200 ]]; then
		evaluate_retval "0" "$err_not_fatal" "response: $response ($url_repo)"
		return 0
	fi
	evaluate_retval "1" "$err_not_fatal" "response: $response: ${cmsg_SemRota} ($url_repo) - ${cmsg_CheckNet}"
	return 1
}

sh_checkNet() {
	xurl="$1"
	local retval

	# have internet?
	sh_info_msg "${cmsg_ChecandoRota} ${xurl}"
	response=$(curl --compressed -s -w "%{http_code}\n" -o /dev/null -k --url "${xurl}")
	retval=$?
	if [[ "$response" -eq 000 || "$response" -eq 404 ]]; then
		evaluate_retval "$err_fatal" "$err_fatal" "reponse: $response - ${cmsg_SemRota} ($xurl) - ${cmsg_CheckNet}"
	fi
	evaluate_retval "0" "$err_not_fatal" "response: $response ($xurl)"
	return 0
}

sh_downloadTarball() {
	sh_checkNet "$url_tarball" || return 1
	sh_info_msg "${cmsg_IniciandoDownload} $url_tarball"
	curl -L -C - --insecure --silent --remote-name "$url_tarball" 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
	if [[ "${PIPESTATUS[0]}" -eq 1 ]]; then
		evaluate_retval "1" "$err_fatal" "${cmsg_SemRota} ($url_mirror) - ${cmsg_CheckNet}"
	fi
	evaluate_retval "0"
	return 0
}

sh_checkTarball() {
	sh_info_msg "${cmsg_ChecandoTarball} rootfs $_TARBALL_ROOTFS"

	if ! [[ -e "$_TARBALL_ROOTFS" ]]; then
		evaluate_retval "1" "$err_not_fatal"
		rm -f "$_TARBALL_ROOTFS"
		sh_downloadTarball
	else
		evaluate_retval "0"
		return 0
	fi
	return "$?"
}

sh_checkIntegrityTarball() {
	sh_checkTarball || return 1

	sh_info_msg "${cmsg_VerificandoIntegridadeTarball} rootfs $_TARBALL_ROOTFS"
	tar -tf "$_TARBALL_ROOTFS" 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
	if ! [[ "${PIPESTATUS[0]}" -eq 0 ]]; then
		evaluate_retval "1" "$err_not_fatal"
		rm -f "$_TARBALL_ROOTFS"
		sh_downloadTarball
	else
		evaluate_retval "0"
		return 0
	fi
	return "${PIPESTATUS[0]}"
}

#dom 03 mar 2024 17:00:23 -04
sh_checkcommand() {
	local cmd="$1"
	command -v "$1" >/dev/null 2>&-
	return $?
}

sh_setVarColors() {
	#tput setaf 127 | cat -v  #capturar saida
	# Se o reset já estiver definido, não precisamos processar novamente (Cache de execução)
	[[ -n "$reset" ]] && return

	# Verifica se o tput existe
	if ! command -v tput >/dev/null 2>&1; then
		sh_unsetVarColors
		return
	fi

	# 1. Agrupamos todos os pedidos em uma única chamada de sistema.
	# A ordem aqui deve ser rigorosamente a mesma do bloco de leitura abaixo.
	local cache
	cache=$(tput -S <<<$'sgr0\nbold\nsmul\nrmul\nrev\nsetaf 0\nsetaf 196\nsetaf 2\nsetaf 3\nsetaf 4\nsetaf 5\nsetaf 6\nsetaf 7\nsetaf 8\nsetaf 202\nsetaf 125\nsetaf 61\nsetaf 9\nsetaf 10\nsetaf 11\nsetaf 12\nsetaf 13\nsetaf 14\nsetaf 15')

	# 2. Leitura em lote para as variáveis (Performance instantânea)
	{
		read -r reset
		read -r bold
		read -r underline
		read -r nounderline
		read -r reverse
		read -r c0
		read -r c196
		read -r c2
		read -r c3
		read -r c4
		read -r c5
		read -r c6
		read -r c7
		read -r c8
		read -r c202
		read -r c125
		read -r c61
		read -r c9
		read -r c10
		read -r c11
		read -r c12
		read -r c13
		read -r c14
		read -r c15
	} <<<"$cache"

	# 3. Montagem das variáveis finais (mantendo sua lógica de negrito e nomes)
	black="${bold}${c0}"
	red="${bold}${c196}"
	green="${bold}${c2}"
	yellow="${bold}${c3}"
	blue="$c4"
	pink="$c5"
	magenta="$c5"
	cyan="$c6"
	white="$c7"
	gray="$c8"
	orange="$c202"
	purple="$c125"
	violet="$c61"
	light_red="$c9"
	light_green="$c10"
	light_yellow="$c11"
	light_blue="$c12"
	light_magenta="$c13"
	light_cyan="$c14"
	bright_white="$c15"
}

sh_unsetVarColors() {
	unset reset green red bold blue cyan
	unset orange pink white yellow violet purple
	sh_setLogPrefix
}

sh_setLogPrefix() {
	COL_NC='\e[0m' # No Color
	COL_LIGHT_GREEN='\e[1;32m'
	COL_LIGHT_RED='\e[1;31m'
	TICK="${white}[${COL_LIGHT_GREEN}✓${COL_NC}${white}]"
	CROSS="${white}[${COL_LIGHT_RED}✗${COL_NC}$white]"
	INFO="[i]"
	# shellcheck disable=SC2034
	DONE="${COL_LIGHT_GREEN} done!${COL_NC}"
	OVER="\\r\\033[K"
	NORMAL="${reset}"
	SUCCESS="${green}"
	WARNING="${yellow}"
	FAILURE="${red}"
	INFO="${cyan}"
	BRACKET="${blue}"
	BMPREFIX=""
	DOTPREFIX="  ${blue}::${reset} "
	#  SUCCESS_PREFIX="${SUCCESS}  ↑  ${NORMAL}"
	SUCCESS_PREFIX=" $TICK "
	SUCCESS_SUFFIX="${BRACKET}[${SUCCESS}  OK  ${BRACKET}]${NORMAL}"
	#  FAILURE_PREFIX="${FAILURE}  ↓  ${NORMAL}"
	FAILURE_PREFIX=" $CROSS "
	FAILURE_SUFFIX="${BRACKET}[${FAILURE} FAIL ${BRACKET}]${NORMAL}"
	WARNING_PREFIX="${WARNING}  W  ${NORMAL}"
	WARNING_SUFFIX="${BRACKET}[${WARNING} WARN ${BRACKET}]${NORMAL}"
	SKIP_PREFIX="${INFO}  S  ${NORMAL}"
	SKIP_SUFFIX="${BRACKET}[${INFO} SKIP ${BRACKET}]${NORMAL}"
	WAIT_PREFIX="${WARNING}  R  ${NORMAL}"
	WAIT_SUFFIX="${BRACKET}[${WARNING} WAIT ${BRACKET}]${NORMAL}"
}

replicate() {
	local Var
	printf -v Var %"$2s" " "
	echo "${Var// /$1}"
}

padr() {
	text=$1
	COLS=$2
	char=$3
	if test $# -eq 1; then
		COLS=$(tput cols)
		char='='
	fi
	printf "%*s\n" "$COLS" "$text" | sed "s/ /$char/g"
}

msg() {
	((++ncounter))
	cinfo="$1"
	cfmt="$(fmt)"
	ufmt=$(unfmt "$cfmt")
	last_msg="$2"
	logmessage="$ufmt $last_msg"
	logmessage=${logmessage/INFO /}
	#	notify-send "${ccabec}" "${logmessage}"
	printf "%s\n" "$(timespec) [ $cinfo ]$ufmt ${logmessage}" 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER

	if ((grafico)); then
		logmessage="$last_msg"
		${DIALOG} \
			--no-collapse \
			--colors \
			--title "$cinfo" \
			--backtitle "$ccabec" \
			--infobox "\nStep:${BOLD}${YELLOW}${ufmt} ${RESET}${BOLD}$logmessage" \
			8 100
	else
		log_info_msg "$(fmt) ${last_msg}"
	fi
}

msgNEW() {
	((++ncounter))
	local cinfo="$1"
	local last_msg="$2"
	# Pega o último argumento para ver se é "silent"
	local mode="${@: -1}"

	cfmt="$(fmt)"
	ufmt=$(unfmt "$cfmt")
	logmessage="$ufmt $last_msg"
	logmessage=${logmessage/INFO /}

	# Seu log original
	printf "%s\n" "$(timespec) [ $cinfo ]$ufmt ${logmessage}" 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER

	if ((grafico)); then
		# Só abre o infobox se NÃO for silent
		if [[ "$mode" != "silent" ]]; then
			logmessage="$last_msg"
			${DIALOG} \
				--no-collapse \
				--colors \
				--title "$cinfo" \
				--backtitle "$ccabec" \
				--infobox "\nStep:${BOLD}${YELLOW}${ufmt} ${RESET}${BOLD}$logmessage" \
				8 100
		fi
	else
		log_info_msg "$(fmt) ${last_msg}"
	fi
}

fmt() {
	printf "${bold}${yellow}%03d/%03d${reset}" "$njobs" "$ncounter"
	return $?
}

mensagem() {
	cinfo="$1"
	last_msg="$2"
	${DIALOG} \
		--no-collapse \
		--colors \
		--title "$cinfo" \
		--backtitle "$ccabec" \
		--infobox "$last_msg" \
		8 100
}

unfmt() {
	local last_msg="$*"
	logmessage="${last_msg/${bold}${yellow}/}"
	logmessage="${logmessage/${reset}/}"
	echo "$logmessage"
}

log_info_msg() {
	last_msg="$*"

	if ! ((quiet)); then
		echo -n -e "${BMPREFIX}${*}"
	fi
	return 0
}

log_info_msg_level() {
	last_msg="$*"

	if ! ((quiet)); then
		echo -n -e "   ${BMPREFIX}${*}"
	fi
	return 0
}

log_error() {
	if ! ((quiet)); then
		echo -e "   ${FAILURE_PREFIX}${*}"
	fi
	return 0
}

log_msg_tab() {
	if ! ((quiet)); then
		echo -e "   ${DOTPREFIX}${*}"
	fi
	return 0
}

log_msg() {
	if ! ((quiet)); then
		echo -e "${DOTPREFIX}${*}"
	fi
	return 0
}

evaluate_retval() {
	local error_value="$?"
	local error_fatal="$2"
	local cmsgdie="$3"
	local level="$4"

	[[ -z "$error_fatal" ]] && error_fatal=$true

	if [[ $# -gt 0 ]]; then
		error_value="$1"
	fi

	if [[ "${error_value}" = 0 ]]; then
		if [[ -n "${level}" ]]; then
			log_success_msg_level ''
		else
			log_success_msg ''
		fi
	else
		if [[ -n "${level}" ]]; then
			log_failure_msg_level ''
		else
			log_failure_msg ''
		fi
	fi

	if ((error_value)); then
		if ((error_fatal)); then
			[[ -z "$cmsgdie" ]] && die "${cmsg_InstalacaoAbortada}..." || die "$cmsgdie"
		else
			[[ -n "$cmsgdie" ]] && log_failure_msg_level "${cmsgdie}"
			log_error "${cmsg_Error_not_fatal} $BOOTLOG"
		fi
	fi
	[[ -n "$cmsgdie" ]] && log_success_msg_level "${cmsgdie}"
	return "${error_value}"
}

log_failure_msg_level() {
	if ! ((quiet)) && ! ((grafico)); then
		echo -n -e "     ${BMPREFIX}${@}"
		echo -e "   ${CURS_ZERO}${FAILURE_PREFIX}${SET_COL}${FAILURE_SUFFIX}"
	fi
	logmessage=${last_msg/$bold$red$green$yellow/}
	printf "%s\n" "$(timespec) [ FAIL ]${logmessage}" 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
	replicate "#" "100" | tee -i -a "$BOOTLOG" >$LOGGER
	return 0
}

log_success_msg_level() {
	if ! ((quiet)) && ! ((grafico)); then
		echo -n -e "     ${BMPREFIX}${@}"
		echo -e "   ${CURS_ZERO}${SUCCESS_PREFIX}${SET_COL}${SUCCESS_SUFFIX}"
	fi
	logmessage=$(unfmt "$last_msg")
	printf "%s\n" "$(timespec) [  OK  ]${logmessage}" 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
	replicate "#" "100" | tee -i -a "$BOOTLOG" >$LOGGER
	return 0
}

log_failure_msg() {
	if ! ((quiet)) && ! ((grafico)); then
		echo -n -e "${BMPREFIX}${@}"
		echo -e "${CURS_ZERO}${FAILURE_PREFIX}${SET_COL}${FAILURE_SUFFIX}"
	fi
	logmessage=${last_msg/$bold$red$green$yellow/}
	printf "%s\n" "$(timespec) [ FAIL ]${logmessage}" 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
	replicate "#" "100" | tee -i -a "$BOOTLOG" >$LOGGER
	return 0
}

log_success_msg() {
	if ! ((quiet)) && ! ((grafico)); then
		echo -n -e "${BMPREFIX}${@}"
		echo -e "${CURS_ZERO}${SUCCESS_PREFIX}${SET_COL}${SUCCESS_SUFFIX}"
	fi
	logmessage=$(unfmt "$last_msg")
	printf "%s\n" "$(timespec) [  OK  ]${logmessage}" 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
	replicate "#" "100" | tee -i -a "$BOOTLOG" >$LOGGER
	return 0
}

timespec() {
	STAMP="$(date +"%b %d %T %:z") $(hostname)"
	echo "$STAMP"
	return 0
}

function debug() {
	whiptail \
		--fb \
		--clear \
		--backtitle "[debug]$0" \
		--title "[debug]$0" \
		--yesno "${*}\n" \
		0 40
	result=$?
	if ((result)); then
		exit
	fi
	return $result
}

info() {
	msg "${fmt} $@"
	evaluate_retval "0"

	${DIALOG} \
		--colors \
		--title "$1" \
		--backtitle "$ccabec" \
		--ok-label "${cmsg_ok}" \
		--msgbox "$2\n$3\n$4\n$5\n$6\n$7" \
		0 0
}

infobox() {
	${DIALOG} \
		--colors \
		--no-shadow \
		--no-mouse \
		--backtitle "${BOLD}${WHITE}${ccabec}${RESET}" \
		--title "${TITLE}" \
		--aspect 20 \
		--infobox "$@"
}

alerta() {
	msg "${fmt} $@"
	evaluate_retval "0"

	${DIALOG} \
		--colors \
		--clear \
		--no-collapse \
		--no-cr-wrap \
		--title "$1" \
		--backtitle "$ccabec" \
		--ok-label "${cmsg_ok}" \
		--msgbox "\n$2\n$3\n$4\n$5\n$6" \
		10 81
}

conf() {
	xtitle="$1"
	shift
	${DIALOG} \
		--colors \
		--title "$xtitle" \
		--backtitle "$ccabec" \
		--no-collapse \
		--no-cr-wrap \
		--clear \
		--yes-label "${cmsg_yeslabel}" \
		--no-label "${cmsg_nolabel}" \
		--yesno "$*" \
		0 0
	nchoice=$?
	return "$nchoice"
}

infoconf() {
	infotitle=$1
	inforesult=$2
	conftitle=$3
	shift 3
	${DIALOG} --title "$infotitle" \
		--begin 05 10 --infobox "$inforesult" 14 75 \
		--and-widget \
		--begin 20 10 \
		--colors \
		--no-collapse \
		--no-cr-wrap \
		--title "$conftitle" \
		--backtitle "$ccabec" \
		--yes-label "${cmsg_yeslabel}" \
		--no-label "${cmsg_nolabel}" \
		--yesno "$*" \
		10 75
	nchoice=$?
	return "$nchoice"
}

display_result() {
	${DIALOG} \
		--colors \
		--title "$2" \
		--backtitle "$ccabec" \
		--no-collapse \
		--no-cr-wrap \
		--no-nl-expand \
		--ok-label "${cmsg_ok}" \
		--msgbox "$1" \
		0 0
}

#			15 100

notconf() {
	xtitle="$1"
	shift
	${DIALOG} \
		--colors \
		--title "$xtitle" \
		--backtitle "$ccabec" \
		--yes-label "${cmsg_nolabel}" \
		--no-label "${cmsg_yeslabel}" \
		--yesno "$*" \
		10 100
	return $?
}

sh_testDisk() {
	local result=0

	fdisk -l "${AConfDisk[_DEVICE]}" 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
	result="${PIPESTATUS[0]}"
	if ! ((quiet)); then
		evaluate_retval "$result"
	fi
	return "$result"
}

sh_mkparted() {
	local nchoice=false
	local withswap=true
	local label_type='gpt'
	local ext=$(sh_getNvme)
	local cini=''
	local cpart=''
	local CSCRIPT=''

	sh_info_msg "${cmsg_TestandoDisco} ${AConfDisk[_DEVICE]}"
	if ! sh_testDisk; then
		die "${cmsg_ErroLeituraDisco}: ${AConfDisk[_DEVICE]}."
	fi

	if ! ((grafico)); then
		if ! ((quiet)); then
			replicate "=" "$COLUMNS"
			if ! fdisk -l "${AConfDisk[_DEVICE]}"; then
				die "${cmsg_ErroLeituraDisco}: ${AConfDisk[_DEVICE]}."
			fi
			replicate "=" "$COLUMNS"
			if ! $LMKPARTED; then
				echo "${yellow}${cwarning} ${red}${cmsg_todos_os_dados_serao_perdidos}${reset}"
			fi
		fi
	fi

	#	if $LMKPARTED; then
	#		return 0
	#	fi

	if ! ((grafico)); then
		if readconf "${red}${cmsg_ContinuarParticionamento} ${yellow}${AConfDisk[_DEVICE]} ${reset}?"; then
			nchoice=true
		fi
	else
		if [[ $(sh_toBytes "$(sh_splitarray "${AARRAY_DSK_DEVICES[${AConfDisk[_DEVICE]}]}" 2)") -lt $(sh_toBytes "4G") ]]; then
			if ! infoconf "${cmsg_Disco}" "$(fdisk -l "${AConfDisk[_DEVICE]}")" \
				"${YELLOW}${cmsg_CriandoParticoes} ${AConfDisk[_DEVICE]}" \
				"\n${cmsg_TamanhoInsuficiente}\n${cmsg_DesejaProsseguir}"; then
				return 1
			fi
			withswap=false
		else
			if ! infoconf "${cmsg_Disco}" "$(fdisk -l "${AConfDisk[_DEVICE]}")" \
				"${YELLOW}${cmsg_CriandoParticoes} ${AConfDisk[_DEVICE]}" \
				"\n${cmsg_DesejaCriarParticaoSwap}"; then
				withswap=false
			fi
		fi

		if ! conf "${YELLOW}${cwarning}" \
			"DEVICE  : ${RED}${AConfDisk[_DEVICE]}${RESET}\n" \
			"MODEL  : ${RED}$MODEL_ORIGEM${RESET}\n" \
			"\n${RED}${cmsg_todos_os_dados_serao_perdidos}${RESET}" \
			"\n${cmsg_ContinuarParticionamento} ${AConfDisk[_DEVICE]} ?\n"; then
			return 1
		fi
		nchoice=true
	fi

	if $nchoice; then
		sh_info_msg "${cmsg_CriandoParticoes} ${AConfDisk[_DEVICE]}"
		Amntpoint=()
		[[ "${AConfDisk[_DISKTABLE]}" = "EFI" || "${AConfDisk[_DISKTABLE]}" = "GPT_BIOS" ]] && label_type='gpt' || label_type='msdos'
		CSCRIPT+="mklabel $label_type "

		if [[ "$label_type" = "gpt" ]]; then
			CSCRIPT+='mkpart primary fat32 1MiB   2MiB set 1 bios_grub on name 1 BIOS '
			CSCRIPT+='mkpart primary fat32 2MiB 258MiB set 2 esp on       name 2 EFI  '
			#			Amntpoint+=(["${AConfDisk[_DEVICE]}${ext}1"]="||0")
			Amntpoint+=(["${AConfDisk[_DEVICE]}${ext}2"]="/boot/efi|vfat|1")
			cini='258MiB'
			cpart='3'
			if $withswap; then
				CSCRIPT+="mkpart primary linux-swap $cini 3G name $cpart SWAP "
				Amntpoint+=(["${AConfDisk[_DEVICE]}${ext}$cpart"]="none|swap|1")
				cini='3G'
				cpart='4'
			fi
			CSCRIPT+="mkpart primary $cini 100% name $cpart ROOT "
			Amntpoint+=(["${AConfDisk[_DEVICE]}${ext}$cpart"]="/|ext4|1")
		else
			cini='1MiB'
			cpart='1'
			if $withswap; then
				CSCRIPT+="mkpart primary linux-swap $cini 3G "
				Amntpoint+=(["${AConfDisk[_DEVICE]}${ext}$cpart"]="none|swap|1")
				cini='3G'
				cpart='2'
			fi
			CSCRIPT+="mkpart primary $cini 100% set $cpart boot on "
			Amntpoint+=(["${AConfDisk[_DEVICE]}${ext}$cpart"]="/|ext4|1")
		fi
		CSCRIPT+='align-check optimal 1'
		CSCRIPT+='align-check optimal 2'
		CSCRIPT+='align-check optimal 3'

		if $withswap; then
			CSCRIPT+='align-check optimal 4'
		fi

		parted --script "${AConfDisk[_DEVICE]}" -- "$CSCRIPT" 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
		evaluate_retval "${PIPESTATUS[0]}"
		parted --script "${AConfDisk[_DEVICE]}" -- print 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
		Amkfs+=(["vfat"]="mkfs.vfat")
		Amkfs+=(["swap"]="mkswap")
		Amkfs+=(["ext4"]="mkfs.ext4")
		LMKPARTED=true
		LFS=true
		LPARTITION=true
		#		sync 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
		#		partprobe 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
	else
		die "${cmsg_InstalacaoAbortada}..."
	fi
}

sh_update_mirror() {
	sh_cmd_job "${cmsg_Configurando} ${cmsg_Mirror,,} ${cmsg_Em} $dir_install" "
      cat >"$dir_install/etc/xbps.d/00-repository-main.conf" <<-EOF
repository=${url_mirror}/current
repository=${url_mirror}/current/nonfree
repository=${url_mirror}/current/multilib
repository=${url_mirror}/current/multilib/nonfree

repository=https://void.chililinux.com/voidlinux/current
#repository=https://void.chililinux.com/voidlinux/current/extras
#repository=https://void.chililinux.com/voidlinux/current/nonfree
#repository=https://void.chililinux.com/voidlinux/current/multilib
#repository=https://void.chililinux.com/voidlinux/current/multilib/nonfree
EOF
   " $err_not_fatal
}

sh_update_sshd() {
	sh_cmd_job "${cmsg_Ajustando} sshd_config" "
   cat >> ${dir_install}/etc/ssh/sshd_config <<-EOF
KbdInteractiveAuthentication Yes
X11Forwarding Yes
PermitRootLogin Yes
PubkeyAuthentication Yes
PubkeyAcceptedKeyTypes=+ssh-rsa
AuthorizedKeysFile      .ssh/authorized_keys
PasswordAuthentication Yes
ChallengeResponseAuthentication Yes
UsePAM yes
EOF
   " $err_not_fatal
}

sh_update_rc_conf() {
	local cfile_rc="$dir_install/etc/rc.conf"

	sh_cmd_job "${cmsg_Ajustando} rc.conf" '
      if [[ ! -e $cfile_rc ]]; then
         touch $cfile_rc
      fi
      if [[ -e $cfile_rc ]]; then
         sed -i -e "s|HOSTNAME=.*|HOSTNAME=${AsUser[chostname]}|g" $cfile_rc
         sed -i -e "s|#\?HOSTNAME=.*|HOSTNAME=${AsUser[chostname]}|g" $cfile_rc
         sed -i -e "s|HARDWARECLOCK=.*|HARDWARECLOCK=${AConfLocale[_CLOCK]}|g" $cfile_rc
         sed -i -e "s|#\?HARDWARECLOCK=.*|HARDWARECLOCK=${AConfLocale[_CLOCK]}|g" $cfile_rc
         sed -i -e "s|FONT=.*|FONT=${AConfLocale[_FONT]}|g" $cfile_rc
         sed -i -e "s|#\?FONT=.*|FONT=${AConfLocale[_FONT]}|g" $cfile_rc
         sed -i -e "s|KEYMAP=.*|KEYMAP=${AConfLocale[_KEYMAP]}|g" $cfile_rc
         sed -i -e "s|#\?KEYMAP=.*|KEYMAP=${AConfLocale[_KEYMAP]}|g" $cfile_rc
         sed -i -e "s|TIMEZONE=.*|TIMEZONE=${AConfLocale[_TIMEZONE]}|g" $cfile_rc
         sed -i -e "s|#\?TIMEZONE=.*|TIMEZONE=${AConfLocale[_TIMEZONE]}|g" $cfile_rc
      fi
   ' $err_not_fatal

	sh_chroot_job "${cmsg_Ajustando} timezone pass2" "
      ln -sf /usr/share/zoneinfo/${AConfLocale[_TIMEZONE]} /etc/localtime
   " $err_not_fatal
}

sh_update_hostname() {
	sh_cmd_job "${cmsg_Ajustando} hostname" "
      echo ${AsUser[chostname]} > ${dir_install}/etc/hostname
   " $err_not_fatal
}

sh_update_rc_local() {
	sh_cmd_job "${cmsg_Ajustando} rc.local" "
      cat > ${dir_install}/etc/rc.local <<-EOF
#HOSTNAME="${AsUser[chostname]}"
#HARDWARECLOCK="${AConfLocale[_CLOCK]}"
#TIMEZONE="${AConfLocale[_TIMEZONE]}"
#KEYMAP="${AConfLocale[_KEYMAP]}"
#hwclock --systohc
EOF
   " $err_not_fatal
}

install_skel_user() {
	local aname=('config-common')
	local x

	for x in "${_WINDOWMANAGER[@]}"; do
		case "$x" in
		"tty") : ;;
		"awesome") aname+=(config-awesome) ;;
		"xorg") : ;;
		"bspwm") aname+=(config-bspwm) ;;
		"blackbox") aname+=(config-blackbox) ;;
		"dwm") aname+=(config-dwm) ;;
		"enlightenment") aname+=(config-enlightenment) ;;
		"fluxbox") aname+=(config-fluxbox) ;;
		"gnome") aname+=(config-gnome) ;;
		"hyprland") aname+=(config-hyprland) ;;
		"i3wm") aname+=(config-i3wm) ;;
		"lxde") aname+=(config-lxde) ;;
		"lxqt") aname+=(config-lxqt) ;;
		"mate") aname+=(config-mate) ;;
		"openbox") aname+=(config-openbox) ;;
		"plasma") aname+=(config-plasma) ;;
		"sway") aname+=(config-sway) ;;
		"twm") aname+=(config-twm) ;;
		"xfce4") aname+=(config-xfce) ;;
		esac
	done

	#skel
	for path in "${aname[@]}"; do
		if [[ -d "$path" ]]; then
			cp -RLf $path/. "$dir_install/" 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
		fi
	done
	cp -RLf config-common/etc/skel/. "$dir_install/root/" 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
	return 0
}

sh_update_bashrc() {
	if $LCUSTOM; then
		sh_cmd_job "${cmsg_Ajustando} bashrc" "
         install_skel_user
      " $err_not_fatal
	fi
}

sh_update_wpa_suplicant() {
	sh_cmd_job "${cmsg_Ajustando} wpa_supplicant.conf" "
      cat >"$dir_install/etc/wpa_supplicant/wpa_supplicant.conf" <<-EOF
ctrl_interface=/run/wpa_supplicant
ctrl_interface_group=wheel
update_config=1
fast_reauth=1

network={
   ssid=P"$_WIFI_NETWORK"
   psk="$_WIFI_PASSWORD"
   mesh_fwding=1
}
EOF
   " $err_not_fatal
}

sh_update_console() {
	local cfile="etc/default/grub"

	sh_cmd_job "${cmsg_Ajustando} console grub" "
      if [[ -e "$dir_install/$cfile" ]]; then
		   sed -i "$dir_install/$cfile" \
			   -e 's|#\(GRUB_TERMINAL_INPUT\).*|\1=console|' \
   			-e 's|#\(GRUB_TERMINAL_OUTPUT\).*|\1=console|'
	   fi
   " $err_not_fatal
}

sh_update_Xkeymap() {
	if [[ "${AConfLocale[_KEYMAP]}" != 'br-abnt2' ]]; then
		return 0
	fi

	sh_cmd_job "${cmsg_Ajustando} ${cmsg_Teclado,,} ${AConfLocale[_KEYMAP]} (X11)" "
   	if [[ ! -d "$dir_install/etc/X11/xorg.conf.d" ]]; then
   	   mkdir -p "$dir_install/etc/X11/xorg.conf.d"
      fi
   	if [[ ! -e "$dir_install/etc/X11/xorg.conf.d/10-keyboard.conf" ]]; then
   	   cat >"$dir_install/etc/X11/xorg.conf.d/10-keyboard.conf" <<-EOF
Section "InputClass"
   Identifier "Keyboard Br Abnt2"
   MatchIsKeyboard "on"
   Option "XkbModel" "pc105"
   Option "XkbLayout" "br"
   Option "XkbVariant" "abnt2"
   Option "XKbOptions" ""
EndSection
EOF
      fi
   " $err_not_fatal
}

sh_check_util_fs() {
	for i in "${!Amkfs[@]}"; do
		cmdsearch="${Amkfs[$i]}"
		if [[ -z $(command -v "$cmdsearch") ]]; then
			result="\n${RED}${cmsg_ERRO}${RESET}: ${cmsg_CommandNotFound} ${BOLD}${CYAN}'$cmdsearch'${RESET}"
			result+="\n--------------${cmsg_ImpossivelContinuar}-------------"
			result+="\n${cmsg_ImpossivelContinuar1}"
			result+="\n${cmsg_ImpossivelContinuar2} \$PATH"
			result+="\n-----------------------------------------------"
			display_result "$result" "${cmsg_CommandNotFound}"
			die "${cmsg_ERRO}: ${cmsg_InstalacaoAbortada}... ${cmsg_CommandNotFound} ${bold}${cyan}'$cmdsearch'${reset}"
			return 1
		fi
	done
	return 0
}

sh_make_fs() {
	local i
	local _PART
	local format
	local fstype

	sh_check_util_fs
	for i in "${!Amntpoint[@]}"; do
		_PART="$i"
		fstype="$(sh_splitarray "${Amntpoint[$i]}" 2)"
		format="$(sh_splitarray "${Amntpoint[$i]}" 3)"

		if [[ "$format" = "1" ]]; then
			sh_info_msg "${cmsg_FormatandoParticao} ${_PART} FS ${fstype,,}"
			declare -A fsparms=(
				[ext2]="-F -L VOID"
				[ext3]="-F -L VOID"
				[ext4]="-F -L VOID"
				[btrfs]="-f -L VOID"
				[f2fs]="-f -l VOID"
				[xfs]="-f -L VOID"
				[jfs]="-f -L VOID"
				[vfat]="-F32 -n EFI"
				[reiserfs]="-f -l VOID"
			)

			if [[ "$fstype" = "swap" ]]; then
				wipefs -a "${_PART}"
				mkswap "${_PART}" 2>&1 | tee -i -a "$BOOTLOG" >"$LOGGER"
			else
				wipefs -a "${_PART}"
				mkfs.$fstype ${fsparms[$fstype]} ${_PART} 2>&1 | tee -i -a "$BOOTLOG" >"$LOGGER"
			fi
			evaluate_retval "${PIPESTATUS[0]}"
		fi
	done

	if $LVM; then
		sh_make_fsLvm
	fi
}

sh_umount_fs() {
	sh_cmd_job "${cmsg_DismountFileSystem}" "
	   umount -frl "$dir_install"
      LBIND=false
	" $err_not_fatal
}

sh_stop_mount() {
	local nchoice

	sh_cmd_job "${cmsg_umount_partition}" "
      umount -rl "$dir_install"
      nchoice="${PIPESTATUS[0]}"
      evaluate_retval 0
   	[[ $nchoice -eq 0 || $nchoice -eq 32 ]] && LMOUNT=$false
	   [[ $LMOUNT -eq $false ]] && return 0 || return 1
   " $err_not_fatal
}

sh_ignore_error() {
	"$@" 2>/dev/null
	return 0
}

sh_chroot_maybe_add_mount() {
	local cond=$1
	shift
	if eval "$cond"; then
		sh_mount_bind "$@"
	fi
}

sh_mount_bind() {
	mount "$@" 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
}

sh_init_bind() {
	local nchoice

	if ! $LBIND; then
		sh_info_msg "${cmsg_MontandoAmbiente} chroot ${cyan}=> ${yellow}${dir_install}"
		for i in /proc /sys /dev /dev/pts /dev/shm /run /tmp; do
			mkdir -p "$dir_install$i" 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
		done

		sh_mount_bind proc "${dir_install}/proc" -t proc -o nosuid,noexec,nodev &&
			sh_mount_bind sys "${dir_install}/sys" -t sysfs -o nosuid,noexec,nodev,ro &&
			sh_ignore_error sh_chroot_maybe_add_mount "[[ -d '$dir_install/sys/firmware/efi/efivars' ]]" \
				efivarfs "$dir_install/sys/firmware/efi/efivars" -t efivarfs -o nosuid,noexec,nodev &&
			sh_mount_bind udev "${dir_install}/dev" -t devtmpfs -o mode=0755,nosuid &&
			sh_mount_bind devpts "${dir_install}/dev/pts" -t devpts -o mode=0620,gid=5,nosuid,noexec &&
			sh_mount_bind shm "${dir_install}/dev/shm" -t tmpfs -o mode=1777,nosuid,nodev &&
			sh_mount_bind /run "${dir_install}/run" -t tmpfs -o nosuid,nodev,mode=0755 &&
			sh_mount_bind tmp "${dir_install}/tmp" -t tmpfs -o mode=1777,strictatime,nodev,nosuid
		evaluate_retval
		nchoice=$?
		[[ $nchoice -eq 0 ]] && LBIND=true
	fi
	$LBIND && return 0 || return 1
}

sh_stop_bind() {
	local nchoice

	sh_info_msg "${cmsg_DesMontandoAmbiente} chroot"
	{
		umount -r "${dir_install}/proc"
		umount -r "${dir_install}/sys"
		umount -r "$dir_install/sys/firmware/efi/efivars"
		umount -r "${dir_install}/dev/shm"
		umount -r "${dir_install}/dev/pts"
		umount -r "${dir_install}/dev"
		umount -r "${dir_install}/run"
		umount -r "${dir_install}/tmp"
	} 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
	nchoice="${PIPESTATUS[0]}"
	evaluate_retval 0

	[[ $nchoice -eq 0 ]] && LBIND=false
	$LBIND && return 1 || return 0
}

sh_info_msg() {
	local _msg="$1"
	last_msg="$_msg"
	msg "INFO" "$last_msg" "$(log_info_msg "$last_msg")"
}

sh_cmd_jobOLD() {
	local cmsg="$1"
	local cjob="$2"
	local erro_fatal="$3"
	local lretval=0

	cmsg+=" ${cmsg_Em} ${yellow}$dir_install"
	last_msg="$cmsg"
	msg "INFO" "$last_msg" "$(log_info_msg "$last_msg")"

	if ((grafico)); then
		eval "$cjob" 2>&1 | tee -i -a "$BOOTLOG" | dialog --colors --backtitle "$cmsg" --title "$cmsg" --begin 10 50 --progressbox 24 120 --and-widget
	else
		eval "$cjob" 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
	fi

	lretval="${PIPESTATUS[0]}"
	evaluate_retval "$lretval" "$erro_fatal"
	shell='/bin/sh'
	return "$lretval"
}

sh_cmd_job() {
	local cmsg="$1"
	local cjob="$2"
	local erro_fatal="$3"
	local lretval=0

	# Adiciona contexto à mensagem
	cmsg+=" ${cmsg_Em} ${yellow}$dir_install"
	last_msg="$cmsg"

	# Chama msg() com um flag 'silent' para não abrir um infobox redundante
	# se o gráfico estiver ligado, já que vamos mostrar no progressbox abaixo.
	msg "INFO" "$last_msg" "$(log_info_msg "$last_msg")" "silent"

	if ((grafico)); then
		# Grupo de comandos { ... ; } garante que o echo e o eval entrem no mesmo pipe
		{
			echo -e "${BOLD}${YELLOW}>>> Step: ${ufmt} ${last_msg}${RESET}\n"
			eval "$cjob"
		} 2>&1 | tee -i -a "$BOOTLOG" | dialog \
			--colors \
			--backtitle "$ccabec" \
			--title " [ $cinfo ] " \
			--begin 10 50 \
			--progressbox 24 120 \
			--and-widget

		lretval="${PIPESTATUS[0]}"
	else
		# Se não for gráfico, faz a mesma injeção mas joga para o LOGGER
		# Assim, no TTY8, você vê o cabeçalho antes das linhas de comando
		{
			echo "-------------------------------------------------------"
			echo ">>> TASK: $last_msg"
			echo "-------------------------------------------------------"
			eval "$cjob"
		} 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER

		lretval="${PIPESTATUS[0]}"
	fi

	evaluate_retval "$lretval" "$erro_fatal"
	return "$lretval"
}

strip_ansi() {
	printf '%s' "$1" |
		sed \
			-e 's/\x1B\[[0-9;]*[A-Za-z]//g' \
			-e 's/\x1B[][()#;?]*[0-9A-Za-z]//g'
}

sh_chroot_jobOLD() {
	local cmsg="$1"
	local cjob="$2"
	local erro_fatal="$3"
	local level="$4"
	local lretval=0

	last_msg="$cmsg"
	if [[ -n "$level" ]]; then
		msg "INFO" "$last_msg" "$(log_info_msg_level "$last_msg")"
	else
		msg "INFO" "$last_msg" "$(log_info_msg "$last_msg")"
	fi

	if ((grafico)); then
		clean_logmessage="$(strip_ansi "$logmessage")"
		chroot "$dir_install" "$shell" -c "$cjob" 2>&1 | tee -i -a "$BOOTLOG" |
			dialog \
				--colors \
				--backtitle "$ccabec" \
				--title "\Zb\Z3Step:$ufmt \Z1==>\Zn \Z7[$clean_logmessage]\Zn \Z6[$(sh_time_elapsed)]\Zn" \
				--progressbox $((MAXROW / 2)) $((MAXCOL - 20))
	else
		chroot "$dir_install" "$shell" -c "$cjob" 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
	fi

	lretval="${PIPESTATUS[0]}"
	evaluate_retval "$lretval" "$erro_fatal" "" "$level"
	shell='/bin/sh'
	return "$lretval"
}

sh_chroot_job() {
	local cmsg="$1"
	local cjob="$2"
	local erro_fatal="$3"
	local level="$4"
	local lretval=0

	last_msg="$cmsg"

	# CHAMADA DA MSG: Agora com "silent" para não cagar o progressbox abaixo
	if [[ -n "$level" ]]; then
		msg "INFO" "$last_msg" "$(log_info_msg_level "$last_msg")" "silent"
	else
		msg "INFO" "$last_msg" "$(log_info_msg "$last_msg")" "silent"
	fi

	if ((grafico)); then
		clean_logmessage="$(strip_ansi "$logmessage")"
		# SEU CÓDIGO ORIGINAL ABAIXO
		chroot "$dir_install" "$shell" -c "$cjob" 2>&1 | tee -i -a "$BOOTLOG" |
			dialog \
				--colors \
				--backtitle "$ccabec" \
				--title "\Zb\Z3Step:$ufmt \Z1==>\Zn \Z7[$clean_logmessage]\Zn \Z6[$(sh_time_elapsed)]\Zn" \
				--progressbox $((MAXROW / 2)) $((MAXCOL - 20))
	else
		chroot "$dir_install" "$shell" -c "$cjob" 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
	fi

	lretval="${PIPESTATUS[0]}"
	evaluate_retval "$lretval" "$erro_fatal" "" "$level"
	shell='/bin/sh'
	return "$lretval"
}

sh_make_user() {
	local user="${AsUser[cuser]}"

	if [[ -n "${AsUser[cuser]}" ]]; then
		if [[ -n "${AsUser[cfullname]}" ]]; then
			sh_chroot_job "${cmsg_CriandoUsuario}: ${AsUser[cuser]} - ${AsUser[cfullname]}" "useradd -m ${AsUser[cuser]} -G ${AsUser[cgroups]} -p ${AsUser[cpass]} -c '${AsUser[cfullname]}'"
		else
			sh_chroot_job "${cmsg_CriandoUsuario}: ${AsUser[cuser]} - ${AsUser[cfullname]}" "useradd -m ${AsUser[cuser]} -G ${AsUser[cgroups]} -p ${AsUser[cpass]}"
		fi
		sh_chroot_job "${cmsg_AjustandoSenhaUsuario}: ${AsUser[cuser]}" "(echo ${AsUser[cuser]}:${AsUser[cpass]}) | chpasswd -m > /dev/null 2>&1"
	fi

	if [[ -n "${AsUser[cpassroot]}" ]]; then
		sh_chroot_job "${cmsg_AjustandoSenhaUsuario}: root" "(echo root:${AsUser[cpassroot]}) | chpasswd -m > /dev/null 2>&1"
		sh_chroot_job "${cmsg_AtivandoBashUsuario}: root" "chsh -s /bin/bash root"
	fi

	sh_update_sudoers
}

sh_update_sudoers() {
	local user="${AsUser[cuser]}"

	if [ -d $dir_install/etc/sudoers.d ]; then
		echo "# Enable sudo for login '$user'" >"$dir_install/etc/sudoers.d/$user"
		echo "$user ALL=(ALL:ALL) NOPASSWD: ALL" >>"$dir_install/etc/sudoers.d/$user"
		echo "# enable the sudoers entry for members of group wheel" >"$dir_install/etc/sudoers.d/wheel"
		echo "%wheel ALL=(ALL:ALL) NOPASSWD: ALL" >>"$dir_install/etc/sudoers.d/wheel"
		unset user
	fi
}

sh_make_fstab() {
	local i
	local _part
	local label
	local fstype
	local format
	local size
	local mntpoint
	local fsorder=1

	if ! $LVM; then
		sh_info_msg "${cmsg_Gerando} fstab pass1 ${cmsg_Em} $dir_install"

		echo "tmpfs                                           /tmp           tmpfs            defaults,nosuid,nodev,noatime,mode=1777 0 0" >"$dir_install/etc/fstab"
		echo "tmpfs                                           /var/log       tmpfs            defaults,noatime,mode=0755              0 0" >>"$dir_install/etc/fstab"
		echo "proc                                            /proc          proc             nodev,noexec,nosuid                     0 0" >>"$dir_install/etc/fstab"

		for i in "${!Amntpoint[@]}"; do
			_part="$i"
			mntpoint="$(sh_splitarray "${Amntpoint[$i]}" 1)"
			fstype="$(sh_splitarray "${Amntpoint[$i]}" 2)"
			format="$(sh_splitarray "${Amntpoint[$i]}" 3)"

			if [ "$fstype" = "f2fs" -o "$fstype" = "btrfs" -o "$fstype" = "xfs" -o "$fstype" = "reiserfs" ]; then
				fsorder=0
			fi

			if [ "$fstype" = "swap" ]; then
				echo "UUID=$(blkid -o value -s UUID "${_part}")  none          swap         none,nofail      0 0" >>"$dir_install/etc/fstab"
				continue
			fi

			if [ -n "$mntpoint" ]; then
				if [ "$mntpoint" = '/boot/efi' ]; then
					echo "UUID=$(blkid -o value -s UUID "${_part}")  ${mntpoint}   ${fstype,,}   defaults 0 2" >>"$dir_install/etc/fstab"
				else
					if [ "$format" = 0 ]; then
						if [ "$mntpoint" = 'none' ]; then
							((++Npoint))
							mntpoint="/mnt/none${Npoint}"
							mkdir -p "$dir_install/${mntpoint}"
						fi
						echo "UUID=$(blkid -o value -s UUID "${_part}")  ${mntpoint}   ${fstype,,}   defaults,nofail,noatime,discard,lazytime 0 $fsorder" >>"$dir_install/etc/fstab"
					else
						echo "UUID=$(blkid -o value -s UUID "${_part}")  ${mntpoint}   ${fstype,,}   defaults,noatime,discard,lazytime 0 $fsorder" >>"$dir_install/etc/fstab"
					fi
				fi
			fi
		done
		evaluate_retval "$?"
	else
		sh_info_msg "${cmsg_Gerando} fstab pass1 ${cmsg_Em} $dir_install"

		for i in "${!Amntpoint[@]}"; do
			_part="$i"
			mntpoint="$(sh_splitarray "${Amntpoint[$i]}" 1)"
			fstype="$(sh_splitarray "${Amntpoint[$i]}" 2)"
			format="$(sh_splitarray "${Amntpoint[$i]}" 3)"

			if [[ "$mntpoint" = "/boot/efi" ]]; then
				echo "UUID=$(blkid -o value -s UUID "${_part}")  ${mntpoint}   ${fstype,,}   defaults 0 $fsorder" >>"$dir_install/etc/fstab"
				break
			fi
		done

		for i in "${!AmntpointFDE[@]}"; do
			_part="$i"
			label="$(sh_splitarray "${AmntpointFDE[$i]}" 1)"
			fstype="$(sh_splitarray "${AmntpointFDE[$i]}" 2)"
			format="$(sh_splitarray "${AmntpointFDE[$i]}" 3)"
			size="$(sh_splitarray "${AmntpointFDE[$i]}" 4)"
			mntpoint="$(sh_splitarray "${AmntpointFDE[$i]}" 5)"
			#			echo "UUID=$(blkid -o value -s UUID "${_part}")	$mntpoint	${fstype,,}	defaults 0 0" >>"$dir_install/etc/fstab"
			echo "UUID=$(blkid -o value -s UUID "${_part}")	$mntpoint	${fstype,,}	defaults,noatime,discard,lazytime 0 0" >>"$dir_install/etc/fstab"
		done
		evaluate_retval "$?"
	fi

	sh_chroot_job "${cmsg_Gerando} fstab pass2 ${cmsg_Em} $dir_install" \
		"sed 's/#.*//' /etc/fstab | column --table --table-columns SOURCES,DIR,TYPE,OPTIONS,DUMP,PASS --table-hide - >/tmp/fstab" "$err_not_fatal"
	sh_chroot_job "${cmsg_Gerando} fstab pass3 ${cmsg_Em} $dir_install" \
		"sed -i 's/SOURCES/#SOURCE/' /tmp/fstab" "$err_not_fatal"
	sh_chroot_job "${cmsg_Gerando} fstab pass4 ${cmsg_Em} $dir_install" \
		"cp /tmp/fstab /etc/fstab" "$err_not_fatal"
}

sh_activating_services() {
	local aServicesTTY=(dbus dhcpcd sshd nanoklogd chronyd socklog-unix udevd)
      	aServicesTTY+=(wpa_supplicant uuidd dmeventd)
	local aServicesX=(elogind polkitd NetworkManager bluetoothd)
	local service
	local level=2

	for x in "${aDE[@]}"; do
		case $x in
		tty) continue ;;
		gnome)
			aServicesX+=(gdm)
			break
			;;
		*)
			aServicesX+=(lxdm)
			break
			;;
		esac
	done

	for service in "${aServicesTTY[@]}"; do
		sh_chroot_job "${cmsg_AtivandoServico} $service ${cmsg_Em} $dir_install" \
			"ln -sf /etc/sv/$service /etc/runit/runsvdir/current/" \
			"$err_not_fatal" \
			"$level"
	done

	if ! $LONLY_TTY; then
		for service in "${aServicesX[@]}"; do
			sh_chroot_job "${cmsg_AtivandoServico} $service ${cmsg_Em} $dir_install" \
				"ln -sf /etc/sv/$service /etc/runit/runsvdir/current/" \
				"$err_not_fatal" \
				"$level"
		done
	fi
}

sh_activating_pipewire() {
	sh_chroot_job "${cmsg_Ajustando} pipewire" "
     mkdir -p /etc/alsa/conf.d
     ln -sf /usr/share/alsa/alsa.conf.d/{50-pipewire.conf,99-pipewire-default.conf} /etc/alsa/conf.d/
     mkdir -p /etc/pipewire/pipewire.conf.d
     ln -sf /usr/share/examples/{wireplumber/10-wireplumber.conf,pipewire/20-pipewire-pulse.conf} /etc/pipewire/pipewire.conf.d/
     mkdir -p /etc/xdg/autostart
     ln -sf /usr/share/applications/{pipewire.desktop,pipewire-pulse.desktop,wireplumber.desktop} /etc/xdg/autostart/
   " $err_not_fatal
}

sh_mk_working_dir() {
	local cdir
	local adir=("$dir_install/boot"
		"$dir_install/boot/efi"
		"$dir_install/dev"
		"$dir_install/proc"
		"$dir_install/sys"
		"$dir_install/var/db/xbps/keys"
		"$dir_install/etc/xbps.d"
	)

	sh_cmd_job "${cmsg_CriandoDiretorios}" "
      for cdir in "${adir[@]}"; do
		   [[ -d "$cdir" ]] || mkdir -p "$cdir"
     	done
   "
}

sh_mount_fs() {
	local i
	local _part
	local mntpoint
	local fstype

	if ! $LVM; then
		for i in "${!Amntpoint[@]}"; do
			_part="$i"
			mntpoint="$(sh_splitarray "${Amntpoint[$i]}" 1)"
			if [[ -n "$mntpoint" && "$mntpoint" = "/" ]]; then
				sh_info_msg "${cmsg_MontandoParticao} ${_part} ${red}(${mntpoint})${rst} ${cmsg_Em} $dir_install${mntpoint}"
				mkdir -p "$dir_install"
				mount "$_part" "$dir_install"
				evaluate_retval "$?"
				break
			fi
		done
	else
		for i in "${!AmntpointFDE[@]}"; do
			_part="$i"
			label="$(sh_splitarray "${AmntpointFDE[$i]}" 1)"
			fstype="$(sh_splitarray "${AmntpointFDE[$i]}" 2)"
			format="$(sh_splitarray "${AmntpointFDE[$i]}" 3)"
			size="$(sh_splitarray "${AmntpointFDE[$i]}" 4)"
			mntpoint="$(sh_splitarray "${AmntpointFDE[$i]}" 5)"
			lvunit="${size: -1}"

			if [[ -n "$mntpoint" && "$mntpoint" = "/" ]]; then
				mkdir -p "$dir_install${mntpoint}"
				sh_info_msg "${cmsg_MontandoParticao} ${_part} ($dir_install)"
				mount "${_part}" "$dir_install${mntpoint}"
				evaluate_retval "$?"
				break
			fi
		done

		for i in "${!AmntpointFDE[@]}"; do
			_part="$i"
			label="$(sh_splitarray "${AmntpointFDE[$i]}" 1)"
			fstype="$(sh_splitarray "${AmntpointFDE[$i]}" 2)"
			format="$(sh_splitarray "${AmntpointFDE[$i]}" 3)"
			size="$(sh_splitarray "${AmntpointFDE[$i]}" 4)"
			mntpoint="$(sh_splitarray "${AmntpointFDE[$i]}" 5)"
			lvunit="${size: -1}"

			[[ -n "$mntpoint" && "$mntpoint" = "/" || "$fstype" = "swap" ]] && continue

			mkdir -p "$dir_install${mntpoint}"
			sh_info_msg "${cmsg_MontandoParticao} ${_part} ($dir_install) ${cmsg_Em} $dir_install${mntpoint}"
			mount "${_part}" "$dir_install${mntpoint}"
			evaluate_retval "$?"
		done
	fi

	for i in "${!Amntpoint[@]}"; do
		_part="$i"
		mntpoint="$(sh_splitarray "${Amntpoint[$i]}" 1)"
		fstype="$(sh_splitarray "${Amntpoint[$i]}" 2)"
		if [[ -n "$mntpoint" && "$mntpoint" = "/" ]]; then
			continue
		fi

		if [[ "$fstype" = "swap" ]]; then
			continue
		fi

		if [[ -n "$mntpoint" ]]; then
			sh_info_msg "${cmsg_MontandoParticao} ${_part} ${red}(${mntpoint})${rst} ${cmsg_Em} $dir_install${mntpoint}"
			mkdir -p "$dir_install${mntpoint}"
			mount "$_part" "$dir_install${mntpoint}"
			evaluate_retval "$?"
		fi
	done
}

sh_X11minimal() {
	local apkgs=()
	local aMedia=()

	if ! $HYPRLAND; then
		apkgs+=("${aXorg[@]}")
	fi

	apkgs+=("${aVideo[@]}")
	apkgs+=("${aFont[@]}")
	apkgs+=("${aDisplaymanager[@]}")
	apkgs+=("${aTerminal[@]}")
	apkgs+=("${aFilemanager[@]}")
	apkgs+=("${aBrowser[@]}")
	apkgs+=("${aBluetooth[@]}")
	apkgs+=("${aNetworkX[@]}")
	apkgs+=("${aUtilityX[@]}")
	apkgs+=("${aIconsAndThemes[@]}")

	if [[ "${AConfAudio[_AUDIOSERVER]}" == 'Pulseaudio' ]]; then
		apkgs+=("${aPulseaudio[@]}")
		aMedia+=("${aPulseaudio[@]}")
	else
		apkgs+=("${aPipewire[@]}")
		aMedia+=("${aPipewire[@]}")
	fi

	apkgs+=("${aPrinter[@]}")
	apkgs+=("${aPerfumery[@]}")
	apkgs+=("${aMicrocode[@]}")
	apkgs+=("${aArchiverX[@]}")
	apkgs+=("${aEditorX[@]}")

	if ! $HYPRLAND; then
		sh_install_pkgs_in_chroot "$(gettext 'Instalando Meta Pacote Xorg')" "${aXorg[*]}"
	fi

	sh_install_pkgs_in_chroot "$(gettext 'Instalando Meta Pacote Video')" "${aVideo[*]}"
	sh_install_pkgs_in_chroot "$(gettext 'Instalando Meta Pacote Fontes')" "${aFont[*]}"
	sh_install_pkgs_in_chroot "$(gettext 'Instalando Meta Pacote Icones')" "${aIconsAndThemes[*]}"
	sh_install_pkgs_in_chroot "$(gettext 'Instalando Meta Pacote DM')" "${aDisplaymanager[*]}"
	sh_install_pkgs_in_chroot "$(gettext 'Instalando Meta Pacote Terminal')" "${aTerminal[*]}"
	sh_install_pkgs_in_chroot "$(gettext 'Instalando Meta Pacote FileManager')" "${aFilemanager[*]}"
	sh_install_pkgs_in_chroot "$(gettext 'Instalando Meta Pacote Navegadore')" "${aBrowser[*]}"
	sh_install_pkgs_in_chroot "$(gettext 'Instalando Meta Pacote Bluetooth')" "${aBluetooth[*]}"
	sh_install_pkgs_in_chroot "$(gettext 'Instalando Meta Pacote Rede')" "${aNetworkX[*]}"
	sh_install_pkgs_in_chroot "$(gettext 'Instalando Meta Pacote Utilitário')" "${aUtilityX[*]}"
	sh_install_pkgs_in_chroot "$(gettext 'Instalando Meta Pacote Media')" "${aMedia[*]}"
	sh_install_pkgs_in_chroot "$(gettext 'Instalando Meta Pacote Impressora')" "${aPrinter[*]}"
	sh_install_pkgs_in_chroot "$(gettext 'Instalando Meta Pacote Perfumaria')" "${aPerfumery[*]}"
	#	sh_install_pkgs_in_chroot "$(gettext 'Instalando Meta Pacote Microde')" "${aMicrocode[*]}"
	sh_install_pkgs_in_chroot "$(gettext 'Instalando Meta Pacote Archivadores')" "${aArchiverX[*]}"
}

#dom 03 mar 2024 09:35:25 -04
sh_blackboxminimal() {
	local DE='Blackbox'
	local apkgs=(blackboxwm bbkeys)
	sh_install_pkgs_in_chroot "Instalando ${DE}" "${apkgs[*]}"
}

sh_fluxboxminimal() {
	local DE='FluxBox'
	local apkgs=(fluxbox fbmenugen cairo galculator-gtk2 gtk2-engines gtk-engine-murrine)
	apkgs+=(wicd qt5ct qt5-styleplugins leafpad dconf volumeicon feh viewnior compton arc-theme ffmpegthumbnailer)

	sh_install_pkgs_in_chroot "Instalando ${DE}" "${apkgs[*]}"
	if [[ -f "$dir_install/home/${AsUser[cuser]}/.fluxbox/startup" ]]; then
		sed -e "/xmodmap/s//# xmodmap/" -i "$dir_install/home/${AsUser[cuser]}/.fluxbox/startup" 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
		if [[ "${AConfLocale[_KEYMAP]}" = 'br-abnt2' ]]; then
			sed -e '/\# xmodmap/a setxkbmap br -variant abnt2' -i "$dir_install/home/${AsUser[cuser]}/.fluxbox/startup" 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
		fi
	fi
}

sh_openboxminimal() {
	local apkgs=(openbox obconf)
	local DE='OpenBox'
	sh_install_pkgs_in_chroot "Instalando ${DE}" "${apkgs[*]}"
}

sh_plasmaminimal() {
	local apkgs=('plasma-desktop' 'plasma-nm' 'plasma-pa' 'plasma-disks')
	local DE='Plasma Desktop'
	sh_install_pkgs_in_chroot "Instalando ${DE}" "${apkgs[*]}"
}

sh_xfce4minimal() {
	local DE='Xfce4'
	local apkgs=(xfce4 Thunar thunar-volman elogind exo mousepad parole ristretto tumbler upower xdg-user-dirs-gtk xfce-polkit)
	apkgs+=(xfce4-notifyd xfce4-panel xfce4-power-manager xfce4-screensaver xfce4-session xfce4-settings xfce4-taskmanager)
	apkgs+=(xfce4-terminal xfconf xfdesktop xfwm4-themes xfwm4 xfce4-pulseaudio-plugin)

	if $LCUSTOM; then
		apkgs+=(xfce4-battery-plugin
			xfce4-clipman-plugin
			xfce4-cpufreq-plugin
			xfce4-cpugraph-plugin
			xfce4-datetime-plugin
			xfce4-screenshooter
			xfce4-dict
			xfce4-diskperf-plugin
			xfce4-fsguard-plugin
			xfce4-genmon-plugin
			xfce4-mailwatch-plugin
			xfce4-mpc-plugin
			xfce4-netload-plugin
			xfce4-pulseaudio-plugin
			xfce4-sensors-plugin
			xfce4-systemload-plugin
			xfce4-time-out-plugin
			xfce4-timer-plugin
			xfce4-verve-plugin
			xfce4-whiskermenu-plugin
			xfce4-weather-plugin
			xfce4-wavelan-plugin
			xfce4-xkb-plugin
			plank
		)
		if sh_checkRepo 'https://void.chililinux.com/voidlinux/current'; then
			apkgs+=(chili-xfce-config)
			#apkgs+=(chili-void-xfce-skel)
		fi
	fi

	sh_install_pkgs_in_chroot "Instalando ${DE}" "${apkgs[*]}"
}

sh_xorgminimal() {
	local DE='Xorg Minimal'
	declare apkgs=(xorg-minimal xinit xterm xorg-fonts xorg-video-drivers mesa-dri)

	sh_install_pkgs_in_chroot "Instalando ${DE}" "${apkgs[*]}"
}

sh_gnomeminimal() {
	local DE='Gnome'
	local apkgs=(gnome gnome-apps gdm gnome-connections extension-manager
		mime-types gnome-terminal gnome-backgrounds gnome-disk-utility)

	if $LCUSTOM; then
		apkgs+=(dconf-editor devhelp Endeavour evolution five-or-more four-in-a-row geary
			gedit ghex glade3 gnome-boxes gnome-builder gnome-chess gnome-games-collection
			gnome-klotski gnome-mahjongg gnome-multi-writer gdm-settings
			gnome-nettool gnome-nibbles gnome-robots gnome-sound-recorder gnome-sudoku
			gnome-taquin gnome-tetravex gnome-tweaks gnome-usage hitori iagno lightsoff
			polari quadrapassel swell-foop sysprof tali
		)
	fi

	sh_install_pkgs_in_chroot "Instalando ${DE}" "${apkgs[*]}"
}

sh_i3minimal() {
	local DE='I3'
	local apkgs=(i3 dmenu i3status i3lock geany volumeicon mc scrot ImageMagick gnome-themes-standard axel mps-youtube youtube-dl mpv cava mate-themes)

	sh_install_pkgs_in_chroot "Instalando ${DE}" "${apkgs[*]}"
}

sh_swayminimal() {
	local DE='Sway'
	local apkgs=(sway)

	sh_install_pkgs_in_chroot "Instalando ${DE}" "${apkgs[*]}"
}

sh_mateminimal() {
	local DE='Mate'
	local apkgs=('mate' 'mate-extra' 'mate-applets' 'atril' 'caja-image-converter' 'caja-open-terminal' 'caja-sendto'
		'caja-share' 'caja-wallpaper' 'caja-xattr-tags' 'engrampa' 'eom' 'mate-calc' 'mate-icon-theme-faenza'
		'mate-media' 'mate-netbook' 'mate-power-manager' 'mate-screensaver' 'mate-sensors-applet' 'mate-system-monitor'
		'mate-terminal' 'mate-utils' 'mozo' 'pluma' 'mate-backgrounds')

	sh_install_pkgs_in_chroot "Instalando ${DE}" "${apkgs[*]}"
}

sh_twmminimal() {
	local DE='TWM'
	local apkgs=('twm')

	sh_install_pkgs_in_chroot "Instalando ${DE}" "${apkgs[*]}"
}

sh_awesomeminimal() {
	local DE='Awesome'
	local apkgs=(awesome polybar pcmanfm font-awesome)

	sh_install_pkgs_in_chroot "Instalando ${DE}" "${apkgs[*]}"
}

sh_bspwmminimal() {
	local DE='Bspwm'
	local apkgs=(bspwm polybar sxhkd dunst flameshot picom feh dmenu lua wmctrl compton mpd)
	apkgs+=(font-weather-icons font-awesome5 noto-fonts-cjk hsetroot lxappearance)
	apkgs+=(rofi gtk-engine-murrine gtk2-engines)
	apkgs+=(chili-void-bspwm-skel)

	sh_install_pkgs_in_chroot "Instalando ${DE}" "${apkgs[*]}"
}

sh_enlightenmentminimal() {
	local DE='Enlightenment'
	local apkgs=(enlightenment efl exquisite acpi acpid connman)

	sh_install_pkgs_in_chroot "Instalando ${DE}" "${apkgs[*]}"
}

sh_dwmminimal() {
	local DE='Dwm'
	local apkgs=(dwm)

	sh_install_pkgs_in_chroot "Instalando ${DE}" "${apkgs[*]}"
}

sh_hyprlandminimal() {
	local DE='Hyprland'
	local user="${AsUser[cuser]}"
	local apkgs=(hyprland hyprland-protocols xdg-desktop-portal-hyprland dbus polkit seatd elogind mesa-dri)
	apkgs+=(hyprlang)
	apkgs+=(Waybar dunst kitty libnotify xdg-desktop-portal-gtk)
	#Wallpaper tool for Wayland compositors
	apkgs+=(swaybg)    #Wallpaper tool for Wayland compositors
	apkgs+=(hyprpaper) #Fast wallpaper utility for wlroots compositors with IPC controls
	apkgs+=(mpvpaper)  #Video wallpaper program for wlroots based wayland compositors
	#hyprland's default terminal
	apkgs+=(kitty alacritty)
	#other great options
	#		  apkgs+=(alacritty wezterm)
	#most popular option
	apkgs+=(rofi)
	#gtk rofi
	apkgs+=(wofi)
	#hyprland wiki
	apkgs+=(bemenu fuzzel tofi)
	apkgs+=(neovim)

	shell='/bin/bash'
	sh_install_pkgs_in_chroot "Instalando ${DE}" "${apkgs[*]}"
}

sh_lxdeminimal() {
	local DE='Lxde'
	local apkgs=(lxde lxterminal lxrandr lxtask lxinput lxappearance)

	sh_install_pkgs_in_chroot "Instalando ${DE}" "${apkgs[*]}"
}

sh_lxqtminimal() {
	local DE='Lxqt'
	local apkgs=(lxqt)

	sh_install_pkgs_in_chroot "Instalando ${DE}" "${apkgs[*]}"
}

sh_make_bspwm_conf() {
	local user="${AsUser[cuser]}"
	shell='/bin/bash'

	sh_chroot_job "${cmsg_Configurando} Bspwm ${cmsg_Em} $dir_install" "
      mkdir -p /home/$user/.config/{bspwm,polybar,sxhkd} &&
		cp -R /usr/share/doc/bspwm/examples/* /home/$user/.config/bspwm/ &&
		cp /usr/share/examples/polybar/config.ini /home/$user/.config/polybar/ &&
		cp /usr/share/doc/bspwm/examples/sxhkdrc /home/$user/.config/sxhkd/ &&
		echo '#!/usr/bin/env bash'  >> /home/$user/.config/polybar/launch.sh &&
		echo 'polybar-msg cmd quit' >> /home/$user/.config/polybar/launch.sh &&
		echo 'echo "---" | tee -a /tmp/polybar1.log /tmp/polybar2.log' >> /home/$user/.config/polybar/launch.sh &&
		echo 'polybar example 2>&1 | tee -a /tmp/polybar1.log & disown' >> /home/$user/.config/polybar/launch.sh &&
   	echo '~/.config/polybar/launch.sh' >> /home/$user/.config/bspwm/bspwmrc &&
	   chmod +x $user:$user /home/$user/.config/polybar/launch.sh &&
   	chown $user:$user /home/$user/.config -R
   " "$err_not_fatal"
}

sh_backup_partitions() {
	if [ $# -ge 2 ]; then
		local disk="${1}"
		local device="${2}"
		local tmpdir="/tmp/$_APP_"
		local cdatetime
		local filetmp

		cdatetime=$(sh_diahora)
		filetmp="$tmpdir/${device}.$cdatetime.dump"
		mkdir -p "$tmpdir" 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
		sfdisk -d "$disk" >"$filetmp" 2>/dev/null
		#  info "BACKUP DA TABELA DE PARTICOES"    \
		#         "Dispositivo : $disk"              \
		#         "  Backup on : ${filetmp}"         \
		#        "$(replicate "=" 80)"               \
		#         "$(cat $filetmp)"
	fi
}

sh_diahora() {
	DIAHORA=$(date +"%d%m%Y-%T" | sed 's/://g')
	printf "%s\n" "$DIAHORA"
}

sh_rtrim() {
	local str="$1"
	echo "${str%%' '}"
}

sh_vg_info() {
	unset ARRAY_VG_{NAME,SIZE,FREE,ATTR}
	local {NAME,SIZE,FREE,ATTR}_

	mensagem "=== VG ===" "\n\n${BOLD}${WHITE}$(gettext "Aguarde... coletando informações")"
	AARRAY_VG_DEVICES=()
	while read -r line; do
		eval "${line//=/_=}"
		ARRAY_VG_NAME+=("$NAME_")
		ARRAY_VG_SIZE+=("$SIZE_")
		ARRAY_VG_FREE+=("$FREE_")
		ARRAY_VG_ATTR+=("$ATTR_")
		AARRAY_VG_DEVICES+=(["$NAME_"]="$NAME_|$SIZE_|$FREE_|$ATTR_")
	done < <(vgs --noheadings --units G -o vg_name,vg_size,vg_free,vg_attr | awk '/^ *[[:alnum:]]+ / {print "NAME=\"" $1 "\"", "SIZE=\"" $2 "\"", "FREE=\"" $3 "\"", "ATTR=\"" $4 "\""}' | sort -k1,1 -k2,2)
}

sh_disk_info() {
	unset ARRAY_DSK_{DISKS,DEVICES,SIZE,TRAN,MODEL,LABEL,SERIAL,PTTYPE,FSTYPE}
	local {NAME,PATH,SIZE,TRAN,MODEL,LABEL,SERIAL,PTTYPE,FSTYPE}_

	mensagem "$(gettext "=== DISCO ===")" "\n\n${BOLD}${WHITE}$(gettext 'Aguarde... coletando informações')"
	AARRAY_DSK_DEVICES=()
	while read -r line; do
		eval "${line//=/_=}"
		ARRAY_DSK_DISKS+=("$NAME_")
		ARRAY_DSK_DEVICES+=("$PATH_")
		ARRAY_DSK_SIZE+=("$SIZE_")
		ARRAY_DSK_TRAN+=("${TRAN_:-${TYPE_}}")
		ARRAY_DSK_MODEL+=("${MODEL_:-${TYPE_} device}")
		ARRAY_DSK_LABEL+=("${LABEL_:-""}")
		ARRAY_DSK_SERIAL+=("${SERIAL_:-""}")
		ARRAY_DSK_PTTYPE+=("${PTTYPE_:-""}")
		ARRAY_DSK_FSTYPE+=("${FSTYPE_:-none}")
		AARRAY_DSK_DEVICES+=(["$PATH_"]="$NAME_|$SIZE_|${TRAN_:-${TYPE_}}|${MODEL_:-unknown}|${LABEL_:-""}|${SERIAL_:-""}|${PTTYPE_:-""}|${FSTYPE_:-"none"}")
	done < <(lsblk -PAo TYPE,NAME,PATH,SIZE,TRAN,MODEL,LABEL,SERIAL,PTTYPE | grep -P 'TYPE="(disk|loop|lvm)"' | sort -k5,5 -k2,2)
}

sh_disk_part_info() {
	unset ARRAY_DSK_{DISKS,DEVICES,SIZE,TRAN,MODEL,LABEL,SERIAL,PTTYPE,FSTYPE}
	unset ARRAY_PART_{DISKS,DEVICES,SIZE,TRAN,MODEL,LABEL,SERIAL,FSTYPE,PARTTYPENAME}
	local {NAME,PATH,SIZE,TRAN,MODEL,LABEL,SERIAL,PTTYPE,FSTYPE,PARTTYPENAME}_

	mensagem "$(gettext "=== DISCO/PARTIÇÃO ===")" "\n\n${BOLD}${WHITE}$(gettext "Aguarde... coletando informações")"
	AARRAY_DSK_DEVICES=()
	AARRAY_PART_DEVICES=()
	while read -r line; do
		eval "${line//=/_=}"
		if [[ "${TYPE_}" != "part" ]]; then
			ARRAY_DSK_DISKS+=("$NAME_")
			ARRAY_DSK_DEVICES+=("$PATH_")
			ARRAY_DSK_SIZE+=("$SIZE_")
			ARRAY_DSK_TRAN+=("${TRAN_:-${TYPE_}}")
			ARRAY_DSK_MODEL+=("${MODEL_:-${TYPE_} device}")
			ARRAY_DSK_LABEL+=("${LABEL_:-""}")
			ARRAY_DSK_SERIAL+=("${SERIAL_:-""}")
			ARRAY_DSK_PTTYPE+=("${PTTYPE_:-""}")
			ARRAY_DSK_FSTYPE+=("${FSTYPE_:-none}")
			ARRAY_DSK_PARTTYPENAME+=("${PARTTYPENAME_:-none}")
			AARRAY_DSK_DEVICES+=(["$PATH_"]="$NAME_|$SIZE_|${TRAN_:-${TYPE_}}|${MODEL_:-unknown}|${LABEL_:-""}|${SERIAL_:-""}|${PTTYPE_:-""}|${FSTYPE_:-"none"}|${PARTTYPENAME_:-none}")
		fi
		if [[ "${TYPE_}" = "part" ]]; then
			[[ "$FSTYPE_" = "iso9660" ]] && continue
			#		[[ "$FSTYPE_" = "crypto_LUKS" ]] && continue
			#		[[ "$FSTYPE_"  = "LVM2_member" ]] && continue
			ARRAY_PART_DISKS+=("$NAME_")
			ARRAY_PART_DEVICES+=("$PATH_")
			ARRAY_PART_SIZE+=("$SIZE_")
			ARRAY_PART_TRAN+=("${TRAN_:-${TYPE_}}")
			ARRAY_PART_MODEL+=("${MODEL_:-unknown}")
			ARRAY_PART_LABEL+=("${LABEL_:-""}")
			ARRAY_PART_SERIAL+=("${SERIAL_:-""}")
			ARRAY_PART_FSTYPE+=("${FSTYPE_:-none}")
			ARRAY_PART_PARTTYPENAME+=("${PARTTYPENAME_:-none}")
			AARRAY_PART_DEVICES+=(["$PATH_"]="$NAME_|$SIZE_|${TRAN_:-${TYPE_}}|${MODEL_:-unknown}|${LABEL_:-""}|${SERIAL_:-""}|${FSTYPE_:-"none"}|${PARTTYPENAME_:-none}")
		fi
	done < <(lsblk -PAo TYPE,NAME,PATH,SIZE,TRAN,MODEL,LABEL,SERIAL,PTTYPE,FSTYPE,PARTTYPENAME | grep -P 'TYPE="(disk|loop|lvm|part)"' | sort -k5,5 -k2,2)
}

sh_part_info() {
	unset ARRAY_PART_{DISKS,DEVICES,SIZE,TRAN,MODEL,LABEL,SERIAL,FSTYPE,PARTTYPENAME}
	local {NAME,PATH,SIZE,TRAN,MODEL,LABEL,SERIAL,FSTYPE,PARTTYPENAME}_

	mensagem "$(gettext "=== PARTIÇÃO ===")" "\n\n${BOLD}${WHITE}$(gettext "Aguarde... coletando informações")"
	AARRAY_PART_DEVICES=()
	while read -r line; do
		eval "${line//=/_=}"
		[[ "$FSTYPE_" = "iso9660" ]] && continue
		#		[[ "$FSTYPE_" = "crypto_LUKS" ]] && continue
		[[ "$FSTYPE_" = "LVM2_member" ]] && continue
		ARRAY_PART_DISKS+=("$NAME_")
		ARRAY_PART_DEVICES+=("$PATH_")
		ARRAY_PART_SIZE+=("$SIZE_")
		ARRAY_PART_TRAN+=("${TRAN_:-${TYPE_}}")
		ARRAY_PART_MODEL+=("${MODEL_:-unknown}")
		ARRAY_PART_LABEL+=("${LABEL_:-""}")
		ARRAY_PART_SERIAL+=("${SERIAL_:-""}")
		ARRAY_PART_FSTYPE+=("${FSTYPE_:-none}")
		ARRAY_PART_PARTTYPENAME+=("${PARTTYPENAME_:-none}")
		AARRAY_PART_DEVICES+=(["$PATH_"]="$NAME_|$SIZE_|${TRAN_:-${TYPE_}}|${MODEL_:-unknown}|${LABEL_:-""}|${SERIAL_:-""}|${FSTYPE_:-"none"}|${PARTTYPENAME_:-none}")
	done < <(lsblk -fPAo TYPE,NAME,PATH,SIZE,TRAN,MODEL,LABEL,SERIAL,FSTYPE,PARTTYPENAME | grep -P 'TYPE="(part)"' | sort -k5,5 -k2,2)
}

sh_getIso() {
	if test -e '/run/initramfs/live/LiveOS/squashfs.img'; then
		return 0
	fi
	return 1
}

sh_chooseSource() {
	local -A Asource
	local -A Aflag
	local cextra
	local exit_status
	local array=()
	local x
	local _src

	Asource["local"]="${cmsg_PacotesDaImagemIso}"
	Asource["network"]="${cmsg_BaixadoDoRepositorioOficial}"
	Asource["networkFull"]="${cmsg_BaixadoDoRepositorioOficialFull}"
	cextra="${cmsg_ExtraNotIso}"

	_src=${AConfMirror[_SOURCE]}
	for x in "${!Asource[@]}"; do
		if [[ $_src = $x ]]; then
			Aflag[$x]='on'
		else
			Aflag[$x]='off'
		fi
		if sh_getIso; then
			cextra="${cmsg_ExtraIso}"
		else
			if ! sh_checkcommand "${XBPS_INSTALL_CMD}"; then
				cextra="${cmsg_ExtraNotIso}\n${cmsg_ExtraNotHostVoid}"
			else
				cextra="${cmsg_ExtraNotIso}"
			fi
		fi
		array+=("$x" "${Asource[$x]}" "${Aflag[$x]}")
	done

	while true; do
		src=$(${DIALOG} --title "=== ${cmsg_Source^^} ===" \
			--default-item "${AConfMirror[_SOURCE]}" \
			--stdout \
			--colors \
			--cancel-label "${cmsg_ButtonBack}" \
			--ok-label "${cmsg_Aceitar}" \
			--radiolist "${cmsg_MENU}\n\n$cextra" \
			12 0 0 "${array[@]}")

		exit_status=$?
		case $exit_status in
		"$D_ESC" | "$D_CANCEL")
			return 1
			;;
		"$D_OK")
			#dom 03 mar 2024 17:00:23 -04
			if [[ "$src" = "networkFull" ]]; then
				if ! sh_checkcommand "${XBPS_INSTALL_CMD}"; then
					alerta "=== ${cmsg_Source^^} ===" \
						"\n${BOLD}$(gettext "Aparentemente, o VOID Linux NÃO está sendo usado como host.\nEscolha network ou ISO")"
					continue
				fi
			fi
			if [[ "$src" = "local" ]]; then
				if ! sh_getIso; then
					info "$ccabec" "\n\n$cextra"
					continue
				else
					LSOURCE=true
					AConfMirror[_SOURCE]=$src
				fi
			fi
			;;
		esac
		LSOURCE=true
		AConfMirror[_SOURCE]=$src
		return 0
	done
}

sh_choosefstype() {
	local oldfstype="$1"
	declare -A Afs
	declare -A Aflag
	local cextra
	local exit_status
	local array=()
	local x

	Afs[xfs]="SGI's XFS"
	Afs[reiserfs]="Linux Reiserfs"
	Afs[jfs]="Linux Jfs"
	Afs[f2fs]="Flash-Friendly Filesystem"
	Afs[ext3]="Linux ext3 (journal)"
	Afs[ext2]="Linux ext2 (no journaling)"
	Afs[btrfs]="Oracle Btrfs"
	Afs[ext4]="Linux ext4 (journal)"
	Afs[vfat]="FAT32 (EFI)"
	Afs[swap]="Linux swap"

	if [[ -z "$oldfstype" ]]; then
		oldfstype=${AConfDisk[_FILESYSTEM]}
	fi

	for x in "${!Afs[@]}"; do
		[[ "$oldfstype" = "$x" ]] && Aflag[$x]='on' || Aflag[$x]='off'
		array+=("$x" "${Afs[$x]}" "${Aflag[$x]}")
	done

	cextra="${cmsg_mkfs}"
	mkfs=$(${DIALOG} \
		--title "${cmsg_TitleFileSystem}" \
		--default-item "$oldfstype" \
		--colors \
		--cancel-label "${cmsg_ButtonBack}" \
		--ok-label "${cmsg_Aceitar}" \
		--radiolist "${cmsg_MENU}\n\n$cextra" \
		24 0 2 "${array[@]}" 2>&1 >/dev/tty)

	exit_status=$?
	case $exit_status in
	"$D_ESC" | "$D_CANCEL")
		return 1
		;;
	esac
	LFS=true
	AConfDisk[_FILESYSTEM]="$mkfs"
	return 0
}

sh_chooseaudioserver() {
	local exit_status
	local array=()
	local x
	local caudio

	case "${AConfAudio[_AUDIOSERVER]:-Pulseaudio}" in
	Pulseaudio)
		array+=("Pulseaudio" "Pulseaudio" "on")
		array+=("Pipewire" "Pipewire" "off")
		;;
	Pipewire)
		array+=("Pulseaudio" "Pulseaudio" "off")
		array+=("Pipewire" "Pipewire" "on")
		;;
	esac

	caudio=$(${DIALOG} \
		--title "${cmsg_DefinirAudioServer}" \
		--default-item "${AConfAudio[_AUDIOSERVER]}" \
		--colors \
		--cancel-label "${cmsg_ButtonBack}" \
		--ok-label "${cmsg_Aceitar}" \
		--radiolist "${cmsg_MENU}\n\n$cextra" \
		12 70 0 "${array[@]}" 2>&1 >/dev/tty)

	exit_status=$?
	case $exit_status in
	"$D_ESC" | "$D_CANCEL")
		return 1
		;;
	esac
	LAUDIO=true
	AConfAudio[_AUDIOSERVER]="$caudio"
	return 0
}

sh_timedatectl() {
	local _localtime

	if [[ -n $(command -v timedatectl) ]]; then
		_localtime=$(awk '{print $3}' <(grep 'Time zone' <(timedatectl)))
		if [[ -n "$_localtime" ]]; then
			echo "$_localtime"
			return 0
		fi
	else
		_localtime=$(cut -d'"' -f2 <(grep TIMEZONE /etc/rc.conf))
		if [[ -n "$_localtime" ]]; then
			echo "$_localtime"
			return 0
		fi
	fi
	return 1
}

sh_chooseLocale() {
	local TMPFILE
	local LOC
	local LANG
	local COUNTRY

	TMPFILE=$(mktemp -t void-install-XXXXXXXX || exit 1)
	DEFITEM="${AConfLocale[_LOCALE]}"

	# tabelas básicas (expansível depois)
	declare -A ISO639=(
		[pt]="Portuguese"
		[en]="English"
		[es]="Spanish"
		[fr]="French"
		[de]="German"
		[it]="Italian"
		[ja]="Japanese"
		[zh]="Chinese"
		[ru]="Russian"
	)

	declare -A ISO3166=(
		[BR]="Brazil"
		[PT]="Portugal"
		[US]="United States"
		[AR]="Argentina"
		[FR]="France"
		[DE]="Germany"
		[IT]="Italy"
		[JP]="Japan"
		[CN]="China"
		[RU]="Russia"
	)

	# captura locales UTF-8 portável (vale Void, Debian, Arch, Alpine, etc)
	# remove C, POSIX, C.utf8 e variantes
	locale -a |
		grep -i utf |
		grep -vE '^(C|POSIX)(\.|$)' |
		sort >"$TMPFILE"

	local MENU_ITEMS=()

	while read -r LOC; do
		LANG="${LOC%%_*}"
		COUNTRY="${LOC#*_}"
		COUNTRY="${COUNTRY%%.*}"

		# fallback se não tiver mapeado
		LANGNAME="${ISO639[$LANG]:-$LANG}"
		COUNTRYNAME="${ISO3166[$COUNTRY]:-$COUNTRY}"

		MENU_ITEMS+=("$LOC" "$LANGNAME $COUNTRYNAME")
	done <"$TMPFILE"

	rm -f "$TMPFILE"

	locale=$(${DIALOG} \
		--title "Select locale" \
		--default-item "$DEFITEM" \
		--menu "Choose your locale" \
		20 70 18 \
		"${MENU_ITEMS[@]}" 2>&1 >/dev/tty)

	exit_status=$?
	case $exit_status in
	"$D_ESC" | "$D_CANCEL")
		return
		;;
	esac
	selected="$locale" # o que voltou do dialog
	for ((i = 0; i < ${#MENU_ITEMS[@]}; i += 2)); do
		if [[ "${MENU_ITEMS[i]}" == "$selected" ]]; then
			desc="${MENU_ITEMS[i + 1]}"
			break
		fi
	done
	AConfLocale[_LOCALE]="$selected"
	AConfLocale[_REGION]="$desc"
	LLOCALE=true
}

sh_chooseTimezone() {
	local -A Atimezone
	local -A Aflag
	local array=()
	local _localtime
	local defaultitem
	local fields
	local timezone
	local sorted_list
	local exit_status
	local areas=('Africa' 'America' 'Antarctica' 'Arctic' 'Asia' 'Atlantic' 'Australia' 'Europe' 'Pacific' 'Brazil' 'Canada' 'Chile' 'Indian' 'Mexico')
	local locations
	local area

	for area in "${areas[@]}"; do
		read -r -a locations -d '\n' < <(find /usr/share/zoneinfo/"$area" -type f -printf '%P\n')
		for key in "${locations[@]}"; do
			Atimezone+=([$key]="$area/$key")
		done
	done

	[[ -z "${AConfLocale[_TIMEZONE]}" ]] && AConfLocale[_TIMEZONE]='America/Sao_Paulo'
	defaultitem="${AConfLocale[_TIMEZONE]#*/}"

	if ! $LTIMEZONE; then
		_localtime=$(sh_timedatectl) && defaultitem="${_localtime#*/}"
		if [[ -z "${Atimezone[$defaultitem]}" ]]; then
			Atimezone["$defaultitem"]="$_localtime"
		fi
	fi

	sorted_list=$(for key in "${!Atimezone[@]}"; do echo "$key|${Atimezone[$key]}"; done | sort -t\| -k2 -k1)
	while IFS='|' LC_ALL=C read -r -a fields; do
		x="${fields[0]}"
		Aflag[$x]='off'
		Aflag[$defaultitem]='on'
		array+=("$x" "${Atimezone[$x]}" "${Aflag[$x]}")
	done <<<"${sorted_list[@]}"

	timezone=$(${DIALOG} \
		--title "$(gettext "=== FUSO HORÁRIO ===")" \
		--default-item "$defaultitem" \
		--colors \
		--cancel-label "${cmsg_ButtonBack}" \
		--ok-label "${cmsg_Aceitar}" \
		--radiolist "${cmsg_MENU}" \
		25 70 24 "${array[@]}" 2>&1 >/dev/tty)

	exit_status=$?
	case $exit_status in
	"$D_ESC" | "$D_CANCEL")
		return
		;;
	esac
	AConfLocale[_TIMEZONE]="${Atimezone[$timezone]}"
	LTIMEZONE=true
}

sh_chooseMirror() {
	declare -A Aflag
	local exit_status
	local array
	local sep="\xe2\x94\x82"
	local fields
	local key
	local sorted_list
	local -i FLD_MIRROR=0
	local -i FLD_REPOSITORY=1
	local -i FLD_REGION=2
	local -i FLD_LOCATION=3
	local -i FLD_TIER=4

	#		[void.chilios.com.br]="http://void.chilios.com.br/voidlinux/|South and Central America|Pimenta Bueno, Brazil|2"
	#		[void.chilios.com.br_2]="https://void.chilios.com.br/voidlinux/|South and Central America|Pimenta Bueno, Brazil|2"
	#		[void.chililinux.com_2]="http://void.chililinux.com/voidlinux/|South and Central America|Pimenta Bueno, Brazil|2"
	#  	[voidlinux.com.br]="https://voidlinux.com.br/repo/|South and Central America|Ouro Preto, Brazil|2"

	declare -gA Amirror=(
		[repo.fi.voidlinux.org]="https://repo-fi.voidlinux.org/|Europe|Helsinki, Finland|1"
		[repo.de.voidlinux.org]="https://repo-de.voidlinux.org/|Europe|Frankfurt, Germany|1"
		[repo.fastly.voidlinux.org]="https://repo-fastly.voidlinux.org/|Globally Available|Fastly Global CDN|1"
		[mirrors.summithq.com]="https://mirrors.summithq.com/voidlinux/|North America|Chicago, USA|1"
		[mirrors.servercentral.com]="https://mirrors.servercentral.com/voidlinux/|North America|Chicago, USA|1"
		[mirrors.cicku.me]="https://mirrors.cicku.me/voidlinux/|Globally Available|Cloudflare Global CDN|2"
		[void.chililinux.com]="https://void.chililinux.com/voidlinux/|South and Central America|Pimenta Bueno, Brazil|2"
		[mirror.sjtu.edu.cn]="https://mirror.sjtu.edu.cn/voidlinux/|Asia|Shanghai, China|2"
		[mirror.clarkson.edu]="https://mirror.clarkson.edu/voidlinux/|North America/|New York, USA|2"
		[void.webconverger.org]="https://void.webconverger.org/|Asia|Singapore|2"
		[ftp.swin.edu.au]="https://ftp.swin.edu.au/voidlinux/|Oceania|Melbourne, Australia|2"
		[ftp.debian.ru]="http://ftp.debian.ru/mirrors/voidlinux/|Europe|Russia|2"
		[mirror.yandex.ru]="https://mirror.yandex.ru/mirrorsvoidlinux/|Europe|Russia|2"
		[ftp.dk.xemacs.org]="http://ftp.dk.xemacs.org/voidlinux/|Europe|Denmark|2"
		[ftp.lysator.liu.se]="https://ftp.lysator.liu.se/pub/voidlinux/|Europe|Sweden|2"
		[mirror.nju.edu.cn]="https://mirror.nju.edu.cn/voidlinux/|Asia|China|2"
		[quantum - mirror.hu]="https://quantum-mirror.hu/mirrors/pub/voidlinux/|Europe|Hungary|2"
		[void.cijber.net]="https://void.cijber.net/|Europe/|Amsterdam, Netherlands|2"
		[mirror.puzzle.ch]="https://mirror.puzzle.ch/voidlinux/|Europe|Bern, Switzerland|2"
		[mirrors.dotsrc.org]="https://mirrors.dotsrc.org/voidlinux/|Europe|Denmark|2"
		[mirrors.bfsu.edu.cn]="https://mirrors.bfsu.edu.cn/voidlinux/|Asia|Beijing, China|2"
		[void.sakamoto.pl]="https://void.sakamoto.pl/|Europe|Warsaw, Poland|2"
		[mirrors.cnnic.cn]="https://mirrors.cnnic.cn/voidlinux/|Asia|Beijing, China|2"
		[mirror.vofr.net]="https://mirror.vofr.net/voidlinux/|North America|California, USA|2"
		[mirror.aarnet.edu.au]="https://mirror.aarnet.edu.aupub/voidlinux/|Oceania|Canberra, Australia|2"
		[mirror.ps.kz]="https://mirror.ps.kz/voidlinux/|Asia|Almaty, Kazakhstan|2"
		[voidlinux.mirror.garr.it]="https://voidlinux.mirror.garr.it/|Europe|Italy|2"
		[mirror2.sandyriver.net]="https://mirror2.sandyriver.net/pub/voidlinux/|North America|Kentucky, USA|2"
		[mirror.accum.se]="https://mirror.accum.se/mirror/voidlinux/|Europe|Sweden|2"
		[mirrors.tuna.tsinghua.edu.cn]="https://mirrors.tuna.tsinghua.edu.cn/voidlinux/|Asia|Beijing, China|2"
	)

	while true; do
		array=()
		sorted_list=$(for key in "${!Amirror[@]}"; do echo "$key|${Amirror[$key]}"; done | sort -t\| -k5 -k3)
		while IFS='|' LC_ALL=C read -r -a fields; do
			key="${fields[FLD_MIRROR]}"
			[[ "${AConfMirror[_MIRROR]}" = "$key" ]] && Aflag["$key"]='on' || Aflag["$key"]='off'
			array+=("$key" "$(printf "$sep%-6s$sep%-25s$sep%-23s$sep%-s" \
				"Tier ${fields[FLD_TIER]}" \
				"${fields[FLD_REGION]}" \
				"${fields[FLD_LOCATION]}" \
				"${fields[FLD_REPOSITORY]}")"
			"${Aflag[$key]}")
		done <<<"${sorted_list[@]}"

		mirror=$(${DIALOG} \
			--title "=== ${cmsg_Mirror^^} ===" \
			--stdout \
			--keep-tite \
			--aspect 20 \
			--clear \
			--backtitle "$ccabec" \
			--default-item "${AConfMirror[_MIRROR]}" \
			--colors \
			--cancel-label "${cmsg_ButtonBack}" \
			--ok-label "${cmsg_Aceitar}" \
			--extra-button --extra-label "void-testmirror" \
			--radiolist "${cmsg_MENU}" \
			24 0 2 "${array[@]}")

		exit_status=$?
		case $exit_status in
		"$D_ESC" | "$D_CANCEL")
			return 1
			;;
		3)
			oldgrafico=$grafico
			grafico=$true
			if [[ -n $(command -v void-testmirror) || -n $(command -v ./void-testmirror) ]]; then
				last_msg="Wait... ${cmsg_Gerando} test with void-testmirror ${xurl}"
				msg "=== ${cmsg_Mirror^^} === void-testmirror" "$last_msg" "$(log_info_msg "$last_msg")"
				result=$(void-testmirror --nocolor --ping --quiet)
				evaluate_retval "$?" "$err_not_fatal"
				[[ -z "$result" ]] && result="${RED}ERRO DESCONHECIDO: void-testmirror não retornou resultado${RESET}"
				info "=== ${cmsg_Mirror^^} === void-testmirror" "\n$result"
			else
				sh_info_msg "Wait... ${cmsg_Gerando} test with void-mirror ${xurl}"
				evaluate_retval "1" "$err_not_fatal"
				info "=== ${cmsg_Mirror^^} === void-testmirror" "\n${RED}void-testmirror não foi localizado no \$PATH${RESET}" \
					"${RED}void-testmirror não foi localizado em $PWD!${RESET}"
			fi
			grafico=$oldgrafico
			continue
			;;
		esac
		AConfMirror[_MIRROR]="$mirror"
		url_mirror="$(sh_splitarray "${Amirror[$mirror]}" "$FLD_REPOSITORY")"
		AConfMirror[url_mirror]="$(sh_splitarray "${Amirror[$mirror]}" "$FLD_REPOSITORY")"
		AConfMirror[location]="$(sh_splitarray "${Amirror[$mirror]}" "$FLD_LOCATION")"
		LMIRROR=true

		if [[ "$distro" = @(void|void-live|voidlinux) ]]; then
			if conf "=== ${cmsg_Mirror^^} ===" \
				"\n${BOLD}$(gettext "Aparentemente, o VOID Linux está sendo usado como host.")\n" \
				"\n${BOLD}${CYAN}Mirror     : ${AConfMirror[_MIRROR]}" \
				"\n${BOLD}${CYAN}Url Mirror : $url_mirror" \
				"\n${BOLD}${CYAN}Region     : $(sh_splitarray "${Amirror[$mirror]}" "$FLD_REGION")" \
				"\n${BOLD}${CYAN}Location   : $(sh_splitarray "${Amirror[$mirror]}" "$FLD_LOCATION")\n" \
				"\n${RED}$(gettext "Você também deseja definir/alterar o espelho do host para o escolhido?")${RESET}\n\n"; then

				sh_info_msg "${cmsg_Configurando} ${cmsg_Mirror,,} ${cmsg_Em} $dir_install"
				mkdir -p "/etc/xbps.d/"
				cat >"/etc/xbps.d/00-repository-main.conf" <<-EOF
					repository=${url_mirror}current
					repository=${url_mirror}current/nonfree
					repository=${url_mirror}current/multilib
					repository=${url_mirror}current/multilib/nonfree
				EOF
				evaluate_retval "$?"
			fi
		fi
		return 0
	done
}

sh_testcommand() {
	if [[ -z $(command -v "$1") ]]; then
		#		echo "$(gettext "não disponível")"
		"$(gettext "não disponível")"
	else
		#		echo "$(gettext "mais avançado")"
		"$(gettext "mais avançado")"
	fi
}

sh_execUtilDisk() {
	local exit_status
	${DIALOG} \
		--title "Modify Partition Table on ${AConfDisk[_DEVICE]}" \
		--colors \
		--msgbox "\n
${BOLD}${software} $(gettext "será executado no disco") ${AConfDisk[_DEVICE]}.${RESET}\n\n
$(gettext "Para sistemas BIOS, ")\
$(gettext "tabelas de partições MBR (dos) ou GPT são suportadas.")\n
$(gettext "Para usar o GPT em sistemas de BIOS de PC, ")
$(gettext "uma partição vazia de 1 MB deve ser adicionada")\n
$(gettext "nos primeiros 2 GB do disco com flag bios_grub ativada.")\n
${BOLD}$(gettext "NOTA: você não precisa disso em sistemas UEFI.")${RESET}\n\n
$(gettext "Para sistemas UEFI, GPT é obrigatório, e uma partição FAT32 com pelo menos")\n
$(gettext "100MB deve ser criado com a flag boot,")
$(gettext "este será usado como")\n
$(gettext "Partição do sistema UEFI.")\
$(gettext "Esta partição deve ter um ponto de montagem como") '/boot/efi'\n\n
$(gettext "Pelo menos 1 partição é necessária para rootfs") '(/)'.\n
$(gettext "Para o swap,") $(gettext "Uma RAM*2 deve ser realmente suficiente.")\
$(gettext "Para o / minímo de 600 MB são necessários.")\n\n
${BOLD}$(gettext "AVISO: /usr não é suportado como uma partição separada.")${RESET}\n
${RESET}\n" 18 80
	exit_status=$?
	if [ $exit_status -eq 0 ]; then
		while true; do
			clear
			"$software" "${AConfDisk[_DEVICE]}"
			LAUTO=false
			break
		done
	else
		return 1
	fi
	sh_disk_part_info
	return 0
}

sh_menuUtilDisk() {
	local array=()
	local i
	local n=0
	local nc=0
	local result
	local sep="\xe2\x94\x82"
	local -A ARRAY_UTIL_DISK=()

	ARRAY_UTIL_DISK+=(["automatic"]="Recommended|Automatic partitioning and formatting|")
	ARRAY_UTIL_DISK+=(["cfdisk"]=$([[ -z $(command -v "cfdisk") ]] && echo "Not available||" || echo "Easy to use|cfdisk is a curses-based program for partitioning any block device|"))
	ARRAY_UTIL_DISK+=(["fdisk"]=$([[ -z $(command -v "fdisk") ]] && echo "Not available||" || echo "More advanced|fdisk is a dialog-driven program for creation and manipulation of partition tables|"))
	ARRAY_UTIL_DISK+=(["gdisk"]=$([[ -z $(command -v "gdisk") ]] && echo "Not available||" || echo "More advanced|GPT fdisk (aka gdisk) is a text-mode menu-driven program for creation and manipulation of partition tables.|"))
	ARRAY_UTIL_DISK+=(["parted"]=$([[ -z $(command -v "parted") ]] && echo "Not available||" || echo "More advanced|parted is a program to manipulate disk partitions|"))

	for i in $(echo "${!ARRAY_UTIL_DISK[@]}" | tr ' ' '\n' | sort); do
		array[n++]="$i"
		array[n++]=$(printf "%-20s$sep%-30s" "$(sh_splitarray "${ARRAY_UTIL_DISK[$i]}" 1)" "$(sh_splitarray "${ARRAY_UTIL_DISK[$i]}" 2)")
		((nc++))
	done

	software=$(${DIALOG} \
		--colors --backtitle "$ccabec" \
		--title "$(gettext "Selecione o software para particionamento")" \
		--ok-label "${cmsg_Aceitar}" \
		--cancel-label "${cmsg_ButtonBack}" \
		--menu "${cmsg_MENU}\n\n\
${BOLD}DEVICE  : ${RESET}${RED}${AConfDisk[_DEVICE]}${RESET}\n\
${BOLD}MODEL   : ${RESET}${RED}$MODEL_ORIGEM${RESET}\n" \
		0 0 0 "${array[@]}" 2>&1 >/dev/tty)

	exit_status=$?
	case $exit_status in
	"$D_ESC" | "$D_CANCEL")
		return 1
		;;
	esac

	case "$software" in
	"automatic")
		if sh_chooseTablePartition; then
			LMKPARTED=false
			oldgrafico=$grafico
			grafico=$true
			sh_mkparted
			grafico=$oldgrafico
			sh_disk_part_info
		fi
		LAUTO=true
		return 0
		;;
	esac

	if sh_execUtilDisk; then
		LAUTO=false
	fi
	return 0
}

sh_getNvme() {
	local tran
	local name

	name="$(sh_splitarray "${AARRAY_DSK_DEVICES[${AConfDisk[_DEVICE]}]}" $DSK_NAME)"
	tran="$(sh_splitarray "${AARRAY_DSK_DEVICES[${AConfDisk[_DEVICE]}]}" $DSK_TRAN)"

	case "$tran" in
	nvme | loop) echo 'p' ;;
	lvm) echo '' ;;
	*)
		case "$name" in
		zram*) echo 'p' ;;
		nbd*) echo 'p' ;;
		*) echo '' ;;
		esac
		;;
	esac
}

sh_getlgrub() {
	local _device="$1"
	if [[ "$LGRUB" == "true" && "${AConfDisk[_BOOTLOADER]}" = "$_device" ]]; then
		echo '*'
	else
		echo ' '
	fi
}

sh_chooseDisk() {
	local old_device="${AConfDisk[_DEVICE]}"

	sh_umount_fs
	while true; do
		sh_disk_part_info
		local array=()
		local i
		local n=0
		local nlen=0
		local nc=0
		local result
		local sep="\xe2\x94\x82"
		local xtitle
		local LCHOOSEBOOTLOADER

		if [ $# -eq 0 ]; then
			xtitle="${cmsg_TitleDisco}"
			LCHOOSEBOOTLOADER=$false
		else
			xtitle="${cmsg_BootLoader^^}"
			LCHOOSEBOOTLOADER=$true
		fi

		for i in "${ARRAY_DSK_DEVICES[@]}"; do
			array[n++]="$i"
			if ((nlen < ${#i})); then
				nlen=${#i}
			fi
			array[n++]=$(printf "$sep%-4s$sep%-6s$sep%6s$sep%-6s$sep%-15s$sep%-30s" \
				"$(sh_getlgrub "$i")" \
				"${ARRAY_DSK_TRAN[$nc]}" \
				"${ARRAY_DSK_SIZE[$nc]}" \
				"${ARRAY_DSK_PTTYPE[$nc]}" \
				"${ARRAY_DSK_LABEL[$nc]}" \
				"${ARRAY_DSK_MODEL[$nc]}")
			((nc++))
		done
		((nlen += 6))
		sd=$(${DIALOG} \
			--default-item "${AConfDisk[_DEVICE]}" \
			--backtitle "$ccabec" \
			--title "$xtitle" \
			--ok-label "${cmsg_ButtonEscolher}" \
			--cancel-label "${cmsg_ButtonBack}" \
			--colors \
			--extra-button \
			--extra-button --extra-label "${cmsg_Particionar}" \
			--menu "${cmsg_MENU}\n\n\
$(printf "%${nlen}s$sep%-4s$sep%-6s$sep%6s$sep%-6s$sep%-15s$sep%-30s" "DEVICE" "BOOT" "TRAN" "SIZE" "PTTYPE" "LABEL" "MODEL")" \
			24 0 2 "${array[@]}" 2>&1 >/dev/tty)

		exit_status=$?
		case $exit_status in
		"$D_ESC" | "$D_CANCEL")
			return 1
			;;
		esac

		if [[ -n "$sd" ]]; then
			if ((LCHOOSEBOOTLOADER)); then
				AConfDisk[_BOOTLOADER]="$sd"
				LGRUB=true
				LOSPROBER=false
				return 0
			fi
			AConfDisk[_DEVICE]="$sd"
			AConfDisk[_BOOTLOADER]="$sd"
			index=$(sh_seekstrarray "${ARRAY_DSK_DEVICES[*]}" "${AConfDisk[_DEVICE]}")
			NAME_ORIGEM="$(sh_splitarray "${AARRAY_DSK_DEVICES[${AConfDisk[_DEVICE]}]}" "$DSK_NAME")"
			MODEL_ORIGEM="$(sh_splitarray "${AARRAY_DSK_DEVICES[${AConfDisk[_DEVICE]}]}" "$DSK_MODEL")"
			SIZE_ORIGEM="$(sh_splitarray "${AARRAY_DSK_DEVICES[${AConfDisk[_DEVICE]}]}" "$DSK_SIZE")"
			TRAN_ORIGEM="$(sh_splitarray "${AARRAY_DSK_DEVICES[${AConfDisk[_DEVICE]}]}" "$DSK_TRAN")"
			LDISK=true
			LGRUB=true
		fi

		case $exit_status in
		"$D_OK")
			AConfDisk[_DEVICE]="$sd"
			AConfDisk[_BOOTLOADER]="$sd"
			sh_checkdisk "$sd"
			sh_backup_partitions "$sd" "$NAME_ORIGEM"
			LDISK=true
			LGRUB=true
			LOSPROBER=false
			sh_rebuild_amntpoint_for_new_disk
			return 0
			;;
		"$D_CONFIG")
			sh_checkdisk "${AConfDisk[_DEVICE]}"
			sh_menuUtilDisk
			continue
			;;
		esac
	done
	LDISK=true
	return 0
}

sh_setBootLoader() {
	if sh_chooseDisk "=== BOOTLOADER (GRUB) ==="; then
		AConfDisk[_BOOTLOADER]="${AConfDisk[_DEVICE]}"
		LGRUB=true
		LOSPROBER=false
		if conf "=== OS-PROBER ===" "\n$(gettext "Detectar outro OS(s) instalado ?")\n\n"; then
			LOSPROBER=true
		fi
		AConfDisk[_OSPROBER]="$LOSPROBER"
		return 0
	fi
	return 1
}

sh_chooseTablePartition() {
	local -A Atable
	local -A Aflag
	local cextra
	local exit_status
	local array=()
	local x

	Atable[EFI]="${cmsg_Efi} - ${cmsg_TabelaGPT}"
	Atable[GPT_BIOS]="${cmsg_Bios} - ${cmsg_TabelaGPT}"
	Atable[MBR_BIOS]="${cmsg_Bios} - ${cmsg_TabelaMBR}"
	cextra="${cmsg_ExtraNotEfi}"

	for x in "${!Atable[@]}"; do
		Aflag[$x]='off'
		if sh_getBootEFI; then
			Aflag[EFI]='on'
			cextra="${cmsg_ExtraEfi}"
		fi
		if [[ -z "${AConfDisk[_DISKTABLE]}" ]]; then
			sh_getBootEFI && AConfDisk[_DISKTABLE]='EFI' || AConfDisk[_DISKTABLE]='GPT_BIOS'
		fi
		Aflag["${AConfDisk[_DISKTABLE]}"]='on'
		array+=("$x" "${Atable[$x]}" "${Aflag[$x]}")
	done

	table=$(${DIALOG} \
		--title "$(gettext "=== TABELA DE PARTIÇÕES ===")" \
		--default-item "${AConfDisk[_DISKTABLE]}" \
		--colors \
		--cancel-label "${cmsg_ButtonBack}" \
		--ok-label "${cmsg_Aceitar}" \
		--radiolist "${cmsg_MENU}\n\n$cextra" \
		12 85 0 "${array[@]}" 2>&1 >/dev/tty)

	exit_status=$?
	case $exit_status in
	"$D_ESC" | "$D_CANCEL")
		return 1
		;;
	"$D_OK")
		if [[ "$table" = "GPT" ]]; then
			if ! sh_getBootEFI; then
				info "$ccabec" "$cextra"
				sh_chooseTablePartition
			fi
		fi
		;;
	esac
	AConfDisk[_DISKTABLE]="$table"
	return 0
}

sh_checkdisk() {
	local device="$1"
	local dsk

	sh_info_msg "${cmsg_ChecandoParticoesMontadas}: $device"
	if [[ "$device" == /dev/zram* ]]; then
		if grep -qw "$device" /proc/swaps; then
			if ! conf "=== CHECKDISK ===" "\n${BOLD}${RED}ERRO:${RESET} o device: '$device' está ativo como swap (zram). Desativar?\n\n"; then
				evaluate_retval "$err_fatal" "$err_fatal" "zram ativo (swap): $device"
				return 1
			fi
			swapoff "$device" 2>/dev/null || {
				evaluate_retval "$err_fatal" "$err_fatal" "falha ao desativar zram: $device"
				return 1
			}
		fi
		return 0
	fi

	# desmonta qualquer partição do device (loop, sdX, nvme, nbd, etc) usando findmnt corretamente (SOURCE -> TARGET)
	# coleta todos os mountpoints das partições do device
	mnts="$(findmnt -rn -o TARGET,SOURCE | awk -v d="$device" '$2 ~ "^"d {print $1}')"
	if [[ -n "$mnts" ]]; then
		if ! conf "=== CHECKDISK ===" "\n${BOLD}${RED}ERRO:${RESET} o device: '$device' tem partições montadas! Desmontar?\n\n"; then
			evaluate_retval "$err_fatal" "$err_fatal" \
				"${cmsg_all_mounted_part}: $mnts"
			return 1
		fi
		# desmonta em ordem reversa (filho -> pai)
		while read -r mp; do
			umount "$mp" 2>/dev/null || {
				evaluate_retval "$err_fatal" "$err_fatal" "falha ao desmontar $mp"
				return 1
			}
		done <<<"$(printf '%s\n' "$mnts" | sort -r)"
	fi
	# desativa swap do device (swap não aparece no findmnt)
	while read -r sw; do
		swapoff "$sw" 2>/dev/null || {
			evaluate_retval "$err_fatal" "$err_fatal" "falha ao desativar swap: $sw"
			return 1
		}
	done < <(
		swapon --noheadings --raw | awk -v d="$device" '$1 ~ "^"d {print $1}'
	)
	return 0
}

sh_confadduser() {
	local size
	local model

	sh_setUser
	size=$(sh_splitarray "${AARRAY_DSK_DEVICES[${AConfDisk[_BOOTLOADER]}]}" 2)
	model=$(sh_splitarray "${AARRAY_DSK_DEVICES[${AConfDisk[_BOOTLOADER]}]}" 4)
	while true; do
		exec 3>&1
		usertext=$(${DIALOG} \
			--title "$(gettext "=== EXTRA ===")" \
			--colors \
			--ok-label "${cmsg_Aceitar}" \
			--cancel-label "${cmsg_ButtonBack}" \
			--backtitle "$ccabec" \
			--insecure "$@" \
			--mixedform "${cmsg_MENU}" \
			0 0 0 \
			"${cmsg_Extra1}: " 1 1 "${AsUser[cfullname]}" 1 28 40 0 0 \
			"${cmsg_Extra2}: " 2 1 "${AsUser[cuser]}" 2 28 20 0 0 \
			"${cmsg_Extra3} (${AsUser[cpass]}): " 3 1 "${AsUser[cpass]}" 3 28 20 0 1 \
			"${cmsg_Extra4} (${AsUser[cpassroot]}): " 4 1 "${AsUser[cpassroot]}" 4 28 20 0 1 \
			"Hostname: " 5 1 "${AsUser[chostname]}" 5 28 20 0 0 \
			"${cmsg_Extra6}: " 6 1 "${AConfDisk[_DEVICE]}" 6 28 20 0 2 \
			"Tam/Model: " 7 1 "$size/$model" 7 28 20 0 2 \
			"${cmsg_Teclado}: " 8 1 "${AConfLocale[_KEYMAP]}" 8 28 20 0 2 \
			"Timezone: " 9 1 "${AConfLocale[_TIMEZONE]}" 9 28 20 0 2 \
			"${cmsg_Extra11}: " 10 1 "${_WINDOWMANAGER[*]}" 10 28 30 0 2 \
			2>&1 1>&3)

		exit_status=$?
		case $exit_status in
		"$D_ESC" | "$D_CANCEL")
			return
			;;
		"$D_OK")
			mapfile -t aUser <<<"$usertext"
			AsUser[cfullname]="${aUser[0]}"
			AsUser[cuser]="${aUser[1]}"
			AsUser[cpass]="${aUser[2]}"
			AsUser[cpassroot]="${aUser[3]}"
			AsUser[chostname]="${aUser[4]}"

			if [[ "${AsUser[cuser]}" == "root" ]]; then
				if ! conf "$(gettext "=== USUÁRIO ===")" "\n${cmsg_adduser1}"; then
					die "$(gettext "=== USUÁRIO === ")" "${cmsg_adduserCancel}"
					return 1
				fi
				sh_confadduser
			fi

			if [[ -z "${AsUser[cuser]}" ]]; then
				if ! conf "=== ${cmsg_Usuario^^} ===" "\n${cmsg_adduser2}"; then
					die "=== ${cmsg_Usuario^^} === " "${cmsg_adduserCancel}"
					return 1
				fi
				sh_confadduser
			fi

			# Verificar se usuario começa com um número
			if [[ "${AsUser[cuser]}" =~ ^[0-9] ]]; then
				if ! conf "=== ${cmsg_Usuario^^} ===" "\n${cmsg_adduser5}"; then
					die "$(gettext "=== USUÁRIO === ")" "${cmsg_adduserCancel}"
					return 1
				fi
				sh_confadduser
			fi

			# Verificar se string1 começa com uma letra maiúscula
			if [[ "${AsUser[cuser]}" =~ ^[A-Z] ]]; then
				if ! conf "=== ${cmsg_Usuario^^} ===" "\n${cmsg_adduser6}"; then
					die "$(gettext "=== USUÁRIO === ")" "${cmsg_adduserCancel}"
					return 1
				fi
				sh_confadduser
			fi

			if [[ -z "${AsUser[cpass]}" ]]; then
				if ! conf "=== ${cmsg_Usuario^^} ===" "\n${cmsg_adduser3}"; then
					die "=== ${cmsg_Usuario^^} ===" "${cmsg_adduserCancel}"
					return 1
				fi
				sh_confadduser
			fi

			if [[ -z "${AsUser[cpassroot]}" ]]; then
				if ! conf "=== ROOT ===" "\n${cmsg_adduser4}"; then
					die "=== ROOT === " "${cmsg_adduserCancel}"
					return 1
				fi
				sh_confadduser
			fi
			LEXTRA=true
			;;
		esac
		exec 3>&-
		return 0
	done
}

sh_choosewifi() {
	while true; do
		local array=()
		local i
		local n=0
		local nc=0
		local result
		local sep="\xe2\x94\x82"

		sh_info_msg "$(gettext 'Escaneando redes wifi...')"
		wpa_cli scan_results 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
		if [[ "${PIPESTATUS[0]}" -gt 0 ]]; then
			evaluate_retval "1" "$err_not_fatal"
			info "WIFI" "${RED}$(gettext "A verificação não retornou nenhum resultado.")" \
				"$(gettext "Aparentemente,") $(gettext "o serviço wpa_supplicant não está em execução.")" \
				"" \
				"$(gettext "Tente o seguinte:")" \
				"${BOLD}1-$(gettext "Usar a opção no menu de serviços para ativar.")" \
				"2-$(gettext "Verifique se há um dispositivo wi-fi conectado à máquina.")"
			return 1
		fi
		evaluate_retval "0"
		scan_results=$(wpa_cli scan_results)
		lines=$(wc -l <<<"$scan_results")
		lines=$((lines - 2))

		unset ARRAY_{SSID,BSID,SIGNAL,FREQUENCY,FLAGS}
		while read -r line; do
			ARRAY_SSID+=("$(awk '{print $5" "$6" "$7}' <<<"$line")")
			ARRAY_BSID+=($(cut -f1 <<<"$line"))
			ARRAY_SIGNAL+=($(cut -f2 <<<"$line"))
			ARRAY_FREQUENCY+=($(cut -f3 <<<"$line"))
			ARRAY_FLAGS+=($(cut -f4 <<<"$line"))
		done < <(tail -$lines <<<"$scan_results")

		for i in "${ARRAY_SSID[@]}"; do
			array[n++]="$i"
			array[n++]=$(printf "$sep%-6s$sep%-4s$sep%3s$sep%-30s" "${ARRAY_BSID[$nc]}" "${ARRAY_SIGNAL[$nc]}" "${ARRAY_FREQUENCY[$nc]}" "${ARRAY_FLAGS[$nc]}")
			((nc++))
		done

		wifi=$(${DIALOG} \
			--default-item "$_WIFI_NETWORK" \
			--backtitle "$ccabec" \
			--title "WIFI" \
			--ok-label "${cmsg_Aceitar}" \
			--cancel-label "${cmsg_ButtonBack}" \
			--colors \
			--menu "${cmsg_MENU}" 0 0 10 "${array[@]}" 2>&1 >/dev/tty)

		exit_status=$?
		case $exit_status in
		"$D_ESC" | "$D_CANCEL")
			return
			;;
		esac
		_WIFI_NETWORK=$wifi
		AConfWifi[_NETWORK]=$wifi
		break
	done
}

sh_confWifi() {
	while true; do
		exec 3>&1
		wifitext=$(${DIALOG} \
			--title "$(gettext "=== WIFI ===")" \
			--colors \
			--ok-label "${cmsg_Aceitar}" \
			--cancel-label "${cmsg_ButtonBack}" \
			--backtitle "$ccabec" \
			--insecure "$@" \
			--extra-button --extra-label "Scan wifi" \
			--mixedform "${cmsg_MENU}" \
			0 0 0 \
			"${cmsg_redewifi}: " 1 1 "$_WIFI_NETWORK" 1 20 40 0 0 \
			"${cmsg_senhawifi}: " 2 1 "$_WIFI_PASSWORD" 2 20 40 0 1 \
			2>&1 1>&3)

		exit_status=$?
		case $exit_status in
		"$D_ESC" | "$D_CANCEL")
			return
			;;
		"$D_OK")
			mapfile -t aWifi <<<"$wifitext"
			_WIFI_NETWORK="${aWifi[0]}"
			_WIFI_PASSWORD="${aWifi[1]}"
			AConfWifi[_NETWORK]="${aWifi[0]}"
			AConfWifi[_PASSWORD]="${aWifi[1]}"
			LWIFI=$true
			;;
		3)
			sh_choosewifi
			continue
			;;
		esac
		exec 3>&-
		return 0
	done
}

sh_dryrun() {
	sh_umount_fs
	sh_mount_fs
	sh_init_bind

	#  sh_update_locale
	#	sh_update_rc_conf
	#	sh_update_rc_local
	#	sh_activating_services
	export PS1="[chroot $dir_install] $PS1"
	LC_ALL=C chroot "$dir_install" "/bin/bash"
	sh_umount_fs
}

sh_usage() {
	local usage=$(gettext "usar:")
	local operation=$(gettext "operação")

	cat <<EOF
${white}${APP} v$_VERSION_${reset}
${orange}$usage ${APP} ${reset}<$operation> [...]
${orange}     ${APP} ${reset}-i
${orange}     ${APP} ${reset}-i [-f <file>]
${orange}     ${APP} ${reset}[-i|c|f|g|q|V|n|h]
${orange}     ${APP} ${reset}[--install|--chroot|--file|--grafico|--quiet|--version|--nocolor|--help]

[<operations>] ${reset}
   ${red}-i  --install${cyan}       # ${cmsg_Usage1}
   ${red}-c  --chroot${cyan}        # ${cmsg_Usage2}
   ${red}-f  --file${cyan}          # ${cmsg_Usage8} (default: $app_conf)
   ${red}-g  --grafico${cyan}       # ${cmsg_Usage3}
   ${red}-q  --quiet${cyan}         # ${cmsg_Usage4}
   ${red}-V  --version${cyan}       # ${cmsg_Usage5}
   ${red}-n  --nocolor${cyan}       # ${cmsg_Usage6}
   ${red}-h  --help${cyan}          # ${cmsg_Usage7}${reset}
EOF
}

sh_loadconf() {
	sh_info_msg "$(gettext 'Loading configuration file'): ${yellow}$app_conf"
	if [ -f "$app_conf" ] && [ -r "$app_conf" ]; then
		# shellcheck source=/dev/null
		source "$app_conf"
		evaluate_retval "$?"
		sh_parseconf
	else
		evaluate_retval "$?" "1" "${cmsg_falhaAbertura} $app_conf!"
	fi
}

sh_parseconf() {
	sh_info_msg "$(gettext 'Analisando o arquivo de configuração'): ${yellow}$app_conf"

	url_mirror="${AConfMirror[url_mirror]}"
	[[ -n "${AsUser[cuser]}" && -n "${AsUser[cpass]}" && -n "${AsUser[cpassroot]}" && -n "${AsUser[chostname]}" ]] && LEXTRA=true
	[[ -n "${AConfLocale[_TIMEZONE]}" ]] && LTIMEZONE=true
	[[ -n "${AConfLocale[_KEYMAP]}" ]] && LKEYMAP=true
	[[ -n "${AConfMirror[_MIRROR]}" && -n "$url_mirror" ]] && LMIRROR=true
	[[ -n "${AConfMirror[_SOURCE]}" ]] && LSOURCE=true
	[[ -n "${AConfAudio[_AUDIOSERVER]}" ]] && LAUDIO=true
	[[ -n "${Amntpoint[*]}" ]] && LPARTITION=true
	[[ -n ${_WINDOWMANAGER[*]} ]] && LWM=true
	evaluate_retval "${PIPESTATUS[0]}" "$err_not_fatal"
}

sh_mkefiroaming() {
	#Caminho de inicialização padrão/reserva
	if [[ -e "$dir_install/boot/efi/EFI/$cnickefi/grubx64.efi" ]]; then
		sh_info_msg "${cmsg_CriandoDiretorios}: $dir_install/boot/efi/EFI/BOOT"
		mkdir -p "$dir_install/boot/efi/EFI/BOOT" 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
		evaluate_retval "${PIPESTATUS[0]}" "$err_not_fatal"

		sh_info_msg "${cmsg_CopiandoCaminhoReserva}: $dir_install/boot/efi/BOOT"
		cp "$dir_install/boot/efi/EFI/$cnickefi/grubx64.efi" "$dir_install/boot/efi/EFI/BOOT/BOOTX64.EFI" 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
		evaluate_retval "${PIPESTATUS[0]}" "$err_not_fatal"
	fi
}

sh_getBootEFI() {
	if [ -d /sys/firmware/efi ]; then
		TARGET_EFI=x86_64-efi
		if [ -r /sys/firmware/efi/fw_platform_size ] &&
			[ "$(cat /sys/firmware/efi/fw_platform_size)" -eq 32 ]; then
			TARGET_EFI=i386-efi
		fi
		return 0
	fi
	return 1
}

sh_choosewm() {
	declare -A aFlag
	declare -A aWm
	local x

	if [[ "${AConfMirror[_SOURCE]}" = "local" ]]; then
		alerta "$ccabec" "Instalação escolhida foi via local/ISO, não é necessário alterar nada aqui"
		_WINDOWMANAGER='tty'
		LWM=true
		return
	fi

	aWm[tty]="${cmsg_tty}"
	aWm[xorg]="Xorg Minimal"
	aWm[awesome]="Awesome"
	aWm[blackbox]="Blackbox"
	aWm[bspwm]="Tiling window manager based on binary space partitioning"
	aWm[dwm]="Dwm"
	aWm[enlightenment]="Enlightenment desktop shell"
	aWm[fluxbox]="Fluxbox"
	aWm[gnome]="Gnome"
	aWm[hyprland]="Dynamic wlroots-based tiling Wayland compositor"
	aWm[i3wm]="i3wm"
	aWm[lxde]="The 'Lightweight X11 Desktop Environment'"
	aWm[lxqt]="The 'Lightweight Qt Desktop Environment'"
	aWm[mate]="Mate"
	aWm[openbox]="Openbox"
	aWm[plasma]="Kde Plasma-Desktop"
	aWm[sway]="Sway"
	aWm[twm]="Twm"
	aWm[xfce4]="Xfce4"

	for x in "${!aWm[@]}"; do
		aFlag[$x]='off'
	done

	for x in "${_WINDOWMANAGER[@]}"; do
		aFlag[$x]='on'
	done

	wm=$(${DIALOG} --title "=== ${cmsg_Wm^^} ===" \
		--default-item "$_WINDOWMANAGER" \
		--colors \
		--cancel-label "${cmsg_ButtonBack}" \
		--ok-label "${cmsg_Aceitar}" \
		--checklist "${cmsg_MENU}" \
		0 0 0 \
		tty "${aWm[tty]}" "${aFlag[tty]}" \
		xorg "${aWm[xorg]}" "${aFlag[xorg]}" \
		awesome "${aWm[awesome]}" "${aFlag[awesome]}" \
		bspwm "${aWm[bspwm]}" "${aFlag[bspwm]}" \
		dwm "${aWm[dwm]}" "${aFlag[dwm]}" \
		blackbox "${aWm[blackbox]}" "${aFlag[blackbox]}" \
		fluxbox "${aWm[fluxbox]}" "${aFlag[fluxbox]}" \
		enlightenment "${aWm[enlightenment]}" "${aFlag[enlightenment]}" \
		gnome "${aWm[gnome]}" "${aFlag[gnome]}" \
		hyprland "${aWm[hyprland]}" "${aFlag[hyprland]}" \
		i3wm "${aWm[i3wm]}" "${aFlag[i3wm]}" \
		lxde "${aWm[lxde]}" "${aFlag[lxde]}" \
		lxqt "${aWm[lxqt]}" "${aFlag[lxqt]}" \
		mate "${aWm[mate]}" "${aFlag[mate]}" \
		openbox "${aWm[openbox]}" "${aFlag[openbox]}" \
		plasma "${aWm[plasma]}" "${aFlag[plasma]}" \
		sway "${aWm[sway]}" "${aFlag[sway]}" \
		twm "${aWm[twm]}" "${aFlag[twm]}" \
		xfce4 "${aWm[xfce4]}" "${aFlag[xfce4]}" \
		2>&1 >/dev/tty)

	exit_status=$?
	case $exit_status in
	"$D_ESC" | "$D_CANCEL")
		return
		;;
	esac

	HYPRLAND=false
	if conf "=== ${cmsg_Wm^^} ===" \
		"\n${BOLD}${WHITE}$(gettext "Uma instalação customizada irá instalar pacotes extras e também")" \
		"\n$(gettext "fazer diversas configurações, evitando faze-las manualmente posteriormente.")\n" \
		"\n${BOLD}${RED}$(gettext "Customizar a instalação?")\n\n"; then
		LCUSTOM=true
	else
		LCUSTOM=false
	fi

	_WINDOWMANAGER=($(strtoarray "$wm"))
	if grep -qi hyprland <<<"${_WINDOWMANAGER[@]}"; then
		HYPRLAND=true
	fi
	LWM=true
}

function pcount() {
	local -i nargs="$#"
	echo $nargs
	[[ nargs -gt 0 ]] && return 0 || return 1
}

strtoarray() {
	local anew
	IFS=' ' read -r -a anew <<<"$1"
	echo "${anew[@]}"
}

lenarraystr() {
	local new=$1
	read -ra ADDR <<<"$new"
	echo "${#ADDR[@]}"
}

sh_chooseKeymap() {
	if notconf "=== ${cmsg_Teclado^^} ===" "${cmsg_LayoutAtual} : \Zb\Z1${AConfLocale[_KEYMAP]}${RESET}" "\n\n${cmsgSetKeyboardLayout}?"; then
		LKEYMAP=true
		return 0
	fi

	localectl 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER

	if [ "${PIPESTATUS[0]}" -eq 0 ]; then
		items=$(localectl list-keymaps | sort -V)
	else
		items=$(find /usr/share/kbd/keymaps/ -iname "*.gz" -type f -printf "%f\n" | sort -V)
	fi

	options=()

	for item in ${items}; do
		options+=("${item%%.*}" "")
	done

	keymap=$(${DIALOG} \
		--colors \
		--default-item "${AConfLocale[_KEYMAP]}" \
		--backtitle "${ccabec}" \
		--ok-label "${cmsg_Aceitar}" \
		--cancel-label "${cmsg_ButtonBack}" \
		--title "${cmsg_descTeclado}" \
		--menu "${cmsg_MENU}" \
		0 70 0 \
		"${options[@]}" 3>&1 1>&2 2>&3)

	nchoice=$?
	if ! ((nchoice)); then
		loadkeys "$keymap"
		AConfLocale[_KEYMAP]="$keymap"
		LKEYMAP=true
	fi
	return $nchoice
}

sh_chmod_tmp() {
	local cfile="$dir_install/etc/runit/core-services/03-filesystems.sh"

	sh_info_msg "${cmsg_Ajustando} ${cmsg_Permissoes} ${cmsg_Em} $dir_install"
	if [[ -e "$cfile" ]]; then
		{
			echo ''
			echo 'msg $(gettext "Ajustando permissões para") /tmp and /var/tmp ...'
			echo 'mkdir -p /tmp /var/tmp'
			echo 'chmod 1777 /tmp /var/tmp'
		} >>"$cfile"
	fi
	evaluate_retval "$?" "$err_not_fatal"
}

sh_copy_scripts() {
	local cfiles=(void-chroot
		void-clonedisk
		void-gitclone
		void-install
		void-maketar
		void-mirror
		void-parted
		void-remove-vg
		void-runimage
		void-services
		void-testmirror
		void-wifi
		void-wifi-config
		void-wifi-config-wpa
		void-dialog-theme-selector
		void-xrandr
	)
	local script

	sh_info_msg "${cmsg_Copiando} scripts ${cmsg_Para} $dir_install"
	for script in "${cfiles[@]}"; do
		if [[ -e "$script" ]]; then
			cp -f "$script" "$dir_install/usr/bin/" 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
		fi
	done
	evaluate_retval "${PIPESTATUS[0]}" "$err_not_fatal"
}

display_config() {
	sh_disk_part_info
	#                                     \n$(padr "${cmsg_Extra3} :" 30 ' ') \Zb\Z0$(sh_gethidden-password "${AsUser[cpass]}")${RESET}\
	#                                     \n$(padr "${cmsg_Extra4} :" 30 ' ') \Zb\Z0$(sh_gethidden-password "${AsUser[cpassroot]}")${RESET}\
	#   \n$(padr "${cmsg_senhawifi} (${cmsg_opcional}) :" 30 ' ') \Zb\Z0$(sh_gethidden-password "${AConfWifi[_PASSWORD]}")${RESET}\
	SETUP="\
                            			  \n$(padr "${cmsg_Extra2} :" 30 ' ') \Zb\Z0${AsUser[cuser]} - [${AsUser[cfullname]}] ${RESET}\
                                                         \n$(padr "Hostname :" 30 ' ') \Zb\Z0${AsUser[chostname]}${RESET}\
                                     \n$(padr "${cmsg_Teclado} :" 30 ' ') \Zb\Z0${AConfLocale[_KEYMAP]}${RESET}\
                                                         \n$(padr "Timezone :" 30 ' ') \Zb\Z0${AConfLocale[_TIMEZONE]}${RESET}\
     \n$(padr "${cmsg_redewifi} (${cmsg_opcional}) :" 30 ' ') \Zb\Z0${AConfWifi[_NETWORK]}${RESET}\
                                                   \n$(padr "${cmsg_Mirror} :" 30 ' ') \Zb\Z0${AConfMirror[url_mirror]} - ${AConfMirror[location]}${RESET}\
                                      \n$(padr "${cmsg_Source} :" 30 ' ') \Zb\Z0${AConfMirror[_SOURCE]}${RESET}\
                                      \n$(padr "${cmsg_Extra6} :" 30 ' ') \Zb\Z0${AConfDisk[_DEVICE]} | $(sh_splitarray "${AARRAY_DSK_DEVICES[${AConfDisk[_BOOTLOADER]}]}" 2) | $(sh_splitarray "${AARRAY_DSK_DEVICES[${AConfDisk[_BOOTLOADER]}]}" 4)${RESET}\
       \n$(padr "${cmsg_BootLoader} (${AConfDisk[_DISKTABLE]}) :" 30 ' ') \Zb\Z0${AConfDisk[_BOOTLOADER]} | $(sh_splitarray "${AARRAY_DSK_DEVICES[${AConfDisk[_BOOTLOADER]}]}" 2) | $(sh_splitarray "${AARRAY_DSK_DEVICES[${AConfDisk[_BOOTLOADER]}]}" 4)${RESET}\
                                          \n$(padr "Detect SO's (os-prober) :" 30 ' ') \Zb\Z0$(sh_getyes "${AConfDisk[_OSPROBER]}")${RESET}\
                                     \n$(padr "${cmsg_Extra11} :" 30 ' ') \Zb\Z0"${_WINDOWMANAGER[*]}"${RESET}\
                                                     \n$(padr "Customizacao :" 30 ' ') \Zb\Z0$(sh_getTrueFalse "$LCUSTOM")${RESET}\
                                                              \n$(padr "Fde :" 30 ' ') \Zb\Z0$(sh_getinfoFde "$LFDE")${RESET}\
                                                              \n$(padr "Lvm :" 30 ' ') \Zb\Z0$(sh_getinfoFde "$LVM")${RESET}\
                                            \n$(padr "FileSystem/Mountpoint :" 30 ' ') ${BOLD}${GREEN}↓↓↓\
                                                       \n\Zb\Z4$(sh_getmntpoint)${RESET}${RESET}"
}

sh_getTrueFalse() {
	local var="$1"
	[[ "$var" == 'true' ]] && echo 'Sim' || echo 'Nao'
}

sh_getinfoFde() {
	local lfde="$1"
	local str
	local _vg
	str="$(sh_getyes "$lfde")"
	_vg="${AConfFde[vg]}"

	case $lfde in
	1)
		str+="|$_vg|${AConfFde[partition]}|/$_vg/root=${AConfFde[lvroot]}"
		[[ -n "${AConfFde[lvswap]}" ]] && str+="|/$_vg/swap=${AConfFde[lvswap]}"
		[[ -n "${AConfFde[lvvar]}" ]] && str+="|/$_vg/var=${AConfFde[lvvar]}"
		[[ -n "${AConfFde[lvhome]}" ]] && str+="|/$_vg/home=${AConfFde[lvhome]}"
		;;
	esac
	echo "$str"
}

sh_getmntpoint() {
	local str
	local nlen=13
	local sep="\xe2\x94\x82"

	str+="\
$(printf "%-${nlen}s" PARTITION)	\
$(printf "$sep%-${nlen}s" FSTYPE)	\
$(printf "$sep%-${nlen}s" SIZE)	\
$(printf "$sep%-${nlen}s" LABEL)	\
$(printf "$sep%-${nlen}s" MOUNTPOINT)	\
$(printf "$sep%-${nlen}s" NEWFSTYPE)	\
$(printf "$sep%-${nlen}s" FORMAT)"
	str+="\n"

	for i in $(echo "${!Amntpoint[@]}" | tr ' ' '\n' | sort); do
		str+="$(printf "%-${nlen}s" "$i")	\
$(printf "$sep%-${nlen}s" "$(sh_splitarray "${AARRAY_PART_DEVICES[$i]}" 7)")	\
$(printf "$sep%-${nlen}s" "$(sh_splitarray "${AARRAY_PART_DEVICES[$i]}" 2)")	\
$(printf "$sep%-${nlen}s" "$(sh_splitarray "${AARRAY_PART_DEVICES[$i]}" 5)")	\
$(printf "$sep%-${nlen}s" "$(sh_splitarray "${Amntpoint[$i]}" 1)")	\
$(printf "$sep%-${nlen}s" "$(sh_splitarray "${Amntpoint[$i]}" 2)")	\
$(printf "$sep%-${nlen}s" "$(sh_getyes "$(sh_splitarray "${Amntpoint[$i]}" 3)")")"
		str+="\n"
	done
	echo "$str"
}

sh_gethidden-password() {
	local senha="$1"
	echo -e "${senha//?/*}"
}

sh_checkInstall() {
	local cmdsearch

	if ! $LMIRROR; then
		alerta "${cmsg_Mirror^^}" "${cmsg_Mirror} ${cmsg_NotConfDefault}"
		DEFITEM="${cmsg_Mirror}"
		return 1
	elif ! $LSOURCE; then
		alerta "${cmsg_Source^^}" "${cmsg_Source} ${cmsg_NotConfDefault}"
		DEFITEM="${cmsg_Source}"
		return 1
	elif ! $LDISK; then
		alerta "${cmsg_Disco^^}" "${cmsg_Disco} ${cmsg_NotConfDefault}"
		DEFITEM="${cmsg_Disco}"
		return 1
	elif ! sh_validate_filesystem; then
		DEFITEM="FileSystem"
		return 1
	elif ! $LGRUB; then
		alerta "${cmsg_BootLoader^^}" "${cmsg_NotConfBootLoader}"
		DEFITEM="${cmsg_BootLoader}"
		return 1
	elif ! $LKEYMAP; then
		alerta "${cmsg_Teclado^^}" "${cmsg_NotConfTeclado}"
		DEFITEM="${cmsg_Teclado}"
		return 1
	elif ! $LTIMEZONE; then
		alerta "TIMEZONE" "${cmsg_NotConfTimezone}"
		DEFITEM="Timezone"
		return 1
	elif ! $LWM; then
		alerta "WM" "${cmsg_NotConfWm}"
		DEFITEM="Wm"
		return 1
		#	elif [ -z "$LWIFI" ]; then
		#		alerta "WIFI" "${cmsg_NotConfWifi}"
		#		DEFITEM="Wifi"
		#		return 1
	elif ! $LEXTRA; then
		alerta "EXTRA" "${RED}${cmsg_NotConfExtra}${RESET}"
		DEFITEM="${cmsg_Usuario}"
		return 1
	fi

	display_config
	if conf "${cmsg_ConfSalva^^}" "$SETUP " \
		"${RESET}\n${cmsg_AcompanheInstalacao} : ${BLUE}sudo tail -f $BOOTLOG${RESET}" \
		"\n${cmsg_OuPeloTerminal}                : ${BLUE}(ctrl+alt+f8)${RESET}" \
		"\n\n${BOLD}${WHITE}${cmsg_descInstalar}?"; then
		clear
		return 0
	fi
	return 1
}

sh_grubInstall() {
	local xuuidfde

	#	echo "GRUB_THEME=/boot/grub/themes/void/theme.txt" >>"$dir_install/etc/default/grub"
	echo "GRUB_THEME=/boot/grub/themes/chili/theme.txt" >>"$dir_install/etc/default/grub"
	if $LOSPROBER; then
		echo "GRUB_DISABLE_OS_PROBER=false" >>"$dir_install/etc/default/grub"
	else
		echo "GRUB_DISABLE_OS_PROBER=true" >>"$dir_install/etc/default/grub"
	fi

	if $LFDE; then
		sh_chroot_job "Alterando /etc/default/grub" "sed -i 's/^GRUB_CMDLINE_LINUX_DEFAULT=/#&/' /etc/default/grub"
		xuuidfde=$(blkid -o value -s UUID "${AConfFde[partition]}")
		{
			echo "GRUB_CMDLINE_LINUX_DEFAULT='splash quiet udev.log_priority=3 libata.noacpi=1 loglevel=4 rd.luks.allow-discards rd.lvm.vg=${AConfFde[vg]} rd.luks.uuid=$xuuidfde'"
			echo "GRUB_ENABLE_CRYPTODISK=y"
		} >>"$dir_install/etc/default/grub"

		sh_chroot_job "Criando chave aleatória" "dd bs=1 count=64 if=/dev/urandom of=/boot/volume.key"
		sh_chroot_job "Adicionando a chave ao volume cryptografado" "printf ${AConfFde[passphrase]} | cryptsetup luksAddKey ${AConfFde[partition]} /boot/volume.key --key-file=-"
		sh_chroot_job "Alterando permissões para proteger a chave" "chmod 000 /boot/volume.key; chmod -R g-rwx,o-rwx /boot"
		echo "${AConfFde[vg]}	UUID=$xuuidfde	/boot/volume.key	luks" >>"$dir_install/etc/crypttab"
		echo 'install_items+=" /boot/volume.key /etc/crypttab "' >>"$dir_install/etc/dracut.conf.d/10-crypt.conf"
	fi

	if $LBIOS; then
		sh_chroot_job "${cmsg_Instalando} GRUB i386-pc ${cmsg_Em} ${AConfDisk[_BOOTLOADER]}" \
			"grub-install ${AConfDisk[_BOOTLOADER]} --target=i386-pc"
	fi
	if $LEFI; then
		# --removable   = garante boot universal via Fallback
		# --no-nvram    = não mexe na BIOS
		sh_chroot_job "${cmsg_Instalando} GRUB EFI ${cmsg_Em} ${AConfDisk[_BOOTLOADER]}" \
			"grub-install ${AConfDisk[_BOOTLOADER]} --target=$TARGET_EFI --efi-directory=/boot/efi --boot-directory=/boot --bootloader-id=$cnickefi --removable --no-nvram"
		#		sh_mkefiroaming
	fi
	if ! $LVM; then
		sh_chroot_job "${cmsg_Gerando} grub.cfg ${cmsg_Em} $dir_install" "grub-mkconfig -o /boot/grub/grub.cfg"
	fi
}

confmulti() {
	xtitle="$1"
	shift
	${DIALOG} \
		--colors \
		--title "$xtitle" \
		--backtitle "$ccabec" \
		--yes-label "${cmsg_yeslabel}" \
		--no-label "${cmsg_nolabel}" \
		--yesno "$*" \
		10 60
	nchoice=$?
	return $nchoice
}

sh_cp_rootfs() {
	local lretval

	sh_info_msg "${cmsg_Descompactando} ISO ${cmsg_Em} $dir_install"
	sh_execcopia
	lretval="$?"
	evaluate_retval "$lretval"

	clear
	rm -f $dir_install/etc/issue
	rm -f $dir_install/etc/motd
	return "$lretval"
}

sh_touch_keys() {
	sh_cmd_job "Criando chaves ${cmsg_Em} $dir_install" "mkdir -p keys" $err_not_fatal

	cat >keys/60:ae:0c:d6:f0:95:17:80:bc:93:46:7a:89:af:a3:2d.plist <<-EOF
		<?xml version="1.0" encoding="UTF-8"?>
		<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
		<plist version="1.0">
		<dict>
			<key>public-key</key>
			<data>LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlJQ0lqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FnOEFNSUlDQ2dLQ0FnRUF2clN6QlpNdmd2T0NJM0FYYk9qYQoycktSa0pTVE0zYy9FalRJZ0NnRFhndW05M0JQQ3RZOE1jRlZvQ1U0T2lYSEdmVG1xMzlCVk5wTHZMSEw5S2sxCnAyNzhTQmhYVk90YkIyRVZtREtudmZJREVUbGRMR3plN3JaTlJKZHR1TjJtWi9UVnJVQjlTMHlRYytJdWY0aHYKMytEOTdWSWRUSkhBN0FTcjA0MjhwcEVHSkd3U1NoWTJYSm05RDVJMEV1R1JXYzE0TUVHN2RJS0ppWWlNMG5FNAp0WW8yL3ZINElGVEhkblZBM2dZaVp5RG5idUNBUi84RVNmVVRVMTNTTkNPZGJ1ZGYzRDVCY3krVWlNREpJM1llCjRNRktCclQ5WmhaK0dzWEJaWTQ4MmxxaVppNkNMNXB0YzlJUUZmOC9lS1phOGphdGtpVkZWZ3JLZU5Sak9UeE4KZldTdTJua3hHTlgrYmhYWXRoaUdXbUpFWThjQ0FQeUZOK0x2NVJldEsyNTZnZGNiMnNrbUVxZWZ2MnpQQyt3VgpXQmJkSDViRDRiWmpuME42Wmw4MXJ2NVJ6RHZudmYrdkQxNGFGVWJaOFFGcXU3NVBiTDR3Nm1ZTTRsZE0vZzBSCjZOWEU4QXo5Qnd4MnREZlllS3V1dHcxRXBQbTJZdkZ5VFViMWNveUF1VEdSeUFhcDFVVEh2ZzlsaFBJSm1oRlEKSjVrQ2cxcUQ3QTMxV2wwUmxuZTZoZ0dvMFpaTko1Y0pNL3YvelNUS0pjdUZnd283SDBoT0dpbDZEZm84OUI0agpHOTZBQ3lQUytEVktQRlhSWXdqL0FrYkhwYVEyZjFGTUFvU3BCcXVEcUhoM3VrazcxS1g2ajE5dDBpRjhEUUxyCnZ0RlNTZElqREEwMmx3ZVY5TmFRcFdzQ0F3RUFBUT09Ci0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLQo=</data>
			<key>public-key-size</key>
			<integer>4096</integer>
			<key>signature-by</key>
			<string>Void Linux</string>
		</dict>
		</plist>
	EOF

	cat >keys/76:75:c9:75:f1:97:35:78:3c:f9:73:d4:f6:04:0b:59.plist <<-EOF
		<?xml version="1.0" encoding="UTF-8"?>
		<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
		<plist version="1.0">
		<dict>
			<key>public-key</key>
			<data>LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlJQm9qQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FZOEFNSUlCaWdLQ0FZRUFxRlJBUnpFeVJMMlVJdU1GWkMwOApmSURJUWZrUzVNczRxOXFLUFhQdHMyN01mbDdDNFdoSHZYb2h2MnNKSzV1SThlOXM3OEJUL0gvbTJxallMWjZJCnF1NmNrZFJUZzNpakNYbTFqY21wRGh1eVpqVW5xaUdPcnBjZUpaTEtUZEYxQWRvZTI4NGRTTW92ZUZldVdlMkIKbkI1aml1ZGg4Szg2WThPdXptbldTN29PTWgzK3dMMEQrNHlGRVRrTTF0ckZCUC9GOUprZEx2dHVONWwyUmVJUQpYa0I5NHpIQ3l5dXkyUC9USnlQOFphSG0vckRwV2JJbUZLMzhsa05IcEczS1ZWYnl5bnFkZyszenJnTHNlR0ZXCnBnelFSdTdON3ByRGIvbDVQV3JSQ0tEUDJyWCtKZHFyWXBrUXh6SDNvTnpkZTd2cGFqejU2c2tzaDhUaHBIY2MKU2g3eTN2ZEJ3dHpDZFlqMkd0RlJaRzB4S21TY24rQ0hLR3dGQTdwdkkzVlVISXNLMm9IazlkSWlwZjkxbFMxVQp4ZUo5Y3RlQmdYZFJ0S0E3QXVTVTN0VzFRak1pNGJrWWVxZ1NUTFJueUxtbVYvR2MyT3BEMktOQVpuWnBIM2RrCnNtV25ibC9rZ05qa2NLTVQ2Rm5hSjdYNlJNdHZ4Mi9CWlcwMy9jQ25nRTR6QWdNQkFBRT0KLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tCg==</data>
			<key>public-key-size</key>
			<integer>3072</integer>
			<key>signature-by</key>
			<string>Vilmar Catafesta &lt;vcatafesta@gmail.com&gt;</string>
		</dict>
		</plist>
	EOF

	cat >keys/cc:e6:28:46:ff:19:07:a2:f0:4b:14:15:4f:89:1b:bc.plist <<-EOF
		<?xml version="1.0" encoding="UTF-8"?>
		<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
		<plist version="1.0">
		<dict>
			<key>public-key</key>
			<data>LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlJQm9qQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FZOEFNSUlCaWdLQ0FZRUEzcXVPbTNUNnc4RXN1ZnY2cnJIZwp6VTQ0S090dXF1M01HMS81Smd2UmJvb1hzS0swdW8wQkpzOFJaY2RLOWZRRWFNbUtHRUxvQVBiVEVQaGlZc0EzCnNkNy95QUR4bFNVcWR2VUl6Unh3M3E1VXFHNjQ5aFJjNnVHMjdxS2pZL0pxSXF5bGV5bmlaNUR0ejI5cm5Mc2wKTUFyT0YrNElsUk5LMnFHMy85RytETmVsVXFDeFRHQTVUd21DUlN5OXRQZ2dPQ3RnYmRuZjdCbHg4anB4MHo4MAo2RHl2ZDhPZ0ZRWEE4R3l5K2Mzc1N3Tm02Y1ZVUTV2clEzcGhCTnVuSzJDbHJzeE5iRGhzQnNXSklGd1JEeFJnCnpYQlJrSmxxL2M1L0crZTV2d0p1TWl6M09WYlh6TWo4WCtNYk5wMExkVzFVRU5tbmRYU1h3aForUllDQTRNMCsKSm1ZV0VRY0xKdnBIelB5cUZnaVhucnFMOUU0Tm4xK2t3TXZYOWEvTVhQcCtjRk12ajBUd01icWRDTTFGeGl2aQpUNkpCbUxOZG0vOXpQbUs5Yzg2UHRGVWNaaCtaV0NRMHBjTmRSWm5NZzJxVmdHUUdkeXFNQVN4QldpeVZrSHdHClkzSUcwZ3VaeVNJVnZmU0cyc0ZsQmZDWk9yK0pqNHNEbWhITXlNdlpoZGdGQWdNQkFBRT0KLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tCg==</data>
			<key>public-key-size</key>
			<integer>3072</integer>
			<key>signature-by</key>
			<string>Vilmar Catafesta &lt;vcatafesta@gmail.com&gt;</string>
		</dict>
		</plist>
	EOF

	cat >keys/3d:b9:c0:50:41:a7:68:4c:2e:2c:a9:a2:5a:04:b7:3f.plist <<-EOF
		<?xml version="1.0" encoding="UTF-8"?>
		<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
		<plist version="1.0">
		<dict>
			<key>public-key</key>
			<data>LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlJQ0lqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FnOEFNSUlDQ2dLQ0FnRUFvM1Nrc2p5N01PMmc4UWxsZjdCVQp1aXhFUWlqN3FOSVJrU0hrWWw4SGxxd1hOczFnK1FzbzhGV3dSbDNMbUpTVW5wT1BaOG1sdVdSajd4Y2pLbnVJCnhPRjBtQS8vM0lzTnVId2dYV2RLL0JiT29wNzFLZmt4aEE0WjhwK0hRbmhLMThxUkFPbG9xOGJ6WXZhaGI2NmEKemdWVTVFM1JzRDU4V0M2ZTFOUVdSSGpiMG1TM2h6M1NxVWVWZFVMT20zVzZBRTdYdWlVQVJOSEdyY1ljMXkyKwpxNjBKWHMrVk5sRlMwaGdDdnpqS3phMVg5cWtzQndzTmdaRlhBcXN1MGFKRndYSTEvM2R4ZWxBcUZFbnRMWVFSCjA4NHpaTDFmWDVRMWlacGNEaHVhTWZVREVZQjA4UzdKTTBYKytibkxxVnphVTZzc0RXdGtzbFJaNjNaVStISTUKemk5a0pyc25LcU5Pa3BKSnJTUkRyMGFvRjV2RDRwN20vYWdZKzdTRk5aaDZzOUJ5V0x3NDVFdytwalVVUmp5aQp6T01TSFhEM3YzczhFdzZkV29wbTVQTGUvUEgzZWFiMEVnbG9yVDZhYmRwaCtaVG4zaUxMWVVkSGNmQ1FDN01GCkNmVGl1TWt4SkJpaCtoOEhKaUlBdmpDZjVxdjZiaFpEUHpGRzAwbEpYRUZwNHRpbGp6eTFmbitiMkdLY3BDOWQKUUs4TEc3M0RFaXhacHBmU09IU09MMWYxVlBzZTBRdnl6d2RWc0xzR0dqV0FaZkw4WUdVZDl4Y20yeW5tVzFuNgpKTjl6NE9oZ3lRa21mNUFFUXpYSUxQR0d1MlREUVh5c05IRG0vUnRMMHJPN3cxbFVKSTVYOW1kbEZYd0xUWHI3ClYrU25aK3U5VCtFREg1NTV6WDJDZTgwQ0F3RUFBUT09Ci0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLQo=</data>
			<key>public-key-size</key>
			<integer>4096</integer>
			<key>signature-by</key>
			<string>Void Linux</string>
		</dict>
		</plist>
	EOF

	cat >keys/7d:45:a3:eb:2a:0d:e7:14:e6:66:65:ce:27:4a:ac:e2.plist <<-EOF
		<?xml version="1.0" encoding="UTF-8"?>
		<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
		<plist version="1.0">
		<dict>
			<key>public-key</key>
			<data>LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlJQ0lqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FnOEFNSUlDQ2dLQ0FnRUFrNFFMWk9vQjI3NndLS1RFaTJDZQpGZnZpY1R4aGttWmVYaGk3WUJWTnZVMzZPeCt5VXZKNndZQ1VJZFNMMUdNdGNRN0dsM2tqOG94RjJRZXVJMisrCjk2SzF4K09WTnlnWXU2cVdZNkZuTEZHVHR2Q3FZK2crd2Fyb29oZFd1OU94RUl1ZVJrUzJndmtieFFYZm55Y2QKa1RSU1o4VzBSdFVXbE5XT3pDdHZ1ZzZMMUFadGlMc1FpblFlZndLb0hZVnJhZlFMS0h2aVI2Z2poaStZOFZwVwpxUFlncU4vU1FSZWhxQkRKNXJuTFpkbDczTTlOSTlPazJaOEZ6NXdFQU45dXNKa2lSRm1zVlRZOXF4dE9yQmc5Cmp6ZC9MaFBDY0VPWnFPSG05K1d4WXFJZzFNQkppRStLL0VEVjhENlBrN0lzZW93Y2FmaW9VSU9NRk5NNUZNV3IKSThlNDFtYVAxVjZ5VlZYM0dVRHlnNlA2bUNYQnNSQU4wOHovQ0RkUVlWakN1ZFhiNWtZK2dJMDhkK0JnTXZlYQpHcFZLMlBrT0tEZ1NmRTlrVDYzbTZYRGg4TnkrNGtDaHBaemR3YnZCTm1CRGQzazR2VVoxSWgwWVF0VEdXTlhGCjZjRTZtV3FpSE10SC9iaUNxYkVDSXR4S2RVdlkyMGxsRE5aaUJGeWNESGpSNTBjeFJjdkEvRW9XdlNlNm9ZT0EKeklnRjNXZDZnOHo3VWJxSE9Rc1FHd2NER3VjV1Q3SlAxN2VTQnYvYkt5N0xVUG9ONnZhOWNjSHhNdjJ5c0YxMQpiSFQxWUk0alpYa2d3OXZIUDdZcm9yN0xyYjIraWFxTWFXR1ZBZWlCY3I0amJnSmxGM3BUU2ljaFF4QjVkUEhJCkoxSGYzYmMwY2ZmRGpKMkoybGRpMk1jQ0F3RUFBUT09Ci0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLQo=</data>
			<key>public-key-size</key>
			<integer>4096</integer>
			<key>signature-by</key>
			<string/>
		</dict>
		</plist>
	EOF

}

#dom 03 mar 2024 09:35:25 -04
sh_copy_keys() {
	local destdirkeys="$dir_install/var/db/xbps/keys"

	sh_touch_keys
	sh_cmd_job "Criando diretorio de chaves em $destdirkeys" "mkdir -p $destdirkeys" $err_not_fatal
	sh_cmd_job "Copiando chaves da ISO para $destdirkeys" "cp -f /var/db/xbps/keys/*.plist $destdirkeys/" $err_not_fatal
	sh_cmd_job "Copiando chaves locais para $destdirkeys" "cp -f keys/*.plist $destdirkeys/" $err_not_fatal
}

sh_install_prereqs() {
	#	REQUIRED_PKGS="base-files xbps libgcc dash coreutils sed tar gawk grub-i386-efi grub-x86_64-efi binutils device-mapper dhclient dracut-network openresolv"
	#	REQUIRED_PKGS="base-container-full xbps libgcc dash coreutils sed tar gawk grub-i386-efi grub-x86_64-efi binutils device-mapper dhclient dracut-network openresolv"
	#	REQUIRED_PKGS="base-voidstrap xbps libgcc dash coreutils sed tar gawk grub-i386-efi grub-x86_64-efi binutils device-mapper dhclient dracut-network openresolv"
	REQUIRED_PKGS="base-voidstrap" # xbps tar xz"

	sh_cmd_job "Instalando bootstrap ${cmsg_Em} $dir_install" \
		"LC_ALL=C xbps-install --rootdir "$dir_install" --repository=${url_mirror}/current -c $CACHEDIR -y $REQUIRED_PKGS -S"
}

#dom 03 mar 2024 09:35:25 -04
sh_extract_root_fs() {
	if [[ "${AConfMirror[_SOURCE]}" = "local" ]]; then
		sh_cp_rootfs
	elif [[ "${AConfMirror[_SOURCE]}" = "network" ]]; then
		sh_tar_rootfs
	elif [[ "${AConfMirror[_SOURCE]}" = "networkFull" ]]; then
		sh_install_prereqs
	fi
}

sh_install_pkgs_in_chroot() {
	local msg="$1"
	local pkgs="$2"

	[[ -n "$pkgs" ]] || return 1

	sh_chroot_job "$msg -> $dir_install" \
		"LC_ALL=C ${XBPS_INSTALL_UNPACK_ONLY} $pkgs" \
		"$err_not_fatal" \
		"$err_not_fatal"
}

sh_update_lxdm_conf() {
	local cfile="$dir_install/etc/lxdm/lxdm.conf"

	cat >"$cfile" <<-EOF
		[base]
		# autologin=dgod
		# timeout=10
		# session=/usr/bin/startlxde
		numlock=1
		# xauth_path=/tmp
		skip_password=1
		greeter=/usr/libexec/lxdm-greeter-gtk

		[server]
		arg=/usr/bin/X -background vt7
		# tcp_listen=1
		# reset=1

		[display]
		gtk_theme=Clearlooks
		bg=/usr/share/backgrounds/chililinux/abstract-art3.jpg
		bottom_pane=1
		lang=1
		# keyboard=1
		theme=vdojo
		transparent_pane=1

		[input]

		[userlist]
		disable=0
		white=
		black=
	EOF
}

sh_update_lxmd_theme() {
	sh_cmd_job "Customizando ${cfile}" "
      sed -i '
        /^theme=Industrial/ {
          s/^/#&/
          a theme=dojo
        }
      ' "$cfile"
   " $err_not_fatal
}

sh_install() {
	local user="${AsUser[cuser]}"
	local start_datetime
	local end_datetime
	local akernel=(linux)
	#        akernel+=(dbus)
	local afirmware=(wifi-firmware)
	local abase=(cryptsetup lvm2 wireless_tools wpa_supplicant)
	#      abase+=(zstd xz)
	local agrub=(grub-i386-efi grub-utils)
	#        agrub+=(grub os-prober grub-x86_64-efi)

	if $LCUSTOM; then
		abase+=(socklog-void chrony)
		agrub+=(grub-terminus grub-btrfs-runit)
	fi

	ncounter=0
	sh_checkInstall || return 1

	#	dialog --title $BOOTLOG --begin 1 0 --tailbox "$BOOTLOG" 20 0 &
	reset
	sh_checkNet "$url_mirror" || return 1
	if [[ "${AConfMirror[_SOURCE]}" = "network" ]]; then
		sh_checkTarball
	fi

	sh_choose_packages

	start_time=$(date +%s) # Obtém o tempo de início em segundos desde a época Unix
	start_datetime=$(date)

	if $LEFI; then
		if sh_getBootEFI; then
			agrub+=(grub-"$TARGET_EFI")
			agrub+=(efivar)
			#			agrub+=(efibootmgr)
		else
			LEFI=false
			LBIOS=true
		fi
	fi

	{
		sh_umount_fs

		if ! sh_make_fs; then
			die "Erro"
		fi

		sh_mount_fs
		sh_mk_working_dir
		sh_copy_keys

		if sh_extract_root_fs; then
			sh_init_bind
			sh_cmd_job "${cmsg_Copiando} /etc/resolv.conf ${cmsg_Em} $dir_install" "cp -f /etc/resolv.conf $dir_install/etc/"
			sh_update_mirror
			#			sh_checkNet "$url_mirror" || return 1

			# Go install
			sh_chroot_job "${cmsg_Atualizando} xbps ${cmsg_Em} $dir_install" "LC_ALL=C xbps-install --sync --update xbps --yes"
			sh_chroot_job "${cmsg_AtualizandoRepositorio} ${cmsg_Em} $dir_install" "LC_ALL=C xbps-install --sync --update --yes"

			if [[ "${AConfMirror[_SOURCE]}" = "local" ]]; then
				sh_install_pkgs_in_chroot "$(gettext 'Atualizando Pacotes Base')" "${agrub[*]}"
			else
				sh_install_pkgs_in_chroot "$(gettext 'Instalando Kernel')" "${akernel[*]}"
				sh_install_pkgs_in_chroot "$(gettext 'Instalando') GRUB" "${agrub[*]}"
				sh_install_pkgs_in_chroot "$(gettext 'Atualizando Pacotes Base')" "${abase[*]}"
				#  			sh_install_pkgs_in_chroot "$(gettext 'Instalando Wifi Firmware')" "${afirmware[*]}"
				sh_install_pkgs_in_chroot "$(gettext 'Atualizando Pacotes Adicionais')" "$_PKGS"
				sh_install_pkgs_in_chroot "$(gettext 'Instalando Daemons')" "${aDaemons[*]}"
				sh_install_pkgs_in_chroot "$(gettext 'Instalando Editores texto')" "${aEditorTxt[*]}"
				sh_install_pkgs_in_chroot "$(gettext 'Instalando Downloaders')" "${aDownloader[*]}"
				sh_install_pkgs_in_chroot "$(gettext 'Instalando Utilitário')" "${aUtility[*]}"
				sh_install_pkgs_in_chroot "$(gettext 'Instalando Archiver tty')" "${aArchiverTty[*]}"
				sh_install_pkgs_in_chroot "$(gettext 'Instalando Extras')" "$_EXTRAS"
			fi
			sh_update_bashrc
			sh_grubInstall
			#sh_copy_scripts
			sh_make_fstab
			sh_make_user
			sh_update_hostname
			sh_update_rc_local
			sh_update_sshd
			sh_update_rc_conf
			sh_update_locale

			#			sh_chroot_job "${cmsg_Configurando} locales ${cmsg_Em} $dir_install" "xbps-reconfigure --force glibc-locales"
			sh_update_wpa_suplicant

			LONLY_TTY=false
			if [[ "${#_WINDOWMANAGER[@]}" -eq 1 ]]; then
				if [[ "${_WINDOWMANAGER}" = 'tty' ]]; then
					LONLY_TTY=true
					:
				else
					sh_update_Xkeymap
					sh_X11minimal
				fi
			else
				sh_update_Xkeymap
				sh_X11minimal
			fi

			aDE=()
			for x in "${_WINDOWMANAGER[@]}"; do
				aDE+=("$x")
				case "$x" in
				"tty") : ;;
				"xorg") sh_xorgminimal ;;
				"awesome") sh_awesomeminimal ;;
				"bspwm")
					sh_bspwmminimal
					#					sh_make_bspwm_conf
					;;
				"blackbox") sh_blackboxminimal ;;
				"dwm") sh_dwmminimal ;;
				"enlightenment") sh_enlightenmentminimal ;;
				"fluxbox") sh_fluxboxminimal ;;
				"hyprland") sh_hyprlandminimal ;;
				"openbox") sh_openboxminimal ;;
				"gnome") sh_gnomeminimal ;;
				"plasma") sh_plasmaminimal ;;
				"xfce4") sh_xfce4minimal ;;
				"i3wm") sh_i3minimal ;;
				"sway") sh_swayminimal ;;
				"twm") sh_twmminimal ;;
				"mate") sh_mateminimal ;;
				"lxde") sh_lxdeminimal ;;
				"lxqt") sh_lxqtminimal ;;
				esac
			done

			if [[ "${AConfAudio[_AUDIOSERVER]}" == 'Pipewire' ]]; then
				sh_activating_pipewire
			fi

			sh_activating_services
			sh_chroot_job "Certificando que todos pacotes estejam configurados corretamente em $dir_install" "xbps-reconfigure --force --all"
			#			sh_chroot_job "${cmsg_RemovendoPacotesAntigosObseletos} ${cmsg_Em} $dir_install" "xbps-remove --clean-cache --remove-orphans --yes"
			sh_chroot_job "${cmsg_RemovendoPacotesAntigosObseletos} ${cmsg_Em} $dir_install" "rm -fv /var/cache/xbps/*.xbps"
			sh_chroot_job "${cmsg_RemovendoPacotesAntigosObseletos} ${cmsg_Em} $dir_install" "rm -fv /var/cache/xbps/*.sig*"

			if $HYPRLAND; then
				sh_chroot_job "${cmsg_Instalando} User into group _seatd ${cmsg_Em} $dir_install" "usermod -aG _seatd "$user"}" "$err_not_fatal"
			fi

			sh_update_lxdm_conf
			sh_chmod_tmp
			sh_umount_fs
			end_datetime=$(date)
			alerta "$APP" "${cmsg_FinalizadaComSucesso}\n" \
				"Start Date time  : $start_datetime" \
				"Finish Date Time : $end_datetime" \
				"Time elapsed     : ${RED}$(sh_time_elapsed)"
		else
			die "${cmsg_ERRO} tar #$?. ${cmsg_ErroTar} $_TARBALL_ROOTFS ${cmsg_Em} $dir_install"
		fi
		exit 0
	} # > out & sh_monitor
	#	killall dialog
}

sh_time_elapsed() {
	local end_time=$(date +%s)                # Obtém o tempo de término em segundos desde a época Unix
	local duration=$((end_time - start_time)) # Calcula a duração em segundos
	local hours=$((duration / 3600))
	local minutes=$(((duration % 3600) / 60))
	local seconds=$((duration % 60))

	# Formatar os valores para terem sempre dois dígitos
	hours=$(printf "%02d" $hours)
	minutes=$(printf "%02d" $minutes)
	seconds=$(printf "%02d" $seconds)
	echo "$hours:$minutes:$seconds"
}

sh_monitor_old() {
	${DIALOG} \
		--clear \
		--backtitle "$ccabec" \
		--title "$BOOTLOG" \
		--tailbox $BOOTLOG 20 120
}

sh_monitor() {
	${DIALOG} \
		--clear \
		--colors \
		--title "$BOOTLOG" \
		--begin 10 10 --tailboxbg $BOOTLOG 20 120 \
		--and-widget \
		--begin 3 10 --progressbox "$last_msg" 5 30
}

sh_getLocale() {
	local lc

	LC_DEFAULT="${Alanguage[pt_BR]}"
	LOCALE="pt_BR"

	if lc="${LC_ALL:-${LANG:-${LC_MESSAGES:-en_US.UTF-8}}}"; then
		lc="${lc%%.*}" # remove .UTF-8
		lc="${lc:0:5}" # fica tipo pt_BR
		LOCALE="$lc"
		LC_DEFAULT="${Alanguage[$lc]}"
	fi

}

sh_setMknodTty() {
	if [[ -c "$LOGGER" ]]; then
		return 0
	fi
	mknod -m 0620 /dev/tty8 c 4 8
	chown --reference=/dev/tty0 /dev/tty8
}

sh_seekstrarray() {
	local str=("$1")
	local search="$2"
	local result=

	for i in "${!str[@]}"; do
		if [[ "${str[$i]}" == "$search" ]]; then
			result="$i"
			break
		fi
	done
	echo "$result"
}

sh_splitarray() {
	local str=("$1")
	local pos="$2"
	local sep="${3:-'|'}"
	local array

	[[ $# -eq 3 && "$pos" = "|" && "$sep" =~ ^[0-9]+$ ]] && {
		sep="$2"
		pos="$3"
	}
	[[ $# -eq 2 && "$pos" = "$sep" ]] && {
		sep="$pos"
		pos=1
	}
	[[ $# -eq 1 || ! "$pos" =~ ^[0-9]+$ ]] && { pos=1; }

	IFS="$sep" read -r -a array <<<"$str"
	echo "${array[pos - 1]}"
}

sh_validate_filesystem() {
	local mntpoint
	local fstype
	local rootfound=0
	local homefound=0
	local varfound=0
	local bootfound=0
	local swapfound=0
	local dsk
	local ext=$(sh_getNvme)
	local flag
	local oldfstype

	sh_disk_part_info
	mensagem "$(gettext "=== DISCO/PARTIÇÃO ===")" "\n\n${BOLD}${WHITE}$(gettext "Aguarde... Verificando disco e partições")"

	for i in "${!Amntpoint[@]}"; do
		_PART="$i"
		dsk="${_PART%%[p0-9]*([0-9])}"
		device="${AARRAY_DSK_DEVICES[$dsk]}"
		tran="$(sh_splitarray "${AARRAY_DSK_DEVICES[$dsk]}" 3)"
		partition="$(sh_splitarray "${AARRAY_PART_DEVICES[$_PART]}" 1)"
		oldfstype="$(sh_splitarray "${AARRAY_PART_DEVICES[$_PART]}" 7)"
		flag="$(sh_splitarray "${AARRAY_PART_DEVICES[$_PART]}" 8)"
		mntpoint="$(sh_splitarray "${Amntpoint[$_PART]}" 1)"
		fstype="$(sh_splitarray "${Amntpoint[$_PART]}" 2)"

		if [[ -z "$device" ]]; then
			${DIALOG} --colors --msgbox "${BOLD}${RED}ERROR:${RESET} The disk configured in the file ($app_conf) does not exist in the system!\n\n\
${BOLD}${WHITE}Device : ${RED}$dsk\n" 8 75
			return 1
		fi

		if [[ -z "$partition" ]]; then
			${DIALOG} --colors --msgbox "${BOLD}${RED}ERROR:${RESET} The partition configured in the file ($app_conf) does not exist in the system!\n\n\
${BOLD}${WHITE}Partition : ${RED}$_PART\n" 8 75
			return 1
		fi
	done

	if [[ -z "${AConfDisk[_BOOTLOADER]}" || -z "$LGRUB" ]]; then
		alerta "${cmsg_BootLoader^^}" "${cmsg_NotConfBootLoader}"
		DEFITEM="${cmsg_BootLoader}"
		return 1
	fi

	if [[ -z "${AConfDisk[_DISKTABLE]}" ]]; then
		sh_getBootEFI && AConfDisk[_DISKTABLE]='EFI' || AConfDisk[_DISKTABLE]='GPT_BIOS'
	fi

	sh_getBootEFI && LEFI=true || LEFI=false
	LBIOS=true

	if $LEFI; then
		if [[ "$(sh_splitarray "${AARRAY_DSK_DEVICES[${AConfDisk[_BOOTLOADER]}]}" 7)" != "gpt" ]]; then
			if ! infoconf "${cmsg_Disco}" "$(fdisk -l "${AConfDisk[_BOOTLOADER]}")" \
				"${YELLOW}=== UEFI ===" "\n${BOLD}${RED}NOTICE: ${RESET}\
The system is enabled for UEFI booting, but the chosen bootloader disk has no gpt table.\n\
Redo the partition table in gpt or choose another disk.\n\n\
${BOLD}${WHITE}Continue with installation without UEFI ?"; then
				return 1
			fi
			LEFI=false
		fi
	fi

	if $LEFI; then
		for i in {0..9}; do
			[[ "$(sh_splitarray "${AARRAY_PART_DEVICES[${AConfDisk[_BOOTLOADER]}${ext}${i}]}" 8)" = "BIOS boot" ]] && {
				LBIOS=true
				break
			} || LBIOS=false
		done
		if ! $LBIOS; then # alguns device block em lvm não são detectados pelo lsblk
			[[ -n "$(sh_splitarray "${AARRAY_PART_DEVICES[${AConfDisk[_BOOTLOADER]}${ext}1]}" 8)" ]] && LBIOS=true
		fi
	fi

	for i in "${!Amntpoint[@]}"; do
		_PART="$i"
		dsk="${_PART%%[p0-9]*([0-9])}"
		tran="$(sh_splitarray "${AARRAY_DSK_DEVICES[$dsk]}" 3)"
		oldfstype="$(sh_splitarray "${AARRAY_PART_DEVICES[$_PART]}" 7)"
		flag="$(sh_splitarray "${AARRAY_PART_DEVICES[$_PART]}" 8)"
		mntpoint="$(sh_splitarray "${Amntpoint[$_PART]}" 1)"
		fstype="$(sh_splitarray "${Amntpoint[$_PART]}" 2)"

		if [ "$mntpoint" = "/" ]; then
			((++rootfound))
			_PART_ROOT="$i"
			_ROOT_FSTYPE="$fstype"
		elif [ "$mntpoint" = "/home" ]; then
			((++homefound))
			_PART_HOME="$i"
		elif [ "$mntpoint" = "/var" ]; then
			((++varfound))
			_PART_VAR="$i"
		elif [ "$fstype" = "vfat" -a "$mntpoint" = "/boot/efi" ]; then
			if $LEFI; then
				if [[ "$flag" != "EFI System" ]]; then
					if ! conf "=== UEFI ===" "${BOLD}${RED}ERROR:${RESET} Could not verify selected partition for mountpoint ${BOLD}${BLUE}/boot/efi${RESET}\n\
whether it has the ${RED}'esp'${RESET} flag required for this purpose.\n
However flag of ${RED}'lvm disk'${RESET} partitions are not detected by lsblk.\n\
${RED}Change${RESET} the partition flag or continue install if you are sure it exists.\n\n\
Type disk     : ${BOLD}${WHITE}${tran}${RESET}\n\
Partition     : ${BOLD}${WHITE}${_PART}${RESET}\n\
mntpoint      : ${BOLD}${WHITE}${mntpoint}${RESET}\n\
current flag  : ${BOLD}${WHITE}${flag}${RESET}\n\
flag required : ${BOLD}${WHITE}EFI System${RESET}\n\
oldfstype     : ${BOLD}${WHITE}${oldfstype}${RESET}\n\
newfstype     : ${BOLD}${WHITE}${fstype}\n\n\
Do you wish to continue install ?"; then
						return 1
					fi
				fi
			fi
			if [[ "$dsk" != "${AConfDisk[_BOOTLOADER]}" ]]; then
				${DIALOG} --colors --msgbox "${BOLD}${RED}ERROR:${RESET} The bootloader disk is different from the /boot/efi disk.
Bootloader : ${AConfDisk[_BOOTLOADER]}\n\
/boot/efi  : $dsk" 8 75
				return 1
			fi
			((++bootfound))
			_PART_BOOT="$i"
		elif [ "$fstype" = "swap" ]; then
			((++swapfound))
			_PART_SWAP="$i"
		fi
	done

	LFS=false
	LPARTITION=false
	if [ "$rootfound" -eq 0 ]; then
		${DIALOG} --colors --msgbox "${BOLD}${RED}ERRO:${RESET} o ponto de montagem do sistema de arquivos raiz (/) ainda não foi configurado." 8 75
		return 1
	elif [ $LEFI == "true" -a "$bootfound" -eq 0 ]; then
		info "=== UEFI ===" "\n\
${BOLD}${RED}ERROR:${RESET}\
The EFI system partition has not yet been configured.\n
Create it or define:\n
	- disk table : gpt\n
	- fstype     : FAT32\n
	- size       : minimum 100MB\n
	- mountpoint : /boot/efi\n"
		return 1
	elif [ "$rootfound" -gt 1 ]; then
		${DIALOG} --colors --msgbox "${BOLD}${RED}ERROR:${RESET} the mount point for the root (/) file system was set on more than 1 partition." 8 75
		return 1
	elif [ "$bootfound" -gt 1 ]; then
		${DIALOG} --colors --msgbox "${BOLD}${RED}ERROR:${RESET} the mount point for the boot file system (/boot/efi) has been configured on more than 1 partition." 8 75
		return 1
	elif [ "$homefound" -gt 1 ]; then
		${DIALOG} --colors --msgbox "${BOLD}${RED}ERROR:${RESET} mount point for home (/home) has been configured on more than 1 partition." 8 75
		return 1
	elif [ "$varfound" -gt 1 ]; then
		${DIALOG} --colors --msgbox "${BOLD}${RED}ERROR:${RESET} mount point for var (/var) has been configured on more than 1 partition." 8 75
		return 1
	fi
	LFS=true
	LPARTITION=true
	return 0
}

sh_getyes() {
	local var="$1"

	case "$var" in
	0 | false)
		echo "${cmsg_nolabel}"
		;;
	1 | true)
		echo "${cmsg_yeslabel}"
		;;
	*)
		# fallback defensivo (opcional)
		echo "${cmsg_nolabel}"
		;;
	esac
}

sh_choosePartition() {
	sh_umount_fs
	while true; do
		sh_disk_part_info
		local array=()
		local i
		local nlen=0
		local n=0
		local nc=0
		local result
		local exit_status
		local sep="\xe2\x94\x82"
		local oldfstype=
		local newfstype=
		local fsformat=
		local mntpoint=
		local oldmntpoint=
		local part=
		local -A Aoldfstype=()
		local dsk

		for i in "${ARRAY_PART_DEVICES[@]}"; do
			array[n++]="$i"
			if ((nlen < ${#i})); then
				nlen=${#i}
			fi
			array[n++]=$(
				printf "$sep%-11s$sep%6s$sep%-20s$sep%-20s$sep%-20s$sep%-9s$sep%-6s" \
					"${ARRAY_PART_FSTYPE[$nc]}" \
					"${ARRAY_PART_SIZE[$nc]}" \
					"${ARRAY_PART_LABEL[$nc]}" \
					"${ARRAY_PART_PARTTYPENAME[$nc]}" \
					"$(sh_splitarray "${Amntpoint[$i]}" 1)" \
					"$(sh_splitarray "${Amntpoint[$i]}" 2)" \
					"$(sh_getyes "$(sh_splitarray "${Amntpoint[$i]}" 3)")"
			)
			Aoldfstype+=([$i]="${ARRAY_PART_FSTYPE[$nc]}")
			((nc++))
		done
		((nlen += 6))
		part=$(${DIALOG} \
			--default-item "${AConfDisk[_DEVICE]}" \
			--backtitle "$ccabec" \
			--title "${cmsg_TitleFileSystem}" \
			--ok-label "${cmsg_Mudar}" \
			--cancel-label "${cmsg_ButtonFeito}" \
			--colors \
			--extra-button \
			--extra-label "${cmsg_info_particao}" \
			--menu "${cmsg_MENU}\n\n\
$(printf "%${nlen}s$sep%-11s$sep%6s$sep%-20s$sep%-20s$sep%-20s$sep%-8s$sep%s" \
				"PARTITION" \
				"FSTYPE" \
				"SIZE" \
				"LABEL" \
				"TYPENAME" \
				"MOUNTPOINT" \
				"NEWFSTYPE" \
				"FORMAT?")" \
			24 0 2 "${array[@]}" 2>&1 >/dev/tty)

		exit_status=$?
		#    	dsk="${part%%?(p)+([0-9])}"
		dsk="${part%%[p0-9]*([0-9])}"

		case $exit_status in
		"$D_ESC" | "$D_CANCEL")
			LFS=true
			LPARTITION=true
			return 0
			;;
		3)
			result=$(fdisk -x "$dsk")
			display_result "$result" "${cmsg_part_disk^^}"
			continue
			;;
		esac

		oldfstype="${Aoldfstype[$part]}"
		oldmntpoint="$(sh_splitarray "${Amntpoint[$part]}" 1)"

		if sh_choosefstype "$oldfstype"; then
			newfstype=${AConfDisk[_FILESYSTEM]}
		else
			continue
		fi

		if [[ "$newfstype" != "swap" ]]; then
			if [[ -z "$newfstype" ]]; then
				unset 'Amntpoint["$part"]'
				continue
			fi

			if sh_getBootEFI && [[ "$newfstype" == "vfat" && -z "$oldmntpoint" ]]; then
				oldmntpoint='/boot/efi'
			fi

			if [[ "$newfstype" != "vfat" && -z "$oldmntpoint" ]]; then
				oldmntpoint='/'
			fi
			mntpoint=$(${DIALOG} \
				--colors \
				--title "$xtitle" \
				--backtitle "$ccabec" \
				--inputbox "Please specify the mount point for $part:" 8 75 "$oldmntpoint" 2>&1 >/dev/tty)
			exit_status=$?
			if [[ $exit_status -eq 1 ]]; then
				continue
			elif [[ "$mntpoint" = "/usr" ]]; then
				${DIALOG} \
					--colors \
					--msgbox "${BOLD}${RED}ERROR:${RESET} /usr mount point has been configured but is not supported, please remove it to continue." \
					8 75
				continue
			elif [[ "$mntpoint" = "/" ]]; then
				AConfDisk[_FILESYSTEM]="$newfstype"
			elif [[ -z "$mntpoint" ]]; then
				unset 'Amntpoint["$part"]'
				continue
			fi
		else
			mntpoint="none"
		fi

		${DIALOG} \
			--colors \
			--title "$xtitle" \
			--backtitle "$ccabec" \
			--yes-label "${cmsg_yeslabel}" \
			--no-label "${cmsg_nolabel}" \
			--yesno "Filesystem original : ${BLUE}$oldfstype${RESET}\n
New filesystem      : ${RED}$newfstype${RESET}\n\n
$(gettext "Você deseja criar um novo sistema de arquivos em") $part?" 8 75
		exit_status=$?
		if [ $exit_status -eq 0 ]; then
			fsformat=1
		elif [ $exit_status -eq 1 ]; then
			if [[ "$newfstype" = "swap" ]]; then
				unset 'Amntpoint["$part"]'
				continue
			fi
			fsformat=0
		else
			continue
		fi

		Amntpoint+=(["$part"]="$mntpoint|$newfstype|$fsformat")
		case $newfstype in
		"swap") Amkfs+=(["swap"]="mkswap") ;;
		*)
			Amkfs+=(["$newfstype"]="mkfs.$newfstype")
			LFS=true
			LPARTITION=true
			;;
		esac
		continue
	done
}

sh_chooseperfumery() {
	local -A Aperfumery
	local -A Aflag
	local -a array=()
	local exit_status
	local x

	Aperfumery[bash]=$(gettext "Ativar o bash para o usuario root")
	Aperfumery[bashrc]=$(gettext "Instalar bashrc.sh personalizado")
	Aperfumery[console]=$(gettext "Usar um terminal gráfico para o Carregador de Inicialização (GRUB)")
	Aperfumery[sshd]=$(gettext "Configurar servidor ssh")
	Aperfumery[sudo]=$(gettext "Enable sudo for login user")

	for x in "${!Aperfumery[@]}"; do
		Aflag[$x]='off'
		array+=("$x" "${Aperfumery[$x]}" "${Aflag[$x]}")
	done

	perf=$(${DIALOG} --title "$(gettext "=== PERFUMARIA ===")" \
		--default-item "$_WINDOWMANAGER" \
		--colors \
		--cancel-label "${cmsg_ButtonBack}" \
		--ok-label "${cmsg_Aceitar}" \
		--checklist "${cmsg_MENU}" \
		12 70 0 "${array[@]}" 2>&1 >/dev/tty)

	exit_status=$?
	case $exit_status in
	"$D_ESC" | "$D_CANCEL")
		return
		;;
	esac
	_PERFUMERY=($(strtoarray "$perf"))
	LPERFUMERY=$true
}

sh_toBytes() {
	local ent mut num fra sai

	ent=${1^^}
	[[ ${ent} = "" ]] && ent=0B
	mut=${ent//[^BKMGT]/}
	num=${ent//[^[:digit:]]/}
	ent=${ent//$mut/}
	fra=${ent//[^,.]/}
	fra=${fra:+${ent//*[,.]/}}
	ent=0BKMGT
	ent=${ent//$mut*/}
	#mut=$((${#ent}-1))
	((mut = ${#ent} - 1, sai = num * 1024 ** mut))
	((ent = ${#sai} - ${#fra}))
	echo ${sai:0:$ent}
}

sh_ternario() {
	local retval="$1"
	[[ "$retval" -eq 0 ]] && {
		echo 1
		return 1
	} || {
		echo 0
		return 0
	}
}

sh_menu_language() {
	while true; do
		i18=$(${DIALOG} \
			--stdout --keep-tite --aspect 20 --clear \
			--default-item "$LC_DEFAULT" \
			--backtitle "$ccabec" \
			--clear \
			--title "${welcome}" \
			--ok-label "${cmsg_Aceitar}" \
			--cancel-label "${cmsg_Exit}" \
			--menu "\n${escolhaIdioma}:" \
			0 80 0 \
			0 "$(gettext "Português")" \
			1 "$(gettext "Inglês")" \
			2 "$(gettext "Alemão")" \
			3 "$(gettext "Francês")" \
			4 "$(gettext "Espanhol")" \
			5 "$(gettext "Italiano")")

		exit_status=$?
		case $exit_status in
		"$D_ESC" | "$D_CANCEL")
			exit 0
			;;
		esac
		LC_DEFAULT="$i18"
		LOCALE="${Alocale[$i18]}"
		#		sh_init "$@"
		break
	done
}

sh_voidServices() {
	if [[ -n $(command -v void-services) || -n $(command -v ./void-services) ]]; then
		bash void-services "$LC_DEFAULT" "-g"
		return 0
	fi

	msg "INFO" "$(log_info_msg "$(gettext "Aguarde...") ${cmsg_Gerando} test with void-mirror ${xurl}")"
	evaluate_retval "1" "$err_not_fatal"
	info "=== ${cmsg_Servicosr^^} === void-services" \
		"\n${RED}void-services $(gettext "não foi localizado no") \$PATH${RESET}" \
		"${RED}void-services $(gettext "não foi localizado em") $PWD!${RESET}"
	return 1
}

sh_getparamfile() {
	if ((LFILE)); then
		echo "- ${BOLD}${WHITE}[$app_conf]"
		return 0
	fi
	return 1
}

sh_main_menu() {
	sh_disk_part_info
	while true; do
		sh_touchConf
		if [ -z "$DEFITEM" ]; then
			DEFITEM="${cmsg_Mirror}"
		fi

		$LMIRROR && MENU_MIRROR="${YELLOW}[${AConfMirror[_MIRROR]}]${RST} ● " || MENU_MIRROR="${RED}[not defined]${RST} ● "
		$LSOURCE && MENU_SOURCE="${YELLOW}[${AConfMirror[_SOURCE]}]${RST} ● " || MENU_SOURCE="${RED}[not defined]${RST} ● "
		$LDISK && MENU_DEVICE="${YELLOW}[${AConfDisk[_DEVICE]}]${RST} ● " || MENU_DEVICE="${RED}[not defined]${RST} ● "
		$LGRUB && MENU_BOOTLOADER="${YELLOW}[${AConfDisk[_BOOTLOADER]}]${RST} ● " || MENU_BOOTLOADER="${RED}[not defined]${RST} ● "
		$LMKPARTED && MENU_FS="${YELLOW}[OK => revise! ]${RST} ● " || MENU_FS="${RED}[not defined]${RST} ● "
		$LKEYMAP && MENU_KEYMAP="${YELLOW}[${AConfLocale[_KEYMAP]}]${RST} ● " || MENU_KEYMAP="${RED}[not defined]${RST} ● "
		$LTIMEZONE && MENU_TIMEZONE="${YELLOW}[${AConfLocale[_TIMEZONE]}${RST} ● " || MENU_TIMEZONE="${RED}[not defined]${RST} ● "
		$LLOCALE && MENU_LOCALE="${YELLOW}[${AConfLocale[_LOCALE]} ${AConfLocale[_REGION]}]${RST} ● " || MENU_LOCALE="${RED}[not defined]${RST} ● "
		$LAUDIO && MENU_AUDIO="${YELLOW}[${AConfAudio[_AUDIOSERVER]}]${RST} ● " || MENU_AUDIO="${RED}[not defined]${RST} ● "
		$LCUSTOM && MENU_CUSTOM="CUSTOM" || MENU_CUSTOM=""
		$LWM && MENU_WM="${YELLOW}[${_WINDOWMANAGER[*]} ${MENU_CUSTOM}]${RST} ● " || MENU_WM="${RED}[not defined]${RST} ● "
		$LEXTRA && MENU_EXTRA="${YELLOW}[OK]${RST} ● " || MENU_EXTRA="${RED}[not defined]${RST} ● "

		menu=$(${DIALOG} \
			--backtitle "$ccabec" \
			--clear \
			--colors \
			--default-item "$DEFITEM" \
			--ok-label "${cmsg_Aceitar}" \
			--cancel-label "${cmsg_Sair}" \
			--extra-button --extra-label "${cmsg_Definicoes}" \
			--title "$APP - ${cmsg_MenuInstalacao} $(sh_getparamfile)" \
			--menu "${RESET}${cmsg_MENU}" \
			26 100 2 \
			"${cmsg_Mirror}" "${MENU_MIRROR}${cmsg_descMirror}" \
			"${cmsg_Source}" "${MENU_SOURCE}${cmsg_DefinirInstalacaoDeOrigem}" \
			"${cmsg_Disco}" "${MENU_DEVICE}${cmsg_descDisco}" \
			"${cmsg_BootLoader}" "${MENU_BOOTLOADER}${cmsg_descBootLoader}" \
			"FileSystem" "${MENU_FS}${cmsg_descFileSystem}" \
			"${cmsg_Teclado}" "${MENU_KEYMAP}${cmsg_descTeclado}" \
			"Timezone" "${MENU_TIMEZONE}${cmsg_descTimezone}" \
			"Locale" "${MENU_LOCALE}${cmsg_descLocale}" \
			"Wm" "${MENU_WM}${cmsg_descWm}" \
			"${cmsg_Usuario}" "${MENU_EXTRA}${cmsg_descExtra}" \
			"Audio" "${MENU_AUDIO}${cmsg_DefinirAudioServer}" \
			"${cmsg_Instalar}" "${cmsg_descInstalar}" \
			'↑↓' '↓↑' \
			"${cmsg_Tema}" "$(gettext 'Seletor de temas do dialog (opcional)')" \
			"${cmsg_Servicos}" "${cmsg_utilvoidservices}" \
			"Clonedisk" "$(gettext 'Utilitário para clonar discos (opcional)')" \
			"Fde" "$(gettext 'Criptografia de disco completo + LVM (opcional)')" \
			"Lvm" "$(gettext 'Gerenciamento de Volume Lógico LVM (opcional)')" \
			"Vg" "Delete/Clear Volume Group (VG) from LVM (optional)" \
			"Wifi" "${cmsg_descWifi}" \
			"${cmsg_Sair}" "${cmsg_descSair}" 2>&1 >/dev/tty)

		if [ $? -eq 3 ]; then
			display_config
			info "${cmsg_ConfSalva^^}" "$SETUP"
			continue
		fi

		case "$menu" in
		"${cmsg_Mirror}") sh_chooseMirror "$@" && [ -n "$LMIRROR" ] && DEFITEM="${cmsg_Source}" ;;
		"${cmsg_Source}") sh_chooseSource && [ -n "$LSOURCE" ] && DEFITEM="${cmsg_Disco}" ;;
		"${cmsg_Disco}") sh_chooseDisk && [ -n "$LDISK" ] && DEFITEM="${cmsg_BootLoader}" ;;
		"${cmsg_BootLoader}") sh_setBootLoader && [ -n "$LGRUB" ] && DEFITEM="FileSystem" ;;
		"FileSystem") sh_choosePartition && [ -n "$LPARTITION" ] && DEFITEM="${cmsg_Teclado}" ;;
		"${cmsg_Teclado}") sh_chooseKeymap && [ -n "$LKEYMAP" ] && DEFITEM="Timezone" ;;
		"Timezone") sh_chooseTimezone && [ -n "$LTIMEZONE" ] && DEFITEM="Wm" ;;
		"Locale") sh_chooseLocale && [ -n "$LTIMEZONE" ] && DEFITEM="Wm" ;;
		"Wm") sh_choosewm && [ -n "$LWM" ] && DEFITEM="Extra" ;;
		"${cmsg_Usuario}") sh_confadduser "$@" && [ -n "$LEXTRA" ] && DEFITEM="Audio" ;;
		"Audio") sh_chooseaudioserver "$@" && [ -n "$LAUDIO" ] && DEFITEM="${cmsg_Instalar}" ;;
		"${cmsg_Instalar}") sh_install ;;
		'↑↓') : ;;
		"${cmsg_Tema}") bash void-dialog-theme-selector ;;
		"${cmsg_Servicos}") sh_voidServices ;;
		"Clonedisk") bash void-clonedisk ;;
		"Fde") sh_confLvm && [ -n "$LFDE" ] && DEFITEM="${cmsg_Instalar}" ;;
		"Lvm") sh_confLvm && [ -n "$LVM" ] && DEFITEM="${cmsg_Instalar}" ;;
		"Vg") sh_chooseVg ;;
		"Wifi") sh_confWifi "$@" && [ -n "$LWIFI" ] && DEFITEM="${cmsg_Instalar}" ;;
		"${cmsg_Sair}") die "${cmsg_InstalacaoAbortada}..." ;;
		*)
			errorbeep
			${DIALOG} --clear \
				--title "$ccabecmin" \
				--colors \
				--yes-label "${cmsg_yeslabel}" \
				--no-label "${cmsg_nolabel}" \
				--yesno "\n${BOLD}${WHITE}${cmsg_SairSemInstalar}?" \
				8 70 && die
			;;
		esac
	done
}

sh_version() {
	cat <<-EOF
		${bold}${cyan}${0##*/} v${_VERSION_}${reset}
		${bold}${black}Copyright (C) 2023 vcatafesta@gmail.com
		$(gettext 'Licença GPL v3+: GNU GPL versão 3 ou posterior') <https://gnu.org/licenses/gpl.html>
		$(gettext 'Este é um software livre: você é livre para alterá-lo e redistribuí-lo.')
		$(gettext 'NÃO HÁ QUALQUER GARANTIA, na máxima extensão permitida em lei.')${reset}
	EOF
}

sh_init() {
	while test $# -gt 0; do
		case $1 in
		-h | -H | --help)
			sh_usage
			exit $(($# ? 0 : 1))
			;;
		-V | --version)
			sh_version
			exit $(($# ? 0 : 1))
			;;
		-f | --file)
			LFILE=$true
			if [[ -n "$2" && "${2:0:1}" != '-' ]]; then
				app_conf="$2"
				shift
			fi
			sh_checkRoot
			sh_loadconf
			;;
		-n | --nocolor)
			log_msg "$(gettext "Desligando saída de cores")"
			sh_unsetVarColors
			;;
		-q | --quiet)
			log_msg "$(gettext "Ativando resumo na saída")"
			quiet=$true
			;;
		-g | --grafico)
			log_msg "$(gettext "Ligando modo gráfico")"
			grafico=$true
			;;
		-i | -I | --install)
			sh_checkRoot
			LINSTALL=true
			appexec+=('sh_main_menu')
			;;
		-c | -C | --chroot)
			sh_checkRoot
			LCHROOT=true
			appexec+=('sh_dryrun')
			;;
		*) die "${cmsg_operNotSupported}: $1 $(gettext 'usar -h para ajuda')" ;;
		esac
		shift
	done
}

sh_getfullusernameloggeduser() {
	local passwd_fields
	IFS=: read -r -a passwd_fields <<<"$(grep -w "$USER" /etc/passwd)"
	echo "${passwd_fields[4]}"
}

function sh_getfullusernameloggeduserbyGetent() {
	local logged_user="${SUDO_USER:-$USER}" # Prioriza SUDO_USER, mas usa USER como fallback
	getent passwd "$logged_user" | cut -d ':' -f 5 | cut -d ',' -f 1
}

sh_getfullusernameloggeduserbyid() {
	local passwd_fields
	IFS=: read -r -a passwd_fields <<<"$(grep -w 1000 /etc/passwd)"
	echo "${passwd_fields[4]%%[,]*}"
}

sh_getusernameloggeduserbyid() {
	local passwd_fields
	IFS=: read -r -a passwd_fields <<<"$(grep -w 1000 /etc/passwd)"
	echo "${passwd_fields[0]}"
}

sh_getdevicefrompartition() {
	local _part="$1"
	echo "${_part%%[p0-9]*([0-9])}"
}

sh_confLvm() {
	local size
	local FdeText
	local arr
	local disk
	local _part
	local dsk
	local oldfstype
	local flag
	local mntpoint
	local fstype
	local i
	local rootfound=0
	local ctitlemenu
	local VGs
	local PVs

	if [[ "$menu" = "Fde" ]]; then
		ctitlemenu='FDE CONFIG'
		LCONFIGFDE=$true
	else
		ctitlemenu='LVM CONFIG'
		LCONFIGFDE=$false
	fi

	if ! $LDISK; then
		alerta "${RED}${REVERSE}$ctitlemenu ${cmsg_TitleDisco}" "${RED}${REVERSE}${cmsg_NotConfDisco^^}"
		DEFITEM="${cmsg_Disco}"
		return 1
	elif ! $LPARTITION; then
		alerta "${RED}${REVERSE}$ctitlemenu $(gettext "=== PARTIÇÃO ===")" "${RED}${REVERSE}${cmsg_NotConfFileSystem^^}"
		DEFITEM="FileSystem"
		return 1
	fi

	sh_disk_part_info
	mensagem "=== VGs ===" "\n\n${BOLD}${WHITE}$(gettext "Aguarde... coletando informações sobre VGs")"
	VGs="$(vgs --noheadings)"
	mensagem "=== PVs ===" "\n\n${BOLD}${WHITE}$(gettext "Aguarde... coletando informações sobre PVs")"
	PVs="$(pvs --noheadings)"
	disk="${AConfDisk[_BOOTLOADER]}|\
$(sh_splitarray "${AARRAY_DSK_DEVICES[${AConfDisk[_BOOTLOADER]}]}" "$DSK_TRAN")|\
$(sh_splitarray "${AARRAY_DSK_DEVICES[${AConfDisk[_BOOTLOADER]}]}" "$DSK_SIZE")|\
$(sh_splitarray "${AARRAY_DSK_DEVICES[${AConfDisk[_BOOTLOADER]}]}" "$DSK_PTTYPE")|\
$(sh_splitarray "${AARRAY_DSK_DEVICES[${AConfDisk[_BOOTLOADER]}]}" "$DSK_MODEL")|\
$(sh_splitarray "${AARRAY_DSK_DEVICES[${AConfDisk[_BOOTLOADER]}]}" "$DSK_LABEL")|\
$(sh_splitarray "${AARRAY_DSK_DEVICES[${AConfDisk[_BOOTLOADER]}]}" "$DSK_SERIAL")"

	for i in "${!Amntpoint[@]}"; do
		_part="$i"
		dsk="${_part%%[p0-9]*([0-9])}"
		size="$(sh_splitarray "${AARRAY_PART_DEVICES[$_part]}" 2)"
		oldfstype="$(sh_splitarray "${AARRAY_PART_DEVICES[$_part]}" 7)"
		flag="$(sh_splitarray "${AARRAY_PART_DEVICES[$_part]}" 8)"
		mntpoint="$(sh_splitarray "${Amntpoint[$_part]}" 1)"
		fstype="$(sh_splitarray "${Amntpoint[$_part]}" 2)"

		if [ "$mntpoint" = "/" ]; then
			AConfFde[partition]="$_part"
			((++rootfound))
			break
		fi
	done

	if [ "$rootfound" -eq 0 ]; then
		${DIALOG} \
			--colors \
			--msgbox "${BOLD}${RED}ERROR:${RESET} $(gettext 'o ponto de montagem para o sistema de arquivos raiz (/) ainda não foi configurado.')" \
			8 75
		return 1
	fi

	while true; do
		exec 3>&1
		FdeText=$(${DIALOG} \
			--title "=== $ctitlemenu ===" \
			--colors \
			--ok-label "${cmsg_Aceitar}" \
			--cancel-label "${cmsg_ButtonBack}" \
			--backtitle "$ccabec" \
			--insecure "$@" \
			--mixedform "${cmsg_MENU}\n\n$(gettext "O tamanho das partições é uma questão de preferência pessoal.")" \
			0 0 0 \
			"Disk: " 1 1 "$disk" 1 42 40 0 2 \
			"Partition: " 2 1 "$_part" 2 42 40 0 2 \
			"Size: " 3 1 "$size" 3 42 40 0 2 \
			"Old FS: " 4 1 "$oldfstype" 4 42 40 0 2 \
			"New FS: " 5 1 "$fstype" 5 42 40 0 2 \
			"Flag: " 6 1 "$flag" 6 42 40 0 2 \
			"Volume Group: " 7 1 "${AConfFde[vg]}" 7 42 25 0 0 \
			"Passphrase: " 8 1 "${AConfFde[passphrase]}" 8 42 20 0 1 \
			"Verify Passphrase: " 9 1 "${AConfFde[verifypassphrase]}" 9 42 20 0 1 \
			"Logical volume (/): " 10 1 "${AConfFde[lvroot]}" 10 42 15 0 0 \
			"Logical volume (/swap) (empty to none): " 11 1 "${AConfFde[lvswap]}" 11 42 15 0 0 \
			"Logical volume (/var)  (empty to none): " 12 1 "${AConfFde[lvvar]}" 12 42 15 0 0 \
			"Logical volume (/home) (empty to none): " 13 1 "${AConfFde[lvhome]}" 13 42 15 0 0 \
			2>&1 1>&3)

		exit_status=$?
		case $exit_status in
		"$D_ESC" | "$D_CANCEL")
			LFDE=false
			LVM=false
			return 1
			;;
		"$D_OK")
			mapfile -t arr <<<"$FdeText"
			AConfFde[vg]="${arr[6]}"
			AConfFde[passphrase]="${arr[7]}"
			AConfFde[verifypassphrase]="${arr[8]}"
			AConfFde[lvroot]="${arr[9]}"
			AConfFde[lvswap]="${arr[10]}"
			AConfFde[lvvar]="${arr[11]}"
			AConfFde[lvhome]="${arr[12]}"
			AConfFde[partition]="$_part"

			lvunitroot="${AConfFde[lvroot]: -1}"
			lvsizeroot="${AConfFde[lvroot]%$lvunitroot}"
			lvunitswap="${AConfFde[lvswap]: -1}"
			lvsizeswap="${AConfFde[lvswap]%$lvunitswap}"
			lvunitvar="${AConfFde[lvvar]: -1}"
			lvsizevar="${AConfFde[lvvar]%$lvunitvar}"
			lvunithome="${AConfFde[lvhome]: -1}"
			lvsizehome="${AConfFde[lvhome]%$lvunithome}"
			maxbytespartition="$(sh_toBytes "$size")"
			byteslvroot="$(sh_toBytes "${AConfFde[lvroot]}")"
			byteslvswap="$(sh_toBytes "${AConfFde[lvswap]}")"
			byteslvvar="$(sh_toBytes "${AConfFde[lvvar]}")"
			byteslvhome="$(sh_toBytes "${AConfFde[lvhome]}")"

			if grep -o -q "$_part " <<<"$PVs"; then
				if ! conf "=== FDE/LVM - $(gettext "Partição") === " \
					"\n$(gettext "Partição") : '$_part'\n$(gettext "Aparentemente,") $(gettext "a partição escolhida já está atribuída como PV no sistema.")\n\n${BOLD}${WHITE}$(gettext "Continuar de qualquer maneira?")\n\n"; then
					LFDE=false
					LVM=false
					continue
				fi
			fi

			if grep -o -q "${AConfFde[vg]} " <<<"$VGs"; then
				if ! conf "=== FDE/LVM - $(gettext "Grupo de Volume") === " \
					"\n$(gettext "Group de Volume") : '${AConfFde[vg]}'\n$(gettext "Aparentemente,") $(gettext "o VG existe no sistema.")\n\n${BOLD}${WHITE}$(gettext "Continuar mesmo assim?")\n\n"; then
					LFDE=false
					LVM=false
					continue
				fi
			fi

			if [[ -z "${AConfFde[vg]}" ]]; then
				if ! conf "=== FDE/LVM - $(gettext "Grupo de Volume") === " \
					"\nVolume Group = '${AConfFde[vg]}'\n$(gettext "O nome do grupo de volumes não pode estar vazio.")\n\n${BOLD}${WHITE}$(gettext "Novamente?")\n\n"; then
					LFDE=false
					LVM=false
					return 1
				fi
				continue
			fi

			if [[ $maxbytespartition -lt $((byteslvroot + byteslvswap + byteslvhome + byteslvvar)) ]]; then
				if ! conf "=== FDE/LVM - $(gettext "Volumes lógicos") === " \
					"\n$(gettext "A soma das partições excede o tamanho total do disco.")\n\n${BOLD}${WHITE}$(gettext "Novamente?")\n\n"; then
					LFDE=false
					LVM=false
					return 1
				fi
				continue
			fi

			if [[ -z "$lvunitroot" || "$lvunitroot" != @(K|M|G|T|%) ]]; then
				if ! conf "=== FDE/LM - $(gettext "Volume lógico raiz") === " \
					"\nThe logical volume root cannot be empty or minuscule in size and/or units out of scope (K|M|G|T|%)\nex: 25% [1-100]% or 10G [1-n](K|M|G|T).\n\n${BOLD}${WHITE}$(gettext "Novamente?")\n\n"; then
					LFDE=false
					LVM=false
					return 1
				fi
				continue
			fi

			if [[ -n "$lvunitswap" && "$lvunitswap" != @(K|M|G|T|%) ]]; then
				if ! conf "=== FDE/LVM - $("Volume lógico") swap === " \
					"\nThe logical volume swap cannot be empty or minuscule in size and/or units out of scope (K|M|G|T|%)\nex: 25% [1-100]% or 10G [1-n](K|M|G|T).\n\n${BOLD}${WHITE}$(gettext "Novamente?")\n\n"; then
					LFDE=false
					LVM=false
					return 1
				fi
				continue
			fi

			if [[ -n "$lvunithome" && "$lvunithome" != @(K|M|G|T|%) ]]; then
				if ! conf "=== FDE/LVM - $("Volume lógico") swap === " \
					"\nThe logical volume swap cannot be empty or minuscule in size and/or units out of scope (K|M|G|T|%)\nex: 25% [1-100]% or 10G [1-n](K|M|G|T).\n\n${BOLD}${WHITE}$(gettext "Novamente?")\n\n"; then
					LFDE=false
					LVM=false
					return 1
				fi
				continue
			fi

			if [[ -n "$lvunitvar" && "$lvunitvar" != @(K|M|G|T|%) ]]; then
				if ! conf "=== FDE/LVM - $("Volume lógico") var === " \
					"\nThe logical volume var cannot be empty or minuscule in size and/or units out of scope (K|M|G|T|%)\nex: 25% [1-100]% or 10G [1-n](K|M|G|T).\n\n${BOLD}${WHITE}$(gettext "Novamente?")\n\n"; then
					LFDE=false
					LVM=false
					return 1
				fi
				continue
			fi

			if [[ -z "${AConfFde[passphrase]}" || "${AConfFde[passphrase]}" != "${AConfFde[verifypassphrase]}" ]]; then
				if ! conf "=== FDE/LVM - $(gettext "Senha") === " \
					"\nPassphrases do not match and also not be empty.\n\n${BOLD}${WHITE}$(gettext "Novamente?")\n\n"; then
					LFDE=false
					LVM=false
					return 1
				fi
				continue
			fi

			AmntpointFDE=()
			AmntpointFDE+=(["/dev/${AConfFde[vg]}/root"]="root|$fstype|1|${AConfFde[lvroot]}|/")
			#					[[ -n "${AConfFde[lvswap]}" && "$(sh_toBytes "${AConfFde[lvswap]}")" -gt 0 ]] &&	AmntpointFDE+=(["/dev/${AConfFde[vg]}/swap"]="swap|swap|1|${AConfFde[lvswap]}|swap")
			#					[[ -n "${AConfFde[lvvar]}"  && "$(sh_toBytes "${AConfFde[lvvar]}")"  -gt 0 ]]	&&	AmntpointFDE+=(["/dev/${AConfFde[vg]}/var"]="var|$fstype|1|${AConfFde[lvvar]}|/var")
			#					[[ -n "${AConfFde[lvhome]}" && "$(sh_toBytes "${AConfFde[lvhome]}")" -gt 0 ]]	&&	AmntpointFDE+=(["/dev/${AConfFde[vg]}/home"]="home|$fstype|1|${AConfFde[lvhome]}|/home")
			[[ -n "${AConfFde[lvswap]}" ]] && AmntpointFDE+=(["/dev/${AConfFde[vg]}/swap"]="swap|swap|1|${AConfFde[lvswap]}|swap")
			[[ -n "${AConfFde[lvvar]}" ]] && AmntpointFDE+=(["/dev/${AConfFde[vg]}/var"]="var|$fstype|1|${AConfFde[lvvar]}|/var")
			[[ -n "${AConfFde[lvhome]}" ]] && AmntpointFDE+=(["/dev/${AConfFde[vg]}/home"]="home|$fstype|1|${AConfFde[lvhome]}|/home")
			;;
		esac
		exec 3>&-
		if ((LCONFIGFDE)); then
			LFDE=true
			LVM=true
		else
			LFDE=false
			LVM=true
		fi
		return 0
	done
}

sh_make_fsFde() {
	local i
	local format
	local fstype
	local _part
	local label

	sh_info_msg "Formatando e cryptografando a unidade : ${AConfFde[partition]}"
	printf "${AConfFde[passphrase]}" | cryptsetup luksFormat --type luks1 "${AConfFde[partition]}" --key-file=- -v 2>&1 | tee -i -a "$BOOTLOG" >"$LOGGER"
	evaluate_retval "${PIPESTATUS[1]}"

	sh_info_msg "Abrindo a unidade cryptografada: ${AConfFde[partition]}"
	printf "${AConfFde[passphrase]}" | cryptsetup luksOpen "${AConfFde[partition]}" "${AConfFde[vg]}" --key-file=- -v 2>&1 | tee -i -a "$BOOTLOG" >"$LOGGER"
	evaluate_retval "${PIPESTATUS[1]}"
}

sh_make_fsLvm() {
	local i
	local _part
	local label
	local fstype
	local format
	local size
	local mntpoint
	local lvunit
	local aLVs=()

	if $LFDE; then
		sh_make_fsFde
	fi

	if $LFDE; then
		:
	else
		sh_info_msg "Criando a unidade fisica LVM: ${AConfFde[vg]}"
		pvcreate -ff "${AConfFde[partition]}" 2>&1 | tee -i -a "$BOOTLOG" >"$LOGGER"
		evaluate_retval "${PIPESTATUS[0]}"
	fi

	sh_info_msg "Criando o grupo de volumes LVM: ${AConfFde[vg]}"
	if $LFDE; then
		vgcreate -ff "${AConfFde[vg]}" "/dev/mapper/${AConfFde[vg]}" 2>&1 | tee -i -a "$BOOTLOG" >"$LOGGER"
	else
		vgcreate -ff "${AConfFde[vg]}" "${AConfFde[partition]}" 2>&1 | tee -i -a "$BOOTLOG" >"$LOGGER"
	fi
	evaluate_retval "${PIPESTATUS[0]}"

	#order required for creation due to issue of 100%
	aLVs=("/dev/${AConfFde[vg]}/root" "/dev/${AConfFde[vg]}/swap" "/dev/${AConfFde[vg]}/var" "/dev/${AConfFde[vg]}/home")
	for i in "${aLVs[@]}"; do
		_part="$i"
		label="$(sh_splitarray "${AmntpointFDE[$i]}" 1)"
		fstype="$(sh_splitarray "${AmntpointFDE[$i]}" 2)"
		format="$(sh_splitarray "${AmntpointFDE[$i]}" 3)"
		size="$(sh_splitarray "${AmntpointFDE[$i]}" 4)"
		mntpoint="$(sh_splitarray "${AmntpointFDE[$i]}" 5)"
		lvunit="${size: -1}"

		[[ -z "$size" ]] && continue

		sh_info_msg "Criando o volume lógico: $label"
		if [[ "$lvunit" = "%" ]]; then
			lvcreate --yes --name "$label" -l "${size}FREE" "${AConfFde[vg]}" 2>&1 | tee -i -a "$BOOTLOG" >"$LOGGER"
		else
			lvcreate --yes --name "$label" -L "${size}" "${AConfFde[vg]}" 2>&1 | tee -i -a "$BOOTLOG" >"$LOGGER"
		fi
		evaluate_retval "${PIPESTATUS[0]}"

		if [[ "$format" = "1" ]]; then
			sh_info_msg "${cmsg_FormatandoParticao} ${_part} FS ${fstype,,}"
			declare -A fsparms=(
				[ext2]="-F   -L $label"
				[ext3]="-F   -L $label"
				[ext4]="-F   -L $label"
				[btrfs]="-f   -L $label"
				[f2fs]="-f   -l $label"
				[xfs]="-f   -L $label"
				[jfs]="-f   -L $label"
				[vfat]="-F32 -n EFI"
				[reiserfs]="-f   -l $label"
			)
			if [[ "$fstype" = "swap" ]]; then
				mkswap "$_part" 2>&1 | tee -i -a "$BOOTLOG" >"$LOGGER"
			else
				mkfs.$fstype ${fsparms[$fstype]} $_part 2>&1 | tee -i -a "$BOOTLOG" >"$LOGGER"
			fi
			evaluate_retval "${PIPESTATUS[0]}"
		fi
	done
	_arch=$(xbps-uhelper arch)
	export XBPS_ARCH=${_arch}
	return 0
}

sh_clearVg() {
	local _vg="$1"
	local alogical=()
	local alogical=("/dev/$_vg/root" "/dev/$_vg/swap" "/dev/$_vg/home" "/dev/$_vg/var")
	local afs=("/dev/mapper/$_vg-root" "/dev/mapper/$_vg-swap" "/dev/mapper/$_vg-home" "/dev/mapper/$_vg-var")
	local i

	sh_umount_fs
	sh_info_msg "$(gettext 'Removendo LVs (Volumes Lógicos')"
	lvremove -ff /dev/"$_vg"/* 2>&1 | tee -i -a "$BOOTLOG" >"$LOGGER"
	evaluate_retval "${PIPESTATUS[0]}" "$err_not_fatal"

	sh_info_msg "$(gettext 'Removendo VG (Volume Group)')"
	vgremove -ff "$_vg" 2>&1 | tee -i -a "$BOOTLOG" >"$LOGGER"
	evaluate_retval "${PIPESTATUS[0]}" "$err_not_fatal"

	sh_info_msg "$(gettext 'Removendo PVs (Volumes Fisícos)')"
	pvremove -ff "${AConfFde[partition]}" 2>&1 | tee -i -a "$BOOTLOG" >"$LOGGER"
	evaluate_retval "${PIPESTATUS[0]}" "$err_not_fatal"
}

sh_chooseVg() {
	local -A Avg
	local -A Aflag
	local array=()
	local defaultitem
	local fields
	local sorted_list
	local exit_status
	local sep="\xe2\x94\x82"

	sh_vg_info
	sorted_list=$(for key in "${!AARRAY_VG_DEVICES[@]}"; do echo "$key|${AARRAY_VG_DEVICES[$key]}"; done | sort -t\| -k2 -k1)

	if [[ ${#sorted_list} -eq 0 ]]; then
		alerta "=== VG ===" "${BOLD}${BLACK}${REVERSE}$(gettext "Info: Nenhum VG localizado no sistema.")"
		return 1
	fi

	defaultitem="${AConfFde[vg]}"
	while IFS='|' LC_ALL=C read -r -a fields; do
		x="${fields[0]}"
		Aflag[$x]='off'
		Aflag[$defaultitem]='on'
		array+=("$x" "$(printf "$sep%-15s$sep%10s$sep%10s$sep%-s" \
			"${fields[1]}" \
			"${fields[2]}" \
			"${fields[3]}" \
			"${fields[4]}")"
		"${Aflag[$x]}")
	done <<<"${sorted_list[@]}"

	vg=$(${DIALOG} --title "=== VG ===" \
		--colors \
		--cancel-label "${cmsg_ButtonBack}" \
		--ok-label "${cmsg_Aceitar}" \
		--radiolist "${cmsg_MENU}" \
		25 70 24 "${array[@]}" 2>&1 >/dev/tty)

	exit_status=$?
	case $exit_status in
	"$D_ESC" | "$D_CANCEL")
		return
		;;
	esac
	if ! infoconf "=== VG === " "$(lvs --noheadings "$vg")" \
		" === VG ===" "${BOLD}${RED}$(gettext 'AVISO'):${RESET} $(gettext "É importante lembrar que remover um VG")\
$(gettext "é uma operação irreversível e pode resultar em perda de dados.")\n
$(gettext "Certifique-se de fazer backup de seus dados.")\n
$(gettext "Todos os dados do disco serão apagados!")\n\n\
${BOLD}${WHITE}$(gettext "Deseja continuar?")"; then
		return 1
	fi
	sh_clearVg "$vg"
}

sh_setLanguage() {
	#	langmsg=('lang=("pt_BR"	"en_US" "de_DE" "fr_FR" "es_ES" "it_IT")')
	#	for xmsg in "${langmsg[@]}"; do eval "$xmsg"; done
	#	#echo "lang       ${#lang[@]} ${lang[@]} ${lang[$PT_BR]} ${lang[$EN_US]}"
	#	#echo "cmsg_ERRO ${#cmsg_ERRO[@]} ${cmsg_ERRO[@]} ${cmsg_ERRO[$PT_BR]} ${cmsg_ERRO[$EN_US]}"

	#	cmsg_LABEL[pt_BR]=$(gettext "Usar as teclas ${RED}↑ PARA CIMA ${RESET}e ${RED}↓ PARA BAIXO ${RESET}para navegar.\nUsar ${RED}TAB ${RESET}para alternar entre os botões e ${RED}ENTER ${RESET}para selecionar.")
	#	cmsg_LBL_check[pt_BR]=$(gettext "Usar as teclas ${RED}PARA CIMA ${RESET}e ${RED}PARA BAIXO ${RESET}para navegar.\nUsar ${RED}BARRA DE ESPAÇO ${RESET}para selecionar.\nUsar ${RED}TAB ${RESET}para alternar entre os botões e ${RED}ENTER ${RESET}para aceitar.")
	#	cmsg_Tarball_Corrompido[pt_BR]=$(gettext "\n${RED}Aparentemente o tarball rootfs ${_TARBALL_ROOTFS} está corrompido.\n\n${BOLD}${WHITE}Testar a integridade e reiniciar a instalação ?")

	#	cmsg_LABEL1=$(gettext "Usar as setas ${CYAN}↑ ${RST}e ${CYAN}↓ ${RST}para navegar.")
	#	cmsg_LABEL2=$(gettext "Usar ${CYAN}TAB ${RST}para alternar entre os botões.")
	#	cmsg_LABEL3=$(gettext "Usar ${CYAN}ENTER ${RST}ou ${CYAN}BARRA DE ESPAÇO ${RST}para selecionar e aceitar.")
	cmsg_LABEL1=$(gettext "Usar as setas ↑ e ↓ para navegar.")
	cmsg_LABEL2=$(gettext "Usar TAB para alternar entre os botões.")
	cmsg_LABEL3=$(gettext "Usar ENTER ou BARRA DE ESPAÇO para selecionar e aceitar.")
	cmsg_MENU="${cmsg_LABEL1}\n${cmsg_LABEL2}\n${cmsg_LABEL3}"

	cmsg_Tarball_Corrompido0=$(gettext "Aparentemente o tarball rootfs")
	cmsg_Tarball_Corrompido1=$(gettext "está corrompido.")
	cmsg_Tarball_Corrompido2=$(gettext "Testar a integridade e reiniciar a instalação ?")
	cmsg_Tarball_Corrompido="\n${RED}${cmsg_Tarball_Corrompido0} ${_TARBALL_ROOTFS} ${cmsg_Tarball_Corrompido1}\n\n${BOLD}${WHITE}${cmsg_Tarball_Corrompido2}"

	cmsg_TamanhoInsuficiente=$(gettext "Tamanho disco insuficiente para criar partições com swap")
	cmsg_DesejaProsseguir=$(gettext "Deseja prosseguir SEM partição de swap?")
	cmsg_DesejaCriarParticaoSwap=$(gettext "Deseja criar partição de swap ?")
	cmsg_AcompanheInstalacao=$(gettext "Acompanhe a evolução da instalação            ")
	cmsg_OuPeloTerminal=$(gettext "e/ou pelo terminal tty8        ")
	cmsg_PacotesDaImagemIso=$(gettext "Utilizar os pacotes da imagem ISO")
	cmsg_BaixadoDoRepositorioOficial=$(gettext "Utilizar tarball base e atualizar pela internet (qualquer host Linux)")
	cmsg_BaixadoDoRepositorioOficialFull=$(gettext "Baixar todos os pacotes da internet (requer host Void Linux)")
	cmsg_DefinirInstalacaoDeOrigem=$(gettext "Definir fonte da instalação")
	cmsg_Definicoes=$(gettext "Definições")
	cmsg_naodefinido=$(gettext "não definido")
	cmsg_AjustandoSenhaUsuario=$(gettext "Ajustando senha usuário")
	cmsg_AtivandoBashUsuario=$(gettext "Ativando o bash para o usuário")
	cmsg_CriandoUsuario=$(gettext "Criando usuário")
	cmsg_MenuInstalacao=$(gettext "MENU DE INSTALAÇÃO")
	cmsg_DesMontandoAmbiente=$(gettext "Desmontando ambiente")
	cmsg_MontandoAmbiente=$(gettext "Montando ambiente")
	cmsg_EntrandoAmbienteChroot=$(gettext "Entrando no ambiente chroot")
	cmsg_MontandoParticao=$(gettext "Montando partição")
	cmsg_Gerando=$(gettext "Gerando")
	cmsg_Ajustando=$(gettext "Ajustando")
	cmsg_Copiando=$(gettext "Copiando")
	cmsg_Descompactando=$(gettext "Descompactando")
	cmsg_Atualizando=$(gettext "Atualizando")
	cmsg_Instalando=$(gettext "Instalando")
	cmsg_Configurando=$(gettext "Configurando")
	cmsg_Em="${cyan}=>${reset}"
	cmsg_ERRO=$(gettext "ERRO")
	cmsg_Aceitar=$(gettext "Aceitar")
	cmsg_Configurar=$(gettext "Configurar")
	cmsg_Particionar=$(gettext "Particionar")
	cmsg_Mudar=$(gettext "Mudar")
	cmsg_Sair=$(gettext "Sair")
	cmsg_Instalar=$(gettext "Instalar")
	cmsg_Mirror=$(gettext "Espelho")
	cmsg_BootLoader=$(gettext "Bootloader (GRUB)")
	cmsg_FileSystem=$(gettext "Sistema de Arquivos")
	cmsg_Disco=$(gettext "Disco")
	cmsg_Teclado=$(gettext "Teclado")
	cmsg_SairSemInstalar=$(gettext "Sair sem instalar")
	cmsg_tty=$(gettext "Somente terminal, sem interface gráfica")
	cmsg_descDisco=$(gettext "Definir disco e partições")
	cmsg_descFileSystem=$(gettext "Definir sistema de arquivos e pontos de montagem")
	cmsg_descBootLoader=$(gettext "Definir bootloader")
	cmsg_descTeclado=$(gettext "Definir teclado do sistema")
	cmsg_descTimezone=$(gettext "Definir fuso horário")
	cmsg_descLocale=$(gettext "Definir localidade do sistema")
	cmsg_descWm=$(gettext "Definir gerenciador de janelas")
	cmsg_descWifi=$(gettext "Definir rede e senha wifi (opcional)")
	cmsg_opcional=$(gettext "opcional")
	cmsg_Usuario=$(gettext "Usuário")
	cmsg_descExtra=$(gettext "Definir usuário,senha,hostname")
	cmsg_descMirror=$(gettext "Escolher espelho")
	cmsg_descInstalar=$(gettext "Iniciar instalação")
	cmsg_descSair=$(gettext "Encerrar instalação")
	cmsg_InstalacaoAbortada=$(gettext "Instalação abortada")
	cmsg_ChecandoRota=$(gettext "Checando rota de internet para o servidor")
	cmsg_falhaAbertura=$(gettext "ERRO: falha de abertura de")
	cmsg_operNotRoot=$(gettext "erro: você não pode realizar esta operação a menos que seja root.")
	cmsg_operNotSupported=$(gettext "erro: operação não suportada")
	cmsg_ButtonBack=$(gettext "Voltar")
	cmsg_ButtonFeito=$(gettext "Feito")
	cmsg_ButtonEscolher=$(gettext "Escolher")
	cmsg_info_disco=$(gettext "Info disco")
	cmsg_info_particao=$(gettext "Info partição")
	cmsg_ok=$(gettext "Ok")
	cmsg_Exit=$(gettext "Sair")
	cmsg_Select=$(gettext "Selecionar")
	cmsg_disco_origem=$(gettext "DISCO DE ORIGEM")
	cmsg_Source=$(gettext "Fonte")
	cmsg_disco_destino=$(gettext "DISCO DE DESTINO")
	cmsg_dest=$(gettext "Escolha o disco de DESTINO:")
	cmsg_yeslabel=$(gettext "Sim")
	cmsg_nolabel=$(gettext "Não")
	cmsg_todos_os_dados_serao_perdidos=$(gettext "Todos os dados disco DESTINO serão perdidos!")
	cwarning=$(gettext "=== AVISO ===")
	cmsg_DismountFileSystem=$(gettext "Desmontando sistema de arquivos")
	cmsg_FinalizadaComSucesso=$(gettext "Instalação finalizada com sucesso")
	cmsg_ErroTar=$(gettext "Falha ao descompactar o tarball")
	cmsg_Para=$(gettext "para")
	cmsg_ConfSalva=$(gettext "Configurações salvas para instalação")
	cmsg_Operacao=$(gettext "nenhuma operação especificada - usar -h para ajuda")
	cmsg_OneOperacao=$(gettext "apenas uma operação pode ser usada por vez")
	cmsg_TestandoDisco=$(gettext "Testando disco")
	cmsg_ContinuarParticionamento=$(gettext "Continuar com o particionamento em")
	cmsg_FormatandoParticao=$(gettext "Formatando partição")
	cmsg_AtivandoServico=$(gettext "Ativando serviço")
	cmsg_IniciandoServico=$(gettext "Iniciando serviço")
	cmsg_Permissoes=$(gettext "permissões")
	cmsg_ChecandoTarball=$(gettext "Checando existência do tarball")
	cmsg_VerificandoIntegridadeTarball=$(gettext "Verificando a integridade do tarball")
	cmsg_IniciandoDownload=$(gettext "Iniciando download de")
	cmsg_CriandoParticoes=$(gettext "Criando partições em")
	cmsg_CriandoDiretorios=$(gettext "Criando diretórios em")
	cmsg_AtualizandoRepositorio=$(gettext "Atualizando repositório")
	cmsg_RemovendoPacotesAntigosObseletos=$(gettext "Removendo pacotes antigos/absoletos")
	cmsg_InstalandoMetaPacotes=$(gettext "Instalando meta pacote X")
	cmsg_AtualizandoPacotesBase=$(gettext "Atualizando pacotes base")
	cmsg_AtualizandoPacotesAdicionais=$(gettext "Atualizando pacotes adicionais em")
	cmsg_part_disk=$(gettext "Visualizar partições do disco")
	cmsg_TitleDisco=$(gettext "=== DISCO ===")
	cmsg_TitleFileSystem=$(gettext "=== FILE SYSTEM ===")
	cmsg_ChecandoParticoesMontadas=$(gettext "Checando por partições montadas no disco")
	cmsg_all_mounted_part=$(gettext "O disco selecionado contém partições montadas")
	cmsgSetKeyboardLayout=$(gettext "Escolher outro layout de teclado")
	cmsg_LayoutAtual=$(gettext "Layout atual")
	cmsg_umount_partition=$(gettext "Aguarde, Desmontando particao de trabalho")
	cmsg_ErroLeituraDisco=$(gettext "Erro de leitura do disco")
	cmsg_SemRota=$(gettext "Sem rota para o servidor")
	cmsg_CheckNet=$(gettext "Check sua conexão com a internet!")
	cmsg_CommandNotFound=$(gettext "não encontrei o comando")
	cmsg_ImpossivelContinuar=$(gettext "IMPOSSÍVEL CONTINUAR")
	cmsg_ImpossivelContinuar1=$(gettext "Esse script precisa dos comandos listados acima")
	cmsg_ImpossivelContinuar2=$(gettext "Instale-os e/ou verifique se estão no seu")
	cmsg_InstCommand=$(gettext "Instalar o(s) comando(s)")
	cmsg_RunNew=$(gettext "INFO: Rode novamente o aplicativo")
	cmsg_RunNewErro=$(gettext "ERRO na instalação dos comandos. Tente manualmente")
	cmsg_CopiandoCaminhoReserva=$(gettext "Criando inicialização padrão/reserva (roaming) para")
	cmsg_Error_not_fatal=$(gettext "Erro não fatal. Para mais detalhes veja o log")
	cmsg_Wm=$(gettext "gerenciador de janelas (wm)")
	cmsg_TabelaMBR=$(gettext "Tabela MBR (dos)")
	cmsg_ExtraEfi=$(gettext "Detectado boot via EFI ↓ é recomendável instalar EFI ↓")
	cmsg_ExtraNotEfi=$(gettext "EFI não detectado ↓ é recomendável GPT_BIOS ou MBR_BIOS ↓")
	cmsg_ExtraIso=$(gettext "Detectado boot via ISO ↓ é recomendável instalar ↓")
	cmsg_ExtraNotIso=$(gettext "ISO não detectado ↓ é recomendável NETWORK ou NETWORKFULL↓")
	cmsg_ExtraNotHostVoid=$(gettext "Host VOID não detectado ↓ é recomendável NETWORK↓")
	welcome=$(gettext "Bem-vindo ao instalador $APP")
	escolhaIdioma=$(gettext "Escolha o idioma")
	cmsg_Usuario=$(gettext "Usuário")
	cmsg_adduser1=$(gettext "Usuário não pode estar root! Novamente?")
	cmsg_adduser2=$(gettext "Usuário não pode estar vazio! Novamente?")
	cmsg_adduser3=$(gettext "Senha do usuário não pode estar vazia! Novamente?")
	cmsg_adduser4=$(gettext "Senha de root não pode estar vazia! Novamente?")
	cmsg_adduser5=$(gettext "Usuário não pode iniciar com números! Novamente?")
	cmsg_adduser6=$(gettext "Usuário não pode iniciar com letras maiúsculas! Novamente?")
	cmsg_adduserCancel=$(gettext "Cadastro de usuário cancelado")
	cmsg_redewifi=$(gettext "Rede wifi")
	cmsg_senhawifi=$(gettext "Senha wifi")
	cmsg_mkfs=$(gettext "↓ é recomendável ext4 ↓")
	cmsg_utilvoidservices=$(gettext "Utilitário void-services (opcional)")
	cmsg_Servicos=$(gettext "Serviços")
	cmsg_Tema=$(gettext "Tema")
	cmsg_Usage1=$(gettext "Instalar")
	cmsg_Usage2=$(gettext "Rodar chroot na partição instalada")
	cmsg_Usage3=$(gettext "Ativar modo gráfico")
	cmsg_Usage4=$(gettext "Saída resumida")
	cmsg_Usage5=$(gettext "Mostrar versão do aplicativo")
	cmsg_Usage6=$(gettext "Remove cores da saída")
	cmsg_Usage7=$(gettext "Este help")
	cmsg_Usage8=$(gettext "Carregar arquivo de configuração")
	cmsg_Extra1=$(gettext "Nome Completo")
	cmsg_Extra2=$(gettext "Nome usuario")
	cmsg_Extra3=$(gettext "Senha usuario")
	cmsg_Extra4=$(gettext "Senha root")
	cmsg_Extra6=$(gettext "Disco destino")
	cmsg_Extra11=$(gettext "Gerenciador Janelas")
	cmsg_Bios=$(gettext "Sistema Básico de Entrada e Saída")
	cmsg_Efi=$(gettext "Interface de Firmware Extensível")
	cmsg_TabelaGPT=$(gettext "Tabela GPT")
	cmsg_NotConfDefault=$(gettext "não foi configurado!")
	cmsg_NotConfDisco=$(gettext "Disco não foi configurado!")
	cmsg_NotConfFileSystem=$(gettext "Filesystem não foi configurado!")
	cmsg_NotConfBootLoader=$(gettext "Bootloader não foi configurado!")
	cmsg_NotConfTeclado=$(gettext "Teclado não foi configurado!")
	cmsg_NotConfTimezone=$(gettext "Timezone não foi configurado!")
	cmsg_NotConfWm=$(gettext "Gerenciador de Janelas não foi configurado!")
	cmsg_NotConfWifi=$(gettext "Rede wifi não foi configurado!")
	cmsg_NotConfExtra=$(gettext "Usuário não foi configurado!")
	cmsg_DefinirAudioServer=$(gettext "Definir servidor de audio")
}

sh_tar_rootfs() {
	sh_checkTarball || return 1
	sh_info_msg "${cmsg_Descompactando} rootfs ${cmsg_Em} $dir_install"
	tar xpf "$_TARBALL_ROOTFS" --xattrs-include='*.*' --numeric-owner -C $dir_install 2>&1 | tee -i -a "$BOOTLOG" >$LOGGER
	ret="${PIPESTATUS[0]}"
	if [[ "$ret" -eq 0 ]]; then
		evaluate_retval "$ret"
		return "$ret"
	else
		evaluate_retval "$ret" "$err_not_fatal"
		sh_umount_fs
		if conf "${YELLOW}${_TARBALL_ROOTFS}" "${cmsg_Tarball_Corrompido}"; then
			sh_checkIntegrityTarball || return 1
			sh_install
		else
			die "${cmsg_ERRO} tar '#'$ret. ${cmsg_ErroTar} $_TARBALL_ROOTFS ${cmsg_Em} $dir_install"
		fi
	fi
}

sh_execcopia() {
	ORIGEM="/run/rootfsbase/"
	DESTINO="$dir_install/"
	DEST="$dir_install"
	PONT='|/—\' # Ponteiros de um hélice do lado direito
	nVal=0

	sizeof() { du -s "$1" 2>/dev/null | cut -f1; }
	running() { ps "$1" | grep "$1" >/dev/null; }

	TITLE="INSTALL"
	#   INTERVALO=0.001
	INTERVALO=0.5
	#   PORCENTO=0
	DIR_DESTINO="$DESTINO/${ORIGEM##*/}"
	MSG="Aguarde, instalando... if=$ORIGEM of=$DESTINO"
	#   MSG=$(eval echo "$MSG")
	mensagem "Aguarde, computando arquivos para instalar"
	#   TOTAL=$(unsquashfs -ll "$LIVE_DIR" | awk '{n+=$3} END {print n}')
	#   TOTAL=$((TOTAL/1024))
	#  TOTALGB=$((TOTAL/1024))
	TOTAL=$(sizeof "$ORIGEM")
	TOTALGB=$((TOTAL / 1024))
	DISPONIVEL=$(df | grep "${DEST}" | awk '{print $4}' | head -1)
	DISPONIVEL=$((DISPONIVEL / 1024))

	if ((DISPONIVEL < TOTALGB)); then
		if ! confmulti "$(gettext '*** AVISO ***')" \
			"\n$(gettext 'Tamanho da partição destino é menor que o necessário')\n" \
			"\n$(gettext 'Partição destino')   : ${part}" \
			"\n$(gettext 'Tamanho disponível') : ${DISPONIVEL}G" \
			"\n$(gettext 'Tamanho necessário') : ${TOTALGB}G" \
			"\n\n$(gettext 'Sistema destino poderá não funcionar, continuar?')"; then
			#           sh_stop_bind
			#           sh_stop_mount
			#           sh_main_menu "$@"
			return 1
		fi
	fi

	log="/tmp/${_APP_}.log"
	[ -e "$log" ] && rm -f "$log"

	rsync -crav "$ORIGEM" "$DESTINO" 1>&2 >"$log" &
	export CPPID=$!

	#  trap sh_trapErro 2 15
	#trap "kill $CPPID" 2 15
	(
		while running "$CPPID"; do
			((nval >= 4)) && nval=0
			COPIADO=$(sizeof "$DIR_DESTINO")
			PERCENTAGEM=$((COPIADO * 100 / TOTAL))
			COPIADOMB=$((COPIADO / 1024))
			LASTFILE=$(tail -n1 "$log")
			[[ "$PERCENTAGEM" -gt 100 ]] && PERCENTAGEM=100
			${DIALOG} --colors \
				--title $TITLE \
				--gauge "$MSG                                       \n$(gettext 'Falta') ${RED}${REVERSE}$((100 - PERCENTAGEM))%${RESET} $(gettext 'para completar a tarefa') \Zb\Z1${PONT:nval:1}\ZB\Zn \
                                    \n\n$(gettext 'Destino')    : ${BLUE}${REVERSE}${AConfDisk[_DEVICE]}$dir_install${RESET}
                                    \n$(gettext 'Disponivel') : ${DISPONIVEL}MB\
                                    \n$(gettext 'Total')      :  ${TOTALGB}MB\
                                    \n$(gettext 'Copiado')    :  ${BLUE}${REVERSE}${COPIADOMB}MB${RESET}\
                                    \n$(gettext 'Arquivo')    : ${LASTFILE}\
                                    \n" 13 130 0 <<<$PERCENTAGEM
			((nval++))
			#           sleep $INTERVALO
		done
	)
	return 0
}

sh_populate_mountpoints() {
	local parent="${AConfDisk[_DEVICE]}"
	local dev fs mp
	local formatar=1

	# zera o array global
	Amntpoint=()

	while read -r dev fs mp; do
		# swap não tem mountpoint
		if [[ "$fs" == "swap" ]]; then
			mp="none"
		fi

		mp="${mp:-none}"
		fs="${fs:-unknown}"
		Amntpoint["$dev"]="$mp|$fs|$formatar"
	done < <(
		lsblk -lnpo NAME,FSTYPE,MOUNTPOINT "$parent" | tail -n +2
	)
}

sh_rebind_amntpoint_device() {
	local new_device="${AConfDisk[_DEVICE]}"
	local old_device
	local dev newdev
	local -A _new

	# array vazio? nada a fazer
	((${#Amntpoint[@]})) || return 0

	# descobre o device antigo a partir da primeira chave
	for dev in "${!Amntpoint[@]}"; do
		old_device="${dev%p*}"
		break
	done

	# se for o mesmo device, não altera
	[[ "$old_device" == "$new_device" ]] && return 0

	# copia mudando o prefixo do device
	for dev in "${!Amntpoint[@]}"; do
		newdev="${dev/#$old_device/$new_device}"
		_new["$newdev"]="${Amntpoint[$dev]}"
	done

	# substitui o array original
	Amntpoint=()
	for dev in "${!_new[@]}"; do
		Amntpoint["$dev"]="${_new[$dev]}"
	done
}

sh_rebuild_amntpoint_for_new_disk() {
	local device="${AConfDisk[_DEVICE]}"
	local root_set=false
	local fs

	[[ -n "$device" ]] || return 1

	#   # se já existe algo desse device, não refaz
	#   for fs in "${!Amntpoint[@]}"; do
	#      [[ "$fs" == "$device"* ]] && return 0
	#   done
	#
	Amntpoint=()

	while read -r line; do
		eval "${line//=/_=}"

		# só partições
		[[ "$TYPE_" == "part" ]] || continue

		# --- CASO 1: FSTYPE EXISTE ---
		if [[ -n "$FSTYPE_" ]]; then
			case "$FSTYPE_" in
			vfat)
				Amntpoint["$PATH_"]="/boot/efi|vfat|1"
				continue
				;;
			swap)
				Amntpoint["$PATH_"]="none|swap|1"
				continue
				;;
			*)
				fs="$FSTYPE_"
				;;
			esac

		# --- CASO 2: FSTYPE VAZIO → PARTTYPENAME ---
		else
			case "$PARTTYPENAME_" in
			*BIOS*)
				continue
				;;
			*EFI*)
				Amntpoint["$PATH_"]="/boot/efi|vfat|1"
				continue
				;;
			*swap*)
				Amntpoint["$PATH_"]="none|swap|1"
				continue
				;;
			*"Linux filesystem"*)
				fs="ext4"
				;;
			*)
				continue
				;;
			esac
		fi

		# --- FILESYSTEM NORMAL (ext4, xfs, etc) ---
		if ! $root_set; then
			Amntpoint["$PATH_"]="/|$fs|1"
			root_set=true
		else
			Amntpoint["$PATH_"]="none|$fs|0"
		fi

	done < <(
		lsblk -fPAo TYPE,NAME,PATH,SIZE,TRAN,MODEL,LABEL,SERIAL,FSTYPE,PARTTYPENAME "$device" |
			grep -P 'TYPE="(part)"' |
			sort -k5,5 -k2,2
	)

	((${#Amntpoint[@]})) && LMKPARTED=true || LMKPARTED=false
}

sh_setEnvironment
sh_getLocale
sh_setLanguage
sh_setVarColors
sh_setAsciiLines
sh_setLogPrefix

[[ "${1-}" = @(-V|--version) ]] && {
	sh_version
	exit $(($# ? 0 : 1))
}

[[ "${1-}" = @(-h|--help) ]] && {
	sh_usage
	exit $(($# ? 0 : 1))
}

sh_checkDependencies
sh_checkRoot
sh_checkDisplay
#sh_update_self "$@"
sh_loadSavedConfig
sh_disablePrintk
sh_loadconf

case " $* " in
*" -c "* | *" --chroot "*)
	grafico=0
	sh_init "$@"
	;;
*)
	grafico=1
	sh_init -i "$@"
	;;
esac

# sanity checks
if ! $LINSTALL && ! $LCHROOT; then
	die "${cmsg_Operacao}"
fi

if $LINSTALL && $LCHROOT; then
	die "${cmsg_OneOperacao}"
fi

sh_setMknodTty
#sh_menu_language "$@"
for x in "${appexec[@]}"; do $x; done
sh_enablePrintk
