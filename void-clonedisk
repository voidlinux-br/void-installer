#!/usr/bin/env bash
#shellcheck disable=SC2154,SC2016,SC2034,SC2059
#
#rsync -aAXv /mnt/ /lfs/evili/ --exclude={"/dev/*","/proc/*","/sys/*","/tmp/*","/run/*","/mnt/*","/lost+found"}
#
#  chili-clonedisk - utility written in bash to clone disks
#  Chili GNU/Linux - https://github.com/vcatafesta/ChiliOS
#  Chili GNU/Linux - https://chililinux.com
#  Chili GNU/Linux - https://chilios.com.br
#
#  Created: 2019/04/05
#  Altered: 2022/10/14
#  Updated: sex 09 jan 2026 18:08:53 -04
#
#  Copyright (c) 2019-2025, Vilmar Catafesta <vcatafesta@gmail.com>
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR AS IS'' AND ANY EXPRESS OR
#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
#  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
#  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#########################################################################
#export LANGUAGE=en
#export LANGUAGE=pt_BR
export TEXTDOMAINDIR=/usr/share/locale
export TEXTDOMAIN=chili-clonedisk

#declare -r APP="${0##*/}"
declare -r _APP_="chili-clonedisk"
declare -r _VERSION_="6.1.09.20260109"
declare -gA Alanguage=([pt_BR]=0 [en_US]=1 [de_DE]=2 [fr_FR]=3 [es_ES]=4 [it_IT]=5)
declare -gA Alocale=([0]=pt_BR [1]=en_US [2]=de_DE [3]=fr_FR [4]=es_ES [5]=it_IT)
declare dialogRcFile="$HOME/.dialogrc"
readonly -a DEPENDENCIES=(dd awk ionice dialog pv tput find smartctl)
readonly -A PACKAGEDEP=(
	['dd']='coreutils'
	['awk']='gawk'
	['ionice']='util-linux'
	['dialog']='dialog'
	['pv']='pv'
	['tput']='ncurses'
	['find']='findutils'
	['smartctl']='smartmontools'
)

# debug
export PS4=$'${red}${0##*/}${green}[$FUNCNAME]${pink}[$LINENO]${reset} '
#set -x
#set -e
shopt -s extglob

detect_distro() {
	local id=""

	if [[ -r /etc/os-release ]]; then
		# Lê ID=void|arch|debian|... exatamente como a distro declara
		id=$(grep -E '^ID=' /etc/os-release | cut -d= -f2 | tr -d '"')
	elif [[ -r /usr/lib/os-release ]]; then
		id=$(grep -E '^ID=' /usr/lib/os-release | cut -d= -f2 | tr -d '"')
	else
		echo "unknown"
		return
	fi
	echo "$id"
}

# Testa se o terminal suporta caracteres gráficos estendidos
sh_ascii-lines() {
	#Isso força o dialog a usar caracteres ASCII básicos para as bordas.
	#if [[ "$LANG" =~ 'UTF-8' ]]; then
	if [[ "$(printf '\u250C')" =~ "┌" ]]; then
		export NCURSES_NO_UTF8_ACS=1 # Terminal suporta ACS
	else
		export NCURSES_NO_UTF8_ACS=0 # Terminal NÃO suporta ACS
	fi
}

cleanup() {
	rm -f "$dialogRcFile"
}
#trap cleanup EXIT

sh_create_dialogrc() {
	cat >"$dialogRcFile" <<-'EOF'
		screen_color = (white,black,off)
		dialog_color = (white,black,off)
		title_color = (cyan,black,on)
		border_color = dialog_color
		shadow_color = (black,black,on)
		button_inactive_color = dialog_color
		button_key_inactive_color = dialog_color
		button_label_inactive_color = dialog_color
		button_active_color = (white,cyan,on)
		button_key_active_color = button_active_color
		button_label_active_color = (black,cyan,on)
		tag_key_selected_color = (white,cyan,on)
		item_selected_color = tag_key_selected_color
		form_text_color = (BLUE,black,ON)
		form_item_readonly_color = (green,black,on)
		itemhelp_color = (white,cyan,off)
		inputbox_color = dialog_color
		inputbox_border_color = dialog_color
		searchbox_color = dialog_color
		searchbox_title_color = title_color
		searchbox_border_color = border_color
		position_indicator_color = title_color
		menubox_color = dialog_color
		menubox_border_color = border_color
		item_color = dialog_color
		tag_color = title_color
		tag_selected_color = button_label_active_color
		tag_key_color = button_key_inactive_color
		check_color = dialog_color
		check_selected_color = button_active_color
		uarrow_color = screen_color
		darrow_color = screen_color
		form_active_text_color = button_active_color
		gauge_color = title_color
		border2_color = dialog_color
		searchbox_border2_color = dialog_color
		menubox_border2_color = dialog_color
		separate_widget = ''
		tab_len = 0
		visit_items = off
		use_shadow = off
		use_colors = on
EOF
	export DIALOGRC="$dialogRcFile"
}

sh_configure() {
	[[ ! -e "$dialogRcFile" ]] && sh_create_dialogrc
	sh_ascii-lines
	true=0
	#	false=1

	# flag languages
	: "${PT_BR=0}"
	: "${EN_US=1}"
	: "${DE_DE=2}"
	: "${FR_FR=3}"
	: "${LC_DEFAULT=$(sh_getLocale)}"

	# flag dialog exit status codes
	: "${D_OK=0}"
	: "${D_CANCEL=1}"
	: "${D_HELP=2}"
	: "${D_EXTRA=3}"
	: "${D_ITEM_HELP=4}"
	: "${D_ESC=255}"

	# flag disk info
	: "${DSK_NAME=1}"
	: "${DSK_SIZE=2}"
	: "${DSK_TRAN=3}"
	: "${DSK_MODEL=4}"
	: "${DSK_LABEL=5}"
	: "${DSK_SERIAL=6}"
	: "${DSK_PTTYPE=7}"
	: "${DSK_FSTYPE=8}"
	: "${DSK_PARTTYPENAME=9}"

	# common vars
	: "${DIALOG=${DIALOG:-"dialog"}}"
	: "${grafico=$true}"
	: "${xapp="$_APP_"}"
	: "${ccabec="${xapp} $_VERSION_"}"
	: "${ctitle="$cdistro Linux"}"
	welcome=$(gettext "Bem vindo ao ")

	# system colors
	tput sgr0 # reset colors
	bold=$(tput bold)
	cyan=$(tput setaf 6)
	black="${bold}$(tput setaf 0)"
	blue=$(tput setaf 4)
	green=$(tput setaf 2)
	yellow=$(tput bold)$(tput setaf 3)
	orange=$(tput setaf 3)
	pink=$(tput setaf 5)
	purple=$(tput setaf 125)
	red=$(tput bold)$(tput setaf 196)
	reset=$(tput sgr0)
	white="${bold}$(tput setaf 7)"
	violet=$(tput setaf 61)

	# dialog colors
	REVERSE="\Zr"
	UNDERLINE="\Zu"
	BOLD="\Zb"
	RESET="\Zn"
	BLACK="\Z0"
	YELLOW="\Z3"
	WHITE="\Z7"
	BLUE="\Z4"
	CYAN="\Z6"
	RED="\Z1"
	GREEN="\Z2"
	MAGENTA="\Z5"
	sep='\xe2\x94\x82'

	COL_NC='\e[0m' # No Color
	COL_LIGHT_GREEN='\e[1;32m'
	COL_LIGHT_RED='\e[1;31m'
	TICK="${white}[${COL_LIGHT_GREEN}✓${COL_NC}${white}]"
	CROSS="${white}[${COL_LIGHT_RED}✗${COL_NC}${white}]"
	INFO="[i]"
	# shellcheck disable=SC2034
	DONE="${COL_LIGHT_GREEN} done!${COL_NC}"
	OVER="\\r\\033[K"
}

sh_toBytes() {
	local ent mut num fra sai

	ent=${1^^}
	[[ -z "${ent}" ]] && ent=0B
	mut=${ent//[^BKMGT]/}
	num=${ent//[^[:digit:]]/}
	ent=${ent//$mut/}
	fra=${ent//[^,.]/}
	fra=${fra:+${ent//*[,.]/}}
	ent=0BKMGT
	ent=${ent//$mut*/}
	#mut=$((${#ent}-1))
	((mut = ${#ent} - 1, sai = num * 1024 ** mut))
	((ent = ${#sai} - ${#fra}))
	echo ${sai:0:$ent}
}

sh_version() {
	printf "$0 $_VERSION_\n"
}

sh_unsetvarcolors() {
	unset bold reset cyan red blue white black green yellow orange pink cyan purple violet
}

sh_getLocale() {
	local lc

	LC_DEFAULT="${Alanguage[pt_BR]}"
	LOCALE="pt_BR"
	#	if lc=$(grep _ <(locale -a) | head -1 | cut -c1-5); then
	#		LOCALE="$lc"
	#		LC_DEFAULT="${Alanguage[$lc]}"
	#	fi
}

sh_splitarray() {
	local str=("$1")
	local pos="$2"
	local sep="${3:-'|'}"
	local array

	[[ $# -eq 3 && "$pos" = "|" && "$sep" =~ ^[0-9]+$ ]] && {
		sep="$2"
		pos="$3"
	}
	[[ $# -eq 2 && "$pos" = "$sep" ]] && {
		sep="$pos"
		pos=1
	}
	[[ $# -eq 1 || ! "$pos" =~ ^[0-9]+$ ]] && { pos=1; }

	#	IFS="$sep" read -r -a array <<< "$str"
	IFS="$sep" read -r -a array <<<"${str[@]}"
	echo "${array[pos - 1]}"
}

sh_seekstrarray() {
	local str=("$1")
	local search="$2"
	local result=

	for i in "${!str[@]}"; do
		if [[ "${str[$i]}" == "$search" ]]; then
			result="$i"
			break
		fi
	done
	echo "$result"
}

confirma() {
	[ "$1" -ne 0 ] && {
		conf "INFO" "$2"
		return $?
	}
}

msg() {
	if [ "$grafico" -eq $true ]; then
		${DIALOG} \
			--no-collapse \
			--title "$1" \
			--infobox "\n$2" \
			6 60
	else
		log_info_msg "$2"
	fi
}

mensagem() {
	${DIALOG} \
		--title "$ctitle" \
		--backtitle "$ccabec" \
		--infobox "$*" \
		6 60
}

alerta() {
	${DIALOG} \
		--colors \
		--title "$1" \
		--no-collapse \
		--cr-wrap \
		--keep-tite \
		--backtitle "$ccabec" \
		--msgbox "\Z2$2\n\Z1$3\n\Z3$4\n\Z4$5\n\Z5$6" \
		0 0
}

#		--no-nl-expand \
display_result() {
	local xtitle="$1"
	shift
	${DIALOG} \
		--title "$xtitle" \
		--backtitle "$ccabec" \
		--colors \
		--beep \
		--no-cr-wrap \
		--no-collapse \
		--msgbox "$*" \
		25 100 >/dev/tty
}

info() {
	${DIALOG} \
		--colors \
		--beep \
		--title "$ctitle" \
		--backtitle "$ccabec" \
		--msgbox "\Z1$*" \
		10 60 >/dev/tty
}

debug() {
	whiptail \
		--fb \
		--clear \
		--backtitle "[debug]$0" \
		--title "[debug]$0" \
		--yesno "${*}\n" \
		0 40 >/dev/tty
	result=$?
	if ((result)); then
		exit
	fi
	return $result
}

readconf() {
	local msg="$1"
	local color="${2:-${red}}"

	echo -n -e "$color"
	if [[ $LC_DEFAULT -eq 0 ]]; then
		read -r -p "$msg [S/n]"
	else
		read -r -p "$msg [Y/n]"
	fi
	echo -n -e "$reset"
	case "${REPLY^}" in
	[SY]) return 0 ;;
	"") return 0 ;;
	*) return 1 ;;
	esac
}

conf() {
	xtitle="$1"
	shift
	${DIALOG} \
		--colors \
		--title "$xtitle" \
		--backtitle "$ccabec" \
		--no-collapse \
		--no-cr-wrap \
		--erase-on-exit \
		--yes-label "${cmsg_yeslabel[$LC_DEFAULT]}" \
		--no-label "${cmsg_nolabel[$LC_DEFAULT]}" \
		--yesno "$*" \
		15 100 >/dev/tty
	nchoice=$?
	return "$nchoice"
}

confmulti() {
	xtitle="$1"
	shift
	${DIALOG} \
		--title "$xtitle" \
		--backtitle "$ccabec" \
		--yes-label "${cmsg_yeslabel[$LC_DEFAULT]}" \
		--no-label "${cmsg_nolabel[$LC_DEFAULT]}" \
		--yesno "$*" \
		10 100 >/dev/tty
	return $?
}

get() {
	local row="$1"
	local col="$2"
	local prompt="$3"
	local new_value="$4"
	local old_value="$5"
	local color="${Acores[box]}"

	# setpos "$row" "$col"
	printf "%s" "${reset}$color"
	read -p "${prompt}${reverse}" -e -i "$old_value" "$new_value"
	# tput sc # Salva a posição atual do cursor
	echo -n -e "$reset"
}

row() { echo "$Prow"; }
col() { echo "$Pcol"; }
lastrow() { echo "$(tput lines)"; }
lastcol() { echo "$(tput cols)"; }

sh_checkdisk() {
	local target="$1"
	local nchoice=0
	local dsk
	local mnt

	# Usa df com tabulação pra evitar bugs com espaços em nomes de caminhos
	dsk=$(df -hT | grep -F "$target")

	if [[ -n "$dsk" ]]; then
		if conf "${cwarning[$LC_DEFAULT]}" \
			"\n${BOLD}${RED}ERROR: ${cmsg_all_mounted_part[$LC_DEFAULT]}${RESET}\n\n \
$dsk\n\n \
${YELLOW}${cmsg_dismount[$LC_DEFAULT]}"; then
			# desmontar qualquer ponto montado que contenha "$target"
			mount | grep -F "$target" | awk '{print $3}' | while read -r mnt; do
				if ! umount -f "$mnt" 2>/dev/null; then
					nchoice=1
					break
				fi
			done
		else
			nchoice=1
		fi
	fi
	return $nchoice
}

sh_part_info() {
	unset ARRAY_DSK_{DISKS,DEVICES,SIZE,TRAN,MODEL,LABEL,SERIAL,PTTYPE,FSTYPE}
	local {NAME,PATH,SIZE,TRAN,MODEL,LABEL,SERIAL,PTTYPE,FSTYPE}_
	declare -gA AARRAY_DSK_DEVICES=()
	declare -gA AARRAY_DSK_PARTITIONS=()

	while read -r line; do
		eval "${line//=/_=}"
		ARRAY_DSK_DISKS+=("$NAME_")
		ARRAY_DSK_DEVICES+=("$PATH_")
		ARRAY_DSK_PARTITIONS+=("$PATH_")
		ARRAY_DSK_SIZE+=("$SIZE_")
		ARRAY_DSK_TRAN+=("${TRAN_:-${TYPE_}}")
		ARRAY_DSK_MODEL+=("${MODEL_:-${TYPE_} device}")
		ARRAY_DSK_LABEL+=("${LABEL_:-""}")
		ARRAY_DSK_SERIAL+=("${SERIAL_:-""}")
		ARRAY_DSK_PTTYPE+=("${PTTYPE_:-""}")
		ARRAY_DSK_FSTYPE+=("${FSTYPE_:-none}")
		AARRAY_DSK_DEVICES+=(["$PATH_"]="$NAME_|$SIZE_|${TRAN_:-${TYPE_}}|${MODEL_:-${TYPE_} device}|${LABEL_:-""}|${SERIAL_:-""}|${PTTYPE_:-""}|${FSTYPE_:-"none"}")
	done < <(lsblk -PAo TYPE,NAME,PATH,SIZE,TRAN,MODEL,LABEL,SERIAL,PTTYPE,FSTYPE | grep -P 'TYPE="(part|lvm)"' | sort -k5,5 -k2,2)
	#done < <(lsblk -PAo TYPE,NAME,PATH,SIZE,TRAN,MODEL,LABEL,SERIAL | grep -P 'TYPE="(disk)"' | sort -k5,5 -k2,2)
	#done < <(lsblk -Pao TYPE,NAME,PATH,SIZE,TRAN,MODEL | grep -P 'TYPE="(disk)')
	#done < <(lsblk -Pao TYPE,NAME,PATH,SIZE,TRAN,MODEL | grep disk)
	#declare -p ARRAY_DSK_{DISKS,DEVICES,SIZE,TRAN,MODEL}
}

sh_disk_info() {
	unset ARRAY_DSK_{DISKS,DEVICES,SIZE,TRAN,MODEL,LABEL,SERIAL,PTTYPE,FSTYPE}
	local {NAME,PATH,SIZE,TRAN,MODEL,LABEL,SERIAL,PTTYPE,FSTYPE}_
	declare -gA AARRAY_DSK_DEVICES=()
	declare -gA AARRAY_DSK_PARTITIONS=()

	while read -r line; do
		eval "${line//=/_=}"
		ARRAY_DSK_DISKS+=("$NAME_")
		ARRAY_DSK_DEVICES+=("$PATH_")
		ARRAY_DSK_PARTITIONS+=("$PATH_")
		ARRAY_DSK_SIZE+=("$SIZE_")
		ARRAY_DSK_TRAN+=("${TRAN_:-${TYPE_}}")
		ARRAY_DSK_MODEL+=("${MODEL_:-${TYPE_} device}")
		ARRAY_DSK_LABEL+=("${LABEL_:-""}")
		ARRAY_DSK_SERIAL+=("${SERIAL_:-""}")
		ARRAY_DSK_PTTYPE+=("${PTTYPE_:-""}")
		ARRAY_DSK_FSTYPE+=("${FSTYPE_:-none}")
		AARRAY_DSK_DEVICES+=(["$PATH_"]="$NAME_|$SIZE_|${TRAN_:-${TYPE_}}|${MODEL_:-${TYPE_} device}|${LABEL_:-""}|${SERIAL_:-""}|${PTTYPE_:-""}|${FSTYPE_:-"none"}")
	done < <(lsblk -PAo TYPE,NAME,PATH,SIZE,TRAN,MODEL,LABEL,SERIAL,PTTYPE | grep -P 'TYPE="(disk|loop|lvm)"' | sort -k5,5 -k2,2)
	#done < <(lsblk -PAo TYPE,NAME,PATH,SIZE,TRAN,MODEL,LABEL,SERIAL | grep -P 'TYPE="(disk)"' | sort -k5,5 -k2,2)
	#done < <(lsblk -Pao TYPE,NAME,PATH,SIZE,TRAN,MODEL | grep -P 'TYPE="(disk)')
	#done < <(lsblk -Pao TYPE,NAME,PATH,SIZE,TRAN,MODEL | grep disk)
	#declare -p ARRAY_DSK_{DISKS,DEVICES,SIZE,TRAN,MODEL}
}

replicate() {
	local char=${1:-'#'}
	local nsize=${2:-$(tput cols)}
	local line
	printf -v line "%*s" "$nsize" && echo -e "${line// /$char}"
}
export -f replicate

sh_time_elapsed() {
	local end_time=$(date +%s)                # Obtém o tempo de término em segundos desde a época Unix
	local duration=$((end_time - start_time)) # Calcula a duração em segundos
	local hours=$((duration / 3600))
	local minutes=$(((duration % 3600) / 60))
	local seconds=$((duration % 60))

	# Formatar os valores para terem sempre dois dígitos
	hours=$(printf "%02d" $hours)
	minutes=$(printf "%02d" $minutes)
	seconds=$(printf "%02d" $seconds)
	echo "$hours:$minutes:$seconds"
}

sh_start_time_elapsed() {
	start_datetime=$(date)
	start_time=$(date +%s)
}

sh_end_time_elapsed() {
	end_datetime=$(date)
}

sh_conf_image_name() {
	source="$1"
	local txtDiskName

	DEVICE_SOURCE="$source"
	DEVICE_NAME="$(sh_splitarray "${AARRAY_DSK_DEVICES[$source]}" "$DSK_NAME")"
	MODEL_SOURCE="$(sh_splitarray "${AARRAY_DSK_DEVICES[$source]}" "$DSK_MODEL")"
	SIZE_SOURCE="$(sh_splitarray "${AARRAY_DSK_DEVICES[$source]}" "$DSK_SIZE")"
	LABEL_SOURCE="$(sh_splitarray "${AARRAY_DSK_DEVICES[$source]}" "$DSK_LABEL")"
	TRAN_SOURCE="$(sh_splitarray "${AARRAY_DSK_DEVICES[$source]}" "$DSK_TRAN")"
	FSTYPE_SOURCE="$(sh_splitarray "${AARRAY_DSK_DEVICES[$source]}" "$DSK_FSTYPE")"

	# Escolhe formato da imagem
	image_format=$(sh_choose_image_format) || return 1

	# Nome default da imagem
	cvdisk_name="${DEVICE_SOURCE//\//_}"
	cvdisk_name="${PWD}/${cvdisk_name#_}_${FSTYPE_SOURCE}.${image_format}"

	while true; do
		# Debug: verifica se variáveis estão corretas
		echo "DEBUG: DEVICE_SOURCE='$DEVICE_SOURCE' DEVICE_NAME='$DEVICE_NAME' MODEL_SOURCE='$MODEL_SOURCE' SIZE_SOURCE='$SIZE_SOURCE' LABEL_SOURCE='$LABEL_SOURCE' TRAN_SOURCE='$TRAN_SOURCE'"
		echo "DEBUG: cvdisk_name='$cvdisk_name'"
		# Mostra o formulário
		exec 3>&1
		txtDiskName=$(${DIALOG} \
			--backtitle "$ccabec" \
			--title "** CLONAR DISCO PARA IMAGEM **" \
			--ok-label "${cmsg_Select[$LC_DEFAULT]}" \
			--cancel-label "${cmsg_button_voltar[$LC_DEFAULT]}" \
			--colors \
			--insecure \
			--mixedform "${cmsg_LABEL[$LC_DEFAULT]}" \
			16 100 0 \
			"Device                     : " 1 1 "$DEVICE_SOURCE" 1 28 20 0 2 \
			"Name                       : " 2 1 "$DEVICE_NAME" 2 28 20 0 2 \
			"Tran                       : " 3 1 "$TRAN_SOURCE" 3 28 20 0 2 \
			"Label                      : " 4 1 "$LABEL_SOURCE" 4 28 20 0 2 \
			"Modelo                     : " 5 1 "$MODEL_SOURCE" 5 28 20 0 2 \
			"Tamanho                    : " 6 1 "$SIZE_SOURCE" 6 28 20 0 2 \
			"File System                : " 7 1 "$FSTYPE_SOURCE" 7 28 20 0 2 \
			"Entre com o nome da imagem : " 8 1 "$cvdisk_name" 8 28 60 0 0 \
			2>&1 1>&3)

		local exit_status=$?
		case $exit_status in
		1 | 255) # Cancel ou ESC
			echo "DEBUG: Usuário cancelou ou pressionou ESC"
			return 1
			;;
		0) # OK
			mapfile -t aDiskName <<<"$txtDiskName"
			cvdisk_name="${aDiskName[7]}"

			if [[ -z "$cvdisk_name" ]]; then
				conf "*** IMAGE NAME ***" "\nNome da imagem inválido! Tente novamente.\n" || die "*** IMAGE NAME ***"
				continue
			fi

			if [[ -e "$cvdisk_name" ]]; then
				if conf "*** IMAGE NAME ***" "${RED}Imagem '$cvdisk_name' já existe. Tentar outro nome?"; then
					continue
				fi
				return 1
			fi
			echo "DEBUG: Nome da imagem definido: $cvdisk_name"
			return 0
			;;
		*)
			echo "DEBUG: exit_status inesperado: $exit_status"
			return 1
			;;
		esac
		exec 3>&-
	done
}

# função para escolher o formato da imagem
sh_choose_image_format() {
	source="$1"
	local choice
	choice=$(${DIALOG} \
		--backtitle "$ccabec" \
		--title "** ESCOLHA O FORMATO DE SAIDA DA IMAGEM**" \
		--clear \
		--stdout \
		--colors \
		--menu "${cmsg_LABEL[$LC_DEFAULT]}\n\n\
${BOLD}${REVERSE}${WHITE}$(gettext "Selecione o formato da imagem do device"):\
${RESET}${BOLD}${YELLOW} ${source}|${SIZE_SOURCE}|${MODEL_SOURCE}${RESET}" \
		10 100 0 \
		1 "RAW (.img)" \
		2 "QCOW2 (.qcow2)")

	case $choice in
	1) echo "raw" ;;
	2) echo "qcow2" ;;
	*) return 1 ;;
	esac
}

sh_clone_disk_to_image() {
	local localtitle="${cmsg_disco_origem[$LC_DEFAULT]}"
	local diskselected=""

	source=$(sh_list_disk "${localtitle}" "${diskselected}")

	if [[ -n "$source" ]]; then
		sh_disk_info
		DEVICE_SOURCE="$source"
		MODEL_SOURCE="$(sh_splitarray "${AARRAY_DSK_DEVICES[$source]}" "$DSK_MODEL")"
		SIZE_SOURCE="$(sh_splitarray "${AARRAY_DSK_DEVICES[$source]}" "$DSK_SIZE")"
		sh_make_clone_disk_to_image "$source"
	fi
}

sh_make_clone_disk_to_image() {
	source="$1"
	local -i nchoice
	set -o pipefail

	if sh_conf_image_name "$source"; then
		# escolher formato
		#local image_format
		#image_format=$(sh_choose_image_format) || return 1

		local outfile="$cvdisk_name"

		if conf "${cwarning[$LC_DEFAULT]}" \
			"${cmsg_disco_origem[LC_DEFAULT]}: ${GREEN}$DEVICE_SOURCE | $SIZE_SOURCE | $MODEL_SOURCE${RESET}\n\
IMAGEM DESTINO : ${RED}$outfile\n\n" \
			"${BOLD}${YELLOW}${cmsg_continuar_com_a_clonagem[$LC_DEFAULT]}?\n"; then

			sh_start_time_elapsed
			mensagem "${cmsg_formatando_particao[$LC_DEFAULT]}: $source TO $outfile"

			# RAW simples com pv
			local src_size
			if [[ -b "$source" ]]; then
				src_size=$(sudo blockdev --getsize64 "$source")
			else
				src_size=$(stat -c%s "$source")
			fi

			SECTOR_SIZE=$(blockdev --getss $source)   # setor físico (4096)
			DISK_SIZE=$(blockdev --getsize64 $source) # tamanho em bytes

			(
				#       dd if="$source" bs=32M          conv=notrunc,noerror,sync status=none | pv --numeric --size "$src_size" > "$outfile"
				#       dd if="$source" bs=$SECTOR_SIZE conv=notrunc,noerror,sync status=none | pv --numeric --size "$src_size" > "$outfile"
				#       pv --numeric --size "$src_size" "$source" | dd of="$outfile" bs=32M conv=notrunc,noerror,sync status=none
				#       pv --numeric --size "$src_size" "$source" | dd of="$outfile" bs=32M conv=notrunc,noerror status=none
				pv --numeric --size "$src_size" "$source" >"$outfile"
			) 2>&1 |
				${DIALOG} \
					--title "${cmsg_running_disk_cloning[LC_DEFAULT]^^}" \
					--colors \
					--gauge \
					"${BOLD}${WHITE}${REVERSE}${cmsg_running_disk_cloning[LC_DEFAULT]} (pv → raw)${RESET}\n\n\
${cmsg_disco_origem[LC_DEFAULT]}: ${YELLOW}$DEVICE_SOURCE | $SIZE_SOURCE | $MODEL_SOURCE${RESET}\n\
IMAGEM DESTINO : ${RED}$outfile" \
					10 100 0
		fi
		nchoice=$?

		if [[ $image_format == "qcow2" ]]; then
			local tmp_raw="$outfile.tmp.raw"
			mv "$outfile" "$tmp_raw"

			# Infobox estilizado enquanto converte
			${DIALOG} --title "${cmsg_running_disk_cloning[LC_DEFAULT]^^}" --colors --infobox \
				"\
      ${BOLD}${WHITE}${REVERSE}Convertendo para QCOW2...${RESET}\n\n\
      ${BOLD}Origem (RAW):${RESET} ${YELLOW}$tmp_raw${RESET}\n\
      ${BOLD}Destino (QCOW2):${RESET} ${RED}$outfile${RESET}\n\n\
      Aguarde, esta operação pode levar alguns minutos..." 10 70

			# Conversão efetiva
			if qemu-img convert -p -O qcow2 "$tmp_raw" "$outfile" >/dev/null; then
				rm -f "$tmp_raw"
			fi
		fi

		sh_end_time_elapsed
		result="$(fdisk -b $SECTOR_SIZE -l $outfile)"
		message="$(printf "\n\n%s" "$result")"

		[[ $nchoice -eq 0 ]] && display_result \
			"fdisk -b $SECTOR_SIZE -l $outfile" \
			"${BOLD}${GREEN}${REVERSE}Clonagem concluída!${RESET}\n\n" \
			"${BOLD}${GREEN}${REVERSE}Info disk : $outfile${RESET}\n" \
			"${BOLD}${WHITE}$message\n\n" \
			"Start Date time  : ${BOLD}${BLUE}$start_datetime${RESET}\n" \
			"Finish Date Time : ${BOLD}${BLUE}$end_datetime${RESET}\n" \
			"Time elapsed     : ${BOLD}${GREEN}$(sh_time_elapsed)${RESET}\n"
		return $nchoice
	fi
}

sh_list_disk() {
	local localtitle="$1"
	local diskselected="$2"

	while true; do
		sh_disk_info
		local array=()
		local i
		local n=0
		local nc=0
		local result
		local nlen=0
		local csrc

		for i in "${ARRAY_DSK_DEVICES[@]}"; do
			if [[ "${i}" = "${diskselected}" ]]; then
				((++nc))
				continue
			fi
			if ((nlen < ${#i})); then
				nlen=${#i}
			fi
			array+=("$i" "$(printf "$sep%-6s$sep%6s$sep%-6s$sep%-20s$sep%-30s" \
				"${ARRAY_DSK_TRAN[$nc]}" \
				"${ARRAY_DSK_SIZE[$nc]}" \
				"${ARRAY_DSK_PTTYPE[$nc]}" \
				"${ARRAY_DSK_LABEL[$nc]}" \
				"${ARRAY_DSK_MODEL[$nc]}")")
			((++nc))
		done
		((nlen += 6))

		if [[ -z "$source" ]]; then
			csrc="(${cmsg_choose_disk_origem[LC_DEFAULT]})"
		else
			csrc="$DEVICE_SOURCE | $SIZE_SOURCE | $MODEL_SOURCE"
		fi

		selected=$(${DIALOG} \
			--default-item "$target" \
			--backtitle "$ccabec" \
			--title "${localtitle}" \
			--ok-label "${cmsg_Select[$LC_DEFAULT]}" \
			--cancel-label "${cmsg_button_voltar[$LC_DEFAULT]}" \
			--colors \
			--extra-button \
			--extra-label "${cmsg_info_disco[$LC_DEFAULT]}" \
			--menu "\
${YELLOW}${cmsg_disco_origem[LC_DEFAULT]} : ${REVERSE}$csrc${RESET}\n
${YELLOW}${cmsg_disco_destino[LC_DEFAULT]}: ${REVERSE}(${cmsg_choose_disk_destino[LC_DEFAULT]})${RESET}\n
$(replicate '_' 90)\n
$(printf "%${nlen}s$sep%-6s$sep%6s$sep%-6s$sep%-20s$sep%-30s" "DEVICE" "TRAN" "SIZE" "PTTYPE" "LABEL" "MODEL")" \
			25 0 25 "${array[@]}" 2>&1 >/dev/tty)

		exit_status=$?
		case $exit_status in
		"$D_ESC")
			return 1
			;;
		"$D_CANCEL")
			return 1
			;;
		3)
			result=$(fdisk -l "$selected")
			result0=$(smartctl --all "$selected")
			message=$(printf "\n\n%s\n\n%s" "$result" "$result0")
			display_result "$cmsg_disco_origem" \
				"${BOLD}${GREEN}${REVERSE}Info disk : $selected${RESET}" \
				"${BOLD}${WHITE}$message"
			continue
			;;
		esac

		if [[ -n "$selected" ]]; then
			echo "$selected"
			break
		fi
		break
	done
}

sh_list_partition() {
	local localtitle="$1"
	local part_selected="$2"

	while true; do
		sh_part_info
		local array=()
		local i
		local n=0
		local nc=0
		local result
		local nlen=0
		local csrc

		for i in "${ARRAY_DSK_DEVICES[@]}"; do
			if [[ "${i}" = "${part_selected}" ]]; then
				((++nc))
				continue
			fi
			if ((nlen < ${#i})); then
				nlen=${#i}
			fi
			array+=("$i" "$(printf "$sep%-6s$sep%6s$sep%-6s$sep%-20s$sep%-30s" \
				"${ARRAY_DSK_TRAN[$nc]}" \
				"${ARRAY_DSK_SIZE[$nc]}" \
				"${ARRAY_DSK_PTTYPE[$nc]}" \
				"${ARRAY_DSK_LABEL[$nc]}" \
				"${ARRAY_DSK_MODEL[$nc]}")")
			((++nc))
		done
		((nlen += 6))

		if [[ -z "$part_source" ]]; then
			csrc="(${cmsg_choose_part_origem[LC_DEFAULT]})"
		else
			csrc="$DEVICE_SOURCE | $SIZE_SOURCE | $MODEL_SOURCE"
		fi

		selected=$(${DIALOG} \
			--default-item "$target" \
			--backtitle "$ccabec" \
			--title "${localtitle}" \
			--ok-label "${cmsg_Select[$LC_DEFAULT]}" \
			--cancel-label "${cmsg_button_voltar[$LC_DEFAULT]}" \
			--colors \
			--extra-button \
			--extra-label "${cmsg_info_disco[$LC_DEFAULT]}" \
			--menu "\
${YELLOW}${cmsg_part_origem[LC_DEFAULT]} : ${REVERSE}$csrc${RESET}\n
${YELLOW}${cmsg_part_destino[LC_DEFAULT]}: ${REVERSE}(${cmsg_choose_part_destino[LC_DEFAULT]})${RESET}\n
$(replicate '_' 90)\n
$(printf "%${nlen}s$sep%-6s$sep%6s$sep%-6s$sep%-20s$sep%-30s" "DEVICE" "TRAN" "SIZE" "PTTYPE" "LABEL" "MODEL")" \
			25 0 25 "${array[@]}" 2>&1 >/dev/tty)

		exit_status=$?
		case $exit_status in
		"$D_ESC")
			#			init
			return
			;;
		"$D_CANCEL")
			#			init
			return
			;;
		3)
			result=$(fdisk -l "$selected")
			result0=$(smartctl --all "$selected")
			message=$(printf "\n\n%s\n\n%s" "$result" "$result0")
			display_result "$cmsg_disco_origem" \
				"${BOLD}${GREEN}${REVERSE}Info disk : $selected${RESET}" \
				"${BOLD}${WHITE}$message"
			continue
			;;
		esac

		if [[ -n "$selected" ]]; then
			echo "$selected"
			break
		fi
		break
	done
}

sh_clone_part_to_part() {
	if sh_choose_source_partition; then
		if sh_choose_target_partition; then
			sh_confclone "$part_source" "$part_target"
			sh_reset_conf
			:
		fi
	fi
}

get_fstype() {
	local img="$1"
	local out fs

	out=$(file "$img")
	# tenta extrair a parte que parece filesystem (ext, fat, ntfs, xfs, btrfs, exfat etc)
	# pega a última palavra que aparece em maiúscula ou ext/ext4/fat/ntfs
	fs=$(echo "$out" | grep -o -E '(ext[2-4]|fat|exfat|ntfs|xfs|btrfs|reiserfs|hfs|hfsplus|f2fs|vfat|swap)' | tail -n1)
	echo "$fs"
}

sh_list_image() {
	local localtitle="$1"
	local imageselected="$2"

	while true; do
		# Lista imagens no diretório atual (pode trocar o "." pelo diretório que quiser)
		mapfile -t ARRAY_IMG_FILES < <(find . -maxdepth 1 -type f \( -iname "*.raw" -o -iname "*.qcow2" -o -iname "*.img" \) | sort)

		if [[ "${#ARRAY_IMG_FILES[@]}" -eq 0 ]]; then
			info "erro: nenhuma imagem encontrada em '$PWD'"
			return 1
		fi

		local array=()
		local i
		local n=0
		local nlen=0
		local result
		maxcols=$(tput cols) # largura do terminal
		ntam=0

		for i in "${ARRAY_IMG_FILES[@]}"; do
			if [[ "${i}" = "${imageselected}" ]]; then
				continue
			fi

			# path completo
			local fpath=$(readlink -f "$i")

			# calcula largura máxima para alinhar
			if ((nlen < ${#fpath})); then
				nlen=${#fpath}
			fi

			# pega infos extras: tamanho e tipo
			local fsize=$(du -h "$i" | awk '{print $1}')
			local ftype=$(file -b "$i")
			local fstype=$(get_fstype "$i")

			#      array+=("$fpath" "$(printf "$sep%-8s$sep%-30s" "$fsize" "$ftype")")
			array+=("$fpath" "$(printf "$sep%-8s$sep%-8s$sep%-30s" "$fsize" "$fstype" "$ftype")")
			((++n))
			ntemp=$((${#fpath} + ${#fsize} + ${#ftype}))
			((ntemp > maxcols)) && ntemp=$maxcols
			((ntemp > ntam)) && ntam=$ntemp
		done
		((nlen += 3))
		((ntam -= 4))

		selected=$(${DIALOG} \
			--default-item "$imageselected" \
			--backtitle "$ccabec" \
			--title "${localtitle}" \
			--ok-label "${cmsg_Select[$LC_DEFAULT]}" \
			--cancel-label "${cmsg_button_voltar[$LC_DEFAULT]}" \
			--colors \
			--stdout \
			--extra-button \
			--extra-label "Info image" \
			--menu "\
${YELLOW}Imagens encontradas (.img, .raw, .qcow2]:${RESET}\n
$(replicate '─' $((maxcols - 4)))\n
$(printf "%-${nlen}s$sep%-8s$sep%-8s$sep%-30s" "PATH" "SIZE" "FS" "TYPE")" \
			15 $maxcols 0 "${array[@]}")

		exit_status=$?
		case $exit_status in
		"$D_ESC" | "$D_CANCEL")
			return 1
			;;
		3)
			result=$(file "$selected")
			result0=$(qemu-img info "$selected" 2>/dev/null || echo "No qemu-img info available")
			message=$(printf "\n\n%s\n\n%s" "$result" "$result0")
			display_result "Image info" \
				"${BOLD}${GREEN}${REVERSE}Info image : $selected${RESET}" \
				"${BOLD}${WHITE}$message"
			continue
			;;
		esac

		if [[ -n "$selected" ]]; then
			echo "$selected"
			break
			return 0
		fi
		break
	done
}

sh_clone_image_to_part() {
	image=$(sh_list_image "** IMAGENS em $PWD **") || return 1

	if sh_choose_target_partition; then
		sh_confclone "$part_source" "$target"
		sh_reset_conf
		:
	fi
}

sh_clone_part_to_image() {
	if sh_choose_source_partition; then
		sh_make_clone_part_to_image
		:
	fi
}

sh_make_clone_part_to_image() {
	local -i nchoice
	set -o pipefail

	if sh_conf_image_name "$source"; then
		# escolher formato
		#local image_format
		#image_format=$(sh_choose_image_format) || return 1

		local outfile="$cvdisk_name"

		if conf "${cwarning[$LC_DEFAULT]}" \
			"${cmsg_disco_origem[LC_DEFAULT]}: ${GREEN}$DEVICE_SOURCE | $SIZE_SOURCE | $MODEL_SOURCE${RESET}\n\
IMAGEM DESTINO : ${RED}$outfile\n\n" \
			"${BOLD}${YELLOW}${cmsg_continuar_com_a_clonagem[$LC_DEFAULT]}?\n"; then

			sh_start_time_elapsed
			mensagem "${cmsg_formatando_particao[$LC_DEFAULT]}: $source TO $outfile"

			# RAW simples com pv
			local src_size
			if [[ -b "$source" ]]; then
				src_size=$(sudo blockdev --getsize64 "$source")
			else
				src_size=$(stat -c%s "$source")
			fi

			SECTOR_SIZE=$(blockdev --getss $source)   # setor físico (4096)
			DISK_SIZE=$(blockdev --getsize64 $source) # tamanho em bytes

			(
				#       dd if="$source" bs=32M          conv=notrunc,noerror,sync status=none | pv --numeric --size "$src_size" > "$outfile"
				#       dd if="$source" bs=$SECTOR_SIZE conv=notrunc,noerror,sync status=none | pv --numeric --size "$src_size" > "$outfile"
				#       pv --numeric --size "$src_size" "$source" | dd of="$outfile" bs=32M conv=notrunc,noerror,sync status=none
				#       pv --numeric --size "$src_size" "$source" | dd of="$outfile" bs=32M conv=notrunc,noerror status=none
				pv --numeric --size "$src_size" "$source" >"$outfile"
			) 2>&1 |
				${DIALOG} \
					--title "${cmsg_running_disk_cloning[LC_DEFAULT]^^}" \
					--colors \
					--gauge \
					"${BOLD}${WHITE}${REVERSE}${cmsg_running_disk_cloning[LC_DEFAULT]} (pv → raw)${RESET}\n\n\
${cmsg_disco_origem[LC_DEFAULT]}: ${YELLOW}$DEVICE_SOURCE | $SIZE_SOURCE | $MODEL_SOURCE${RESET}\n\
IMAGEM DESTINO : ${RED}$outfile" \
					10 100 0
		fi
		nchoice=$?

		if [[ $image_format == "qcow2" ]]; then
			local tmp_raw="$outfile.tmp.raw"
			mv "$outfile" "$tmp_raw"

			# Infobox estilizado enquanto converte
			${DIALOG} --title "${cmsg_running_disk_cloning[LC_DEFAULT]^^}" --colors --infobox \
				"\
      ${BOLD}${WHITE}${REVERSE}Convertendo para QCOW2...${RESET}\n\n\
      ${BOLD}Origem (RAW):${RESET} ${YELLOW}$tmp_raw${RESET}\n\
      ${BOLD}Destino (QCOW2):${RESET} ${RED}$outfile${RESET}\n\n\
      Aguarde, esta operação pode levar alguns minutos..." 10 70

			# Conversão efetiva
			if qemu-img convert -p -O qcow2 "$tmp_raw" "$outfile" >/dev/null; then
				rm -f "$tmp_raw"
			fi
		fi

		sh_end_time_elapsed
		result="$(fdisk -b $SECTOR_SIZE -l $outfile)"
		message="$(printf "\n\n%s" "$result")"

		[[ $nchoice -eq 0 ]] && display_result \
			"fdisk -b $SECTOR_SIZE -l $outfile" \
			"${BOLD}${GREEN}${REVERSE}Clonagem concluída!${RESET}\n\n" \
			"${BOLD}${GREEN}${REVERSE}Info disk : $outfile${RESET}\n" \
			"${BOLD}${WHITE}$message\n\n" \
			"Start Date time  : ${BOLD}${BLUE}$start_datetime${RESET}\n" \
			"Finish Date Time : ${BOLD}${BLUE}$end_datetime${RESET}\n" \
			"Time elapsed     : ${BOLD}${GREEN}$(sh_time_elapsed)${RESET}\n"
		return $nchoice
	fi
}

sh_clone_disk_to_disk() {
	if sh_choose_source_disk; then
		if sh_choose_target_disk; then
			:
		fi
	fi
}

sh_choose_source_disk() {
	local localtitle="${cmsg_disco_origem[$LC_DEFAULT]}"
	local disk_selected=""

	source=$(sh_list_disk "${localtitle}" "${disk_selected}")
	if [[ -n "$source" ]]; then
		sh_disk_info
		DEVICE_SOURCE="$source"
		MODEL_SOURCE="$(sh_splitarray "${AARRAY_DSK_DEVICES[$source]}" "$DSK_MODEL")"
		NAME_TARGET="$(sh_splitarray "${AARRAY_DSK_DEVICES[$source]}" "$DSK_NAME")"
		SIZE_SOURCE="$(sh_splitarray "${AARRAY_DSK_DEVICES[$source]}" "$DSK_SIZE")"
		return 0
	fi
	return 1
}

sh_choose_target_disk() {
	local localtitle="${cmsg_disco_destino[$LC_DEFAULT]}"
	local disk_selected="$source"

	target=$(sh_list_disk "${localtitle}" "${disk_selected}")
	if [ "$source" == "$target" ]; then
		alerta "${cwarning[$LC_DEFAULT]}" "\n   \Z1${cmsg_disco_identico[$LC_DEFAULT]} \n\n      \Z4SOURCE DISK : \Z1\Zr$MODEL_SOURCE\ZR\n \Z4DISK TARGET : \Z1\Zr$MODEL_TARGET\ZR"
		sh_choose_target_disk
	fi

	if [[ -n "$target" ]]; then
		sh_disk_info
		DEVICE_TARGET="$target"
		MODEL_TARGET="$(sh_splitarray "${AARRAY_DSK_DEVICES[$target]}" "$DSK_MODEL")"
		NAME_TARGET="$(sh_splitarray "${AARRAY_DSK_DEVICES[$target]}" "$DSK_NAME")"
		SIZE_TARGET="$(sh_splitarray "${AARRAY_DSK_DEVICES[$target]}" "$DSK_SIZE")"

		if [[ "$(sh_toBytes "$SIZE_SOURCE")" -gt "$(sh_toBytes "$SIZE_TARGET")" ]]; then
			if ! conf "${YELLOW}${cwarning[$LC_DEFAULT]}" \
				"\n${BOLD}${RED}${REVERSE}$(gettext "O disco de DESTINO é menor que o disco de ORIGEM")${RESET}\n\n" \
				"${BOLD}${WHITE}${cmsg_disco_origem[LC_DEFAULT]} : $DEVICE_SOURCE | $SIZE_SOURCE | $MODEL_SOURCE\n" \
				"${BOLD}${WHITE}${cmsg_disco_destino[LC_DEFAULT]}: $DEVICE_TARGET | $SIZE_TARGET | $MODEL_TARGET${RESET}\n\n" \
				"${YELLOW}$(gettext "Prosseguir?")"; then
				#				init
				return
			fi
		fi

		sh_backup_partitions "$target" "$NAME_TARGET"
		if ! sh_checkdisk "$target"; then
			alerta "CHOOSEDISK" "${cmsg_nec_dismount[LC_DEFAULT]}"
			die "ERRO: ${cmsg_nec_dismount[LC_DEFAULT]}"
		fi
		sh_confclone "$source" "$target"
		sh_reset_conf
	fi
}

sh_choose_source_partition() {
	local localtitle="${cmsg_part_origem[$LC_DEFAULT]}"
	local part_selected=

	part_source=$(sh_list_partition "${localtitle}" "${part_selected}")

	if [[ -n "$part_source" ]]; then
		sh_part_info
		DEVICE_SOURCE="$part_source"
		MODEL_SOURCE="$(sh_splitarray "${AARRAY_DSK_DEVICES[$part_source]}" "$DSK_MODEL")"
		NAME_SOURCE="$(sh_splitarray "${AARRAY_DSK_DEVICES[$part_source]}" "$DSK_NAME")"
		SIZE_SOURCE="$(sh_splitarray "${AARRAY_DSK_DEVICES[$part_source]}" "$DSK_SIZE")"
		return 0
	fi
	return 1
}

sh_choose_target_partition() {
	local localtitle="${cmsg_part_destino[$LC_DEFAULT]}"
	local part_selected="$part_source"

	part_target=$(sh_list_partition "${localtitle}" "${part_selected}")
	if [ "$part_source" == "$part_target" ]; then
		alerta "${cwarning[$LC_DEFAULT]}" "\n   \Z1${cmsg_disco_identico[$LC_DEFAULT]} \n\n      \Z4SOURCE DISK : \Z1\Zr$MODEL_SOURCE\ZR\n \Z4DISK TARGET : \Z1\Zr$MODEL_TARGET\ZR"
		sh_choose_target_partition
	fi

	if [[ -n "$part_target" ]]; then
		sh_part_info
		DEVICE_TARGET="$part_target"
		MODEL_TARGET="$(sh_splitarray "${AARRAY_DSK_DEVICES[$part_target]}" "$DSK_MODEL")"
		NAME_TARGET="$(sh_splitarray "${AARRAY_DSK_DEVICES[$part_target]}" "$DSK_NAME")"
		SIZE_TARGET="$(sh_splitarray "${AARRAY_DSK_DEVICES[$part_target]}" "$DSK_SIZE")"

		if [[ "$(sh_toBytes "$SIZE_SOURCE")" -gt "$(sh_toBytes "$SIZE_TARGET")" ]]; then
			if ! conf "${YELLOW}${cwarning[$LC_DEFAULT]}" \
				"\n${BOLD}${RED}${REVERSE}$(gettext "O disco de DESTINO é menor que o disco de ORIGEM")${RESET}\n\n" \
				"${BOLD}${WHITE}${cmsg_part_origem[LC_DEFAULT]} : $DEVICE_SOURCE | $SIZE_SOURCE | $MODEL_SOURCE ${RESET} \n" \
				"${BOLD}${WHITE}${cmsg_part_destino[LC_DEFAULT]}: $DEVICE_TARGET | $SIZE_TARGET | $MODEL_TARGET ${RESET} \n\n" \
				"${YELLOW}$(gettext "Prosseguir?")"; then
				return 1
			fi
		fi
		sh_backup_partitions "$part_target" "$NAME_TARGET"
		if ! sh_checkdisk "$part_target"; then
			alerta "CHOOSEDISK" "${cmsg_nec_dismount[LC_DEFAULT]}"
			die "ERRO: ${cmsg_nec_dismount[LC_DEFAULT]}"
		fi
		return 0
	fi
	return 1
}

sh_reset_conf() {
	source=
	target=
}

sh_backup_partitions() {
	if [ $# -ge 2 ]; then
		local disk="${1}"
		local device="${2}"
		local tmpdir="/tmp/$_APP_"
		local cdatetime
		local filetmp

		cdatetime=$(sh_diahora)
		filetmp="$tmpdir/${device}.$cdatetime.dump"
		log_exec mkdir -p "$tmpdir"
		log_exec sfdisk -d "$disk" >"$filetmp"
		#  info "BACKUP DA TABELA DE PARTICOES"    \
		#         "Dispositivo : $disk"              \
		#         "  Backup on : ${filetmp}"         \
		#        "$(replicate "=" 80)"               \
		#         "$(cat $filetmp)"
	fi
}

sh_confclone() {
	source="$1"
	local target="$2"

	if conf "${cwarning[$LC_DEFAULT]}" \
		"\n${cmsg_todos_os_dados_serao_perdidos[$LC_DEFAULT]}\n\n""\
${BLUE} ${cmsg_disco_origem[LC_DEFAULT]}:  $DEVICE_SOURCE | $SIZE_SOURCE | $MODEL_SOURCE \n" \
		"${RED}${cmsg_disco_destino[LC_DEFAULT]}: $DEVICE_TARGET | $SIZE_TARGET | $MODEL_TARGET\n\n" \
		"${BOLD}${WHITE}${cmsg_continuar_com_a_clonagem[$LC_DEFAULT]}?\n"; then
		sh_domakeclone "$source" "$target"
		return "$?"
	fi
	return 1
}

sh_domakeclone() {
	local source="$1"
	local target="$2"
	local -i nchoice

	mensagem "${cmsg_formatando_particao[$LC_DEFAULT]}: $source TO $target"
	(pv -n "$source" |
		dd of="$target" conv=notrunc,noerror) 2>&1 |
		${DIALOG} \
			--title "${cmsg_running_disk_cloning[LC_DEFAULT]^^}" \
			--colors \
			--gauge \
			"${BOLD}${WHITE}${REVERSE}${cmsg_running_disk_cloning[LC_DEFAULT]} (dd if=$source of=$target bs=4MB conv=notrunc,noerror,sync iflag=fullblock oflag=direct)${RESET}\n\n\
${cmsg_disco_origem[LC_DEFAULT]}:  ${YELLOW}$DEVICE_SOURCE | $SIZE_SOURCE | $MODEL_SOURCE${RESET}\n\
${cmsg_disco_destino[LC_DEFAULT]}: ${RED}$DEVICE_TARGET | $SIZE_TARGET | $MODEL_TARGET" \
			10 100 0
	nchoice=$?
	result=$(fdisk -l "$target")
	message=$(printf "\n\n%s" "$result")
	[[ $nchoice -eq 0 ]] && display_result "fdisk -l $target" \
		"${BOLD}${GREEN}${REVERSE}$(gettext "Clonagem concluída!")" \
		"${RESET}${BOLD}${WHITE}$message"
	return $nchoice
}

sh_Language() {
	cmsg_nec_dismount[pt_BR]=$(gettext "Necessário desmontar a partição antes de reparticionar")
	cwarning[pt_BR]=$(gettext "** AVISO **")
	cmsg_all_mounted_part[pt_BR]=$(gettext "Necessário desmontar as partições abaixo antes de prosseguir")
	cmsg_dismount[pt_BR]=$(gettext "Desmontar ?")
	cmsg_Error[pt_BR]=$(gettext "ERRO")
	cmsg_info_disco[pt_BR]=$(gettext "Info disco")
	cmsg_Ok[pt_BR]=$(gettext "Ok")
	cmsg_disco_destino[pt_BR]=$(gettext "DISCO DE DESTINO")
	cmsg_choose_disk_origem[pt_BR]=$(gettext "Escolha o disco ORIGEM")
	cmsg_choose_disk_destino[pt_BR]=$(gettext "Escolha o disco DESTINO")
	cmsg_choose_part_origem[pt_BR]=$(gettext "Escolha a partição ORIGEM")
	cmsg_choose_part_destino[pt_BR]=$(gettext "Escolha a partição DESTINO")
	cmsg_yeslabel[pt_BR]=$(gettext "Sim")
	cmsg_nolabel[pt_BR]=$(gettext "Não")

	cLB1=$(gettext "Use as teclas")
	cLB2=$(gettext "PARA CIMA")
	cLB3=$(gettext "e")
	cLB4=$(gettext "PARA BAIXO")
	cLB5=$(gettext "para navegar")
	cLB6=$(gettext "Use")
	cLB7=$(gettext "para alternar entre os botões")
	cLB8=$(gettext "para selecionar")
	cmsg_LABEL[pt_BR]="$cLB1${BLUE} ↑ $cLB2$RESET $cLB3 ${BLUE}↓ $cLB4$RESET $cLB5\n$cLB6${BLUE} TAB${RESET} $cLB7${BLUE} ENTER${RESET} $cLB8"

	cmsg_disco_identico[pt_BR]=$(gettext "Disco ORIGEM e DESTINO não podem ser o mesmo")
	cmsg_formatando_particao[pt_BR]=$(gettext "Formatando partição")
	cmsg_running_disk_cloning[pt_BR]=$(gettext "Executando clonagem de disco")
	cmsg_Select[pt_BR]=$(gettext "Selecionar")
	cmsg_Sair[pt_BR]=$(gettext "Sair")
	cmsg_button_voltar[pt_BR]=$(gettext "Voltar")
	cmsg_disco_origem[pt_BR]=$(gettext "DISCO DE ORIGEM")
	cmsg_disco_destino[pt_BR]=$(gettext "DISCO DE DESTINO")
	cmsg_part_origem[pt_BR]=$(gettext "PARTIÇÃO DE ORIGEM")
	cmsg_part_destino[pt_BR]=$(gettext "PARTIÇÃO DE DESTINO")
	cmsg_todos_os_dados_serao_perdidos[pt_BR]="  ${RED}$(gettext "AVISO!")${RESET}  $(gettext "Todos os dados disco/partição de DESTINO abaixo serão perdidos!")"
	cmsg_continuar_com_a_clonagem[pt_BR]=$(gettext "Continuar com a clonagem")
}

init() {
	while true; do
		i18=$(${DIALOG} \
			--stdout \
			--clear \
			--backtitle "$ccabec" \
			--title "${welcome}${xapp}" \
			--ok-label "${cmsg_Ok[$LC_DEFAULT]}" \
			--cancel-label "${cmsg_Sair[$LC_DEFAULT]}" \
			--menu "\n$(gettext "Escolha o idioma:")" \
			0 80 0 \
			0 "$(gettext "Português")" \
			1 "$(gettext "Inglês")" \
			2 "$(gettext "Alemão")" \
			3 "$(gettext "Francês")")

		exit_status=$?
		case $exit_status in
		"$D_ESC" | "$D_CANCEL")
			exit 0
			;;
		esac
		LC_DEFAULT=$i18
		sh_choose_clone_type
	done
}

#figlet
sh_logo() {
	printf '%s' "$green"
	cat <<'EOF'
      _                      _ _     _
  ___| | ___  _ __   ___  __| (_)___| | __   Copyright (c) 2019-2025 Vilmar Catafesta <vcatafesta@gmail.com>
 / __| |/ _ \| '_ \ / _ \/ _` | / __| |/ /   Copyright (c) 2019-2025 ChiliLinux Development Team
| (__| | (_) | | | |  __/ (_| | \__ \   <
 \___|_|\___/|_| |_|\___|\__,_|_|___/_|\_\   $(gettext "Este programa pode ser redistribuído livremente")
                                             $(gettext "sob os termos da Licença Pública Geral GNU")
EOF
	sh_version
}

sh_usage() {
	printf '%s\n' "${cyan}$(gettext "Comandos mais usados:")"
	printf '%s\n' "${red}	-h  ${reset}- $(gettext "exibir esta ajuda e sair")"
	printf '%s\n' "${red}	-v  ${reset}- $(gettext "mostrar versão")"
	printf '%s\n' "${red}	-c  ${reset}- $(gettext "suprime colorização da saída")"
}

if [[ $1 = "-v" || $1 = "--version" || $1 = "-V" ]]; then
	sh_logo
	exit 0
fi

sh_checkrootOLD() {
	[[ $1 = "-Qq" ]] && return
	if [ "$(id -u)" != "0" ]; then
		printf "${red}%s\n" "$(gettext "erro: Você não pode executar esta operação a menos que seja root!")"
		exit 1
	fi
}

sh_checkroot() {
	if [[ "$(id -u)" != "0" ]]; then
		elevate_to_root "$@"
	fi
	ccabec+=' [root]'
}

log_err() {
	printf " %b %s\\n" "${CROSS}" "${*}"
}

elevate_to_root() {
	log_err "This script must be run as root. Elevating privileges..."

	# Tenta usar sudo primeiro (caso esteja configurado)
	if command -v sudo >/dev/null 2>&1; then
		exec sudo bash "$0" "$@"
	fi

	# Se sudo falhar, tenta su
	if command -v su >/dev/null 2>&1; then
		exec su -c "$0 $*"
	fi
	die "Error: Unable to elevate privileges. Run manually as root."
}

DOT() {
	printf "%s" "${blue}:: ${reset}"
}

die() {
	local msg=$1
	shift
	printf "%-75s\n" "$(DOT)${bold}${red}$msg${reset}" >&2
	exit 1
}

log_msg() {
	local retval="${PIPESTATUS[0]}"

	if [[ $retval -eq 0 ]]; then
		printf " %b %s\\n" "${TICK}" "${*}"
	else
		printf " %b %s\\n" "${CROSS}" "${*}"
	fi
}

run_dialog_stream() {
  local title="$1"; shift
    stdbuf -oL -eL "$@" 2>&1 \
        | dialog \
    		--backtitle "$ccabec" \
            --progressbox "$title" 20 70
  local status=${PIPESTATUS[0]}
  return "$status"
}

sh_setup() {
	local DISTRO=$(detect_distro)
	msg "$_APP_" "Instalando necessários pacotes"

	case "$DISTRO" in
	void | voidlinux | void-live)
		if ! run_dialog_stream "Instalando pacoates no ${DISTRO^^}" \
			xbps-install -Sy "${PACKAGEDEP[@]}"; then
			die "[ERRO] Falha ao instalar pacotes."
		fi
		;;
	chili | chililinux | arch | manjaro | biglinux)
		if ! run_dialog_stream "Instalando pacoates no ${DISTRO^^}" \
			pacman -S --neeeded --quiet --noconfirm "${PACKAGEDEP[@]}"; then
			die "[ERRO] Falha ao instalar pacotes."
		fi
		;;
	manjaro) : ;;
	debian) : ;;
	ubuntu) : ;;
	ubuntu) : ;;
	fedora) : ;;
	endeavouros) : ;;
	*)
		echo "Outra distro: $DISTRO"
		;;
	esac
}

sh_checkDependencies() {
	local aBlock_files=()
	local d
	local errorFound=false
	declare -a missing

	for d in "${DEPENDENCIES[@]}"; do
		if ! command -v "$d" &>/dev/null; then
			log_err "Check: ${red}ERROR${reset}: $(gettext "Não foi possível encontrar o comando") ${cyan}'$d'${reset} -> $(gettext "instalar pacote") ${cyan}"${PACKAGEDEP[$d]}"${reset}"
			missing+=("$d")
			errorFound=true
		else
			#     log_msg "Check: ${cyan}$d"
			:
		fi
	done

	if $errorFound; then
		replicate '='
		echo "${yellow}             $(gettext "IMPOSSÍVEL CONTINUAR")"
		echo "${black}$(gettext "Este script precisa dos comandos listados acima")"
		echo "${black}$(gettext "Instale-os e/ou verifique se eles estão em seu") ${red}\$PATH${reset}"
		replicate '='
		#die $(gettext "Abortando...")
		if readconf "Deseja instalar os pacotes e suprir os aplicativos necessários ?"; then
			sh_setup
		else
			exit 1
		fi
	fi
}
export -f sh_checkDependencies

sh_display() {
	if [[ "$(tput cols)" -lt 80 ]] || [[ "$(tput lines)" -lt 24 ]]; then
		dialog --backtitle "$ccabec" \
			--title "$(gettext "TERMINAL MUITO PEQUENO")" \
			--msgbox "\n\
$(gettext "Antes de continuar, redimensione seu terminal\npara que ele meça pelo menos 80 x 24 caracteres")\n\
$(gettext "Caso contrário, você não poderá usar as ferramentas de partição de disco")" 11 68
	fi
}

sh_execute_iso2usb() {
	if command -v chili-iso2usb >/dev/null; then
		bash chili-iso2usb
	fi
	return
}

#				--keep-tite \
sh_choose_clone_type() {
	while true; do
		clone_type=$(
			${DIALOG} \
				--clear \
				--stdout \
				--aspect 20 \
				--default-item "$LC_DEFAULT" \
				--backtitle "$ccabec" \
				--colors \
				--title "MENU" \
				--ok-label "${cmsg_Select[$LC_DEFAULT]}" \
				--cancel-label "${cmsg_Sair[$LC_DEFAULT]}" \
				--menu "${cmsg_LABEL[$LC_DEFAULT]}\n\n${YELLOW}$(gettext "Escolha o tipo de clone"):${RESET}" \
				10 80 0 \
				0 "$(gettext "Clonar Disco para Disco")" \
				1 "$(gettext "Clonar Disco para Imagem")" \
				2 "$(gettext "Clonar Partição para Imagem")" \
				3 "$(gettext "Clonar Partição para Partição")" \
				4 "$(gettext "Clonar Imagem para Partição")" \
				5 "$(gettext "Gravar ISO para Disco")" \
				6 "$(gettext "Listar Discos")"
		)

		exit_status=$?
		case $exit_status in
		"$D_ESC" | "$D_CANCEL")
			exit 0
			;;
		esac
		case $clone_type in
		0) sh_clone_disk_to_disk ;;
		1) sh_clone_disk_to_image ;;
		2) sh_clone_part_to_image ;;
		3) sh_clone_part_to_part ;;
		4) sh_clone_image_to_part ;;
		5) sh_execute_iso2usb ;;
		6) sh_list_disk ;;
		esac
	done
}

sh_configure
sh_getLocale
sh_Language
sh_display

#opts=$(getopt -o vnh: --long version,nocolor,help:,debugfile:,minheap:,maxheap: -n 'clonedisk' -- "$@")
#if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 1 ; fi
if ! opts=$(getopt -o Vnh --long version,nocolor,help -n "${0##*/}" -- "$@"); then
	sh_usage
	exit 0
fi
eval set -- "$opts"
while true; do
	case "$1" in
	-V | --version)
		sh_logo
		exit 0
		;;
	-n | --nocolor)
		sh_unsetvarcolors
		break
		;;
	-h | --help)
		sh_usage
		exit 0
		;;
	*) break ;;
	esac
done
sh_checkroot "$@"
sh_checkDependencies "${DEPENDENCIES[*]}"
#init "$@"
sh_choose_clone_type
