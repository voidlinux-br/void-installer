#!/usr/bin/env bash
#shellcheck disable=SC2034,SC2015,SC2154,SC2140,SC2016,SC2153,SC2068,SC2155,SC2059
#shellcheck source=/dev/null

# 	fetch - search, install, create, remove, upgrade packages compatible with:
# 	Chili GNU/Linux - https://github.com/vcatafesta/ChiliOS
#	Chili GNU/Linux - https://chililinux.com
#	Chili GNU/Linux - https://chilios.com.br
# 	MazonOS GNU/Linux - http://mazonos.com
#
# 	Created: 2019/04/05
# 	Altered: 2023/09/22
#
# 	Copyright (c) 2019-2022, Vilmar Catafesta <vcatafesta@gmail.com>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

# 	fetch uses quite a few external programs during its execution. You
# 	need to have at least the following installed for makepkg to function:
#  	awk, bsdtar (libarchive), bzip2, coreutils, fakeroot, file, find (findutils),
#   	gettext, gpg, grep, gzip, sed, tput (ncurses), xz
# 	contains portion of software https://bananapkg.github.io/
#########################################################################
#debug
export PS4='${red}${0##*/}${green}[$FUNCNAME]${pink}[$LINENO]${reset} '
#set -x
#set -e
shopt -s extglob

# Import lib
readonly _VERSION_="3.44.20230922"
#LIBRARY=${LIBRARY:-'/usr/share/fetch'}
#[[ -f "${LIBRARY}/core.sh" ]] && source "${LIBRARY}/core.sh"
SYSCONFDIR=${SYSCONFDIR:-'/etc/fetch'}

# var bool
declare -gi ERR_OK=0
declare -gi ERR_ERROR=1
declare -gi true=1
declare -gi false=0
declare -gi LINSTALLED=2
declare -gi ncount=0
declare -gi njobs_alien=5

sh_setEnvironment() {
	sh_setvarcolors
	export LC_ALL=C
	export LANG=C
	readonly DEPENDENCIES=(which find tar zstd curl sed sort grep cat awk tput stat tee lynx numfmt gettext parallel)
	readonly BOOTLOG="/tmp/fetch-$(sh_diahora).log"
	readonly LOGGER='/dev/tty8'
	unset CDPATH
	unset GREP_OPTIONS

	[[ -s "$SYSCONFDIR/fetch.conf" ]] || sh_touchconf
	[[ -s "$SYSCONFDIR/fetch.conf" ]] && source "$SYSCONFDIR/fetch.conf" || return 1

	# files
	export FOLDERS_METAPACKAGES='folders_metapackages.csv'
	export METAPACKAGES='metapackages.csv'
	export PACKAGES_SPLIT='packages-split.csv'
	export PACKAGES_INSTALLED_SPLIT='packages-installed-split.csv'
	export PACKAGES_IN_CACHE='packages-in-cache.csv'

	#var public
	declare -ga public_pkg_not_found=()
	declare -ga public_pkg=()
	declare -ga public_pkg_deps=()
	declare -ga public_ListSearch=()
	declare -gi public_ntotal_pkg_installed=0
	declare -gi public_ntotal_pkg_listed=0
	declare -gi public_len_count_pkg=0

	# default
	export PKG_EXT
	export SEP
	export SITE
	export GITSITE
	export RAW
	export APP
	export CACHEDIR
	export CACHEDIR_ARCHIVES
	export CACHEDIR_SEARCH
	export CACHEDIR_LIST
	export CACHEDIR_DESC
	export CACHEDIR_REMO
	export VARLIB_FETCH
	export DESCME
	export ALIEN_CACHE_DIR="${ALIEN_CACHE_DIR:=/var/cache/pacman/pkg}"
	export ALIEN_VARLIB="/var/lib/pacman/local"

	# Número máximo de processos paralelos
	#	export MAX_PARALLEL=36
	export MAX_PARALLEL=80%

	export verbose=0
	export SEP=','
	: "${PKG_EXT:='chi.zst'}" # se PKG_EXT não estiver definida, recebe 'chi.zst'
	: "${GITSITE:=0}"         # se GITSITE não estiver definida, recebe 0
	export SITE="${PKG_SITE:=https://chililinux.com}"
	export RAW="${PKG_RAW:=https://raw.githubusercontent.com/vcatafesta/ChiliOS/master}"
	export APP="fetch"
	export APP="${0##*/}"
	export CACHEDIR="${CACHEDIR:=/var/cache/$APP}"
	export CACHEDIR_ARCHIVES="$CACHEDIR/archives"
	export CACHEDIR_SEARCH="$CACHEDIR/search"
	export CACHEDIR_LIST="$CACHEDIR/list"
	export CACHEDIR_DESC="$CACHEDIR/desc"
	export CACHEDIR_REMO="$CACHEDIR/remove"
	export DESCME='info/desc'
	export VARLIB_FETCH="/var/lib/$APP"
	export CHILI_OS=$true

	# flag's para split package
	declare -ga aPKGARRAY=()
	declare -ga aPKGSPLIT=()
	export aPKGLIST
	export PKG_FOLDER_DIR=0
	export PKG_FULLNAME=1
	export PKG_ARCH=2
	export PKG_BASE=3
	export PKG_BASE_VERSION=4
	export PKG_VERSION=5
	export PKG_BUILD=6

	if [[ -z "${COLUMNS}" ]]; then
		COLUMNS=$(stty size)
		COLUMNS=${COLUMNS##* }
	fi
	if [[ "${COLUMNS}" = "0" ]]; then
		COLUMNS=80
	fi
	COL=$((COLUMNS - 8))
	SET_COL="\\033[${COL}G" # at the $COL char
	CURS_ZERO="\\033[0G"
	#	CURS_ZERO="$(tput sc;tput cr)"

	#temporary
	export TMP_DIR_ROOT="$(mktemp -d -u)"
	export TMP_DIR_BACKUP="$TMP_DIR_ROOT/$APP/$CACHEDIR_SEARCH"
	export TMP_DIR_FOLDERS="$TMP_DIR_ROOT/$APP/$CACHEDIR/folders"

	# regex's
	#DATE_RE='(\d{4}-\d{2}-\d{2}\s\d{2}:\d{2})'	#2022-03-16 14:22
	#RE_ALIEN='.+\.zst$|.+\.xz$' 						#VC
	#RE_ALIEN='.+\.[zst|xz]+$'  						#VC
	export RE_ALIEN='.+\.(zst|xz)$' #Bagatini/Blau

	if [[ "$PKG_EXT" = "chi.zst" ]]; then
		export CHILI_OS=$true
		#PKG_RE='^([a-z-]+)(-)([0-9\\.]+)(-)([0-9])(-)(.*)(.chi.zst)$'
		#PKG_RE='([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*)-(([0-9]+(\.[0-9]+)*)(-([0-9]+))?)-([^.]+).*'
		#PKG_RE='(.+)-(([^-]+)-([0-9]+))-([^.]+)\.chi\.zst' 				#SOEN
		#		PKG_RE='(.+)-(([^-]+)-([0-9]+))-([^.]+)\.chi\.zst'    			#VC
		export PKG_RE='(.+)-(([^-]+)-([0-9]+))-([^.]+)(\.chi\.zst)$' #VC
		#		PKG_RE_LYNX='(?!.*\/)(.*)-(([^-]+)-([0-9]+))-([^.]+)(\.chi\.zst)$'
		#		PKG_RE_FULL1='(?:")(.+)-(([^-]+)-([0-9]+))-([^.]+)\.chi\.zst(?="><a)'
		#		PKG_RE_FULL2='(?:e">)(.+)-(([^-]+)-([0-9]+))-([^.]+)(\.chi)(\.zst)(?=<\/a)'
		GREP_RE='.chi\.zst\"'
		#SED_RE='^.+>(.+)-(([^-]+)-([0-9]+))-([^.]+)(.chi.zst)<.a>.*([0-9]{4}-[0-9]{2}-[0-9]{2}|[0-9]{2}-[A-z]{3}-[0-9]{4})[ ]([0-9]{2}:[0-9]{2}).*[ ]([0-9]+k?)(.*)'
		#SED_RE='^.+="(.+)-(([^-]+)-([0-9]+))-([^.]+)(.chi.zst)".+<.a>.*([0-9]{4}-[0-9]{2}-[0-9]{2}|[0-9]{2}-[A-z]{3}-[0-9]{4})[ ]([0-9]{2}:[0-9]{2}).+[ ]([0-9]+k?)(.*)'
		export SED_RE='^.*["|\/](.+)-(([^-]+)-([0-9]+))-([^.]+)(.chi.zst)".+<.a>.*([0-9]{4}-[0-9]{2}-[0-9]{2}|[0-9]{2}-[A-z]{3}-[0-9]{4})[ ]([0-9]{2}:[0-9]{2}).+[ ]([0-9]+k?).*'
		#		FETCH_RE='-[^a-z]+?[^-]+-[0-9].*-'
		#		FETCH_RE='-[^-]+-[0-9]-'
		#		FETCH_RE='-[^-]+[0-9]+-[^.]+.chi.*'
		#		FETCH_RE='-[^-]+[0-9]+[^.]*\.chi[^.]*\.zst'
		export FETCH_RE='-[^-]+[0-9]+[^.]*.chi[^.]*.zst'
	else
		export CHILI_OS=$false
		#PKG_RE='(.+)-(([^-]+)-([0-9]+))\.mz' 						#SOEN
		export PKG_RE='(.+)-(([^-]+)-([0-9]))\.mz' #VC
		#		PKG_RE_LYNX='(?!.*\/)(.+)-(([^-]+)-([0-9]))\.mz$'		#VC
		export GREP_RE='.mz\"'
		#		SED_RE='^.+href="(.+)-(([^-]+)-([0-9]))()(\.mz\b)".+([0-9]{4}-[0-9]{2}-[0-9]{2}|[0-9]{2}-[A-z]{3}-[0-9]{4})[ ]([0-9]{2}:[0-9]{2})[ ]+([0-9]+[.]?[0-9]+.?).+'
		export SED_RE='^.+href="(.+)-(([^-]+)-([0-9]))()(\.mz\b)".+([0-9]{4}-[0-9]{2}-[0-9]{2}|[0-9]{2}-[A-z]{3}-[0-9]{4})[ ]([0-9]{2}:[0-9]{2})[ ]+([0-9]?[.]?[0-9]?.?).+'
		#		SED_RE='^.+href="(.+)-(([^-]+)-([0-9]))()(\.mz\b)".+([0-9]{4}-[0-9]{2}-[0-9]{2}|[0-9]{2}-[A-z]{3}-[0-9]{4})[ ]([0-9]{2}:[0-9]{2})[ ]+([0-9.])+([BKMGT]?)\b'
		#		SED_RE='^.+href="(.+)-(([^-]+)-([0-9]))()(\.mz\b)".+([0-9]{4}-[0-9]{2}-[0-9]{2}|[0-9]{2}-[A-z]{3}-[0-9]{4})[ ]([0-9]{2}:[0-9]{2})[ ]+([0-9.]+)+([BKMGT])?'
		export SED_RE='^.+href="(.+)-(([^-]+)-([0-9]))()(\.mz\b)".+([0-9]{4}-[0-9]{2}-[0-9]{2}|[0-9]{2}-[A-z]{3}-[0-9]{4})[ ]([0-9]{2}:[0-9]{2})[ ]+(([0-9]+)([BKMGT]?)).+'
		export FETCH_RE='-[^-]+-[0-9]+[.]'
	fi
}

###########################################################################################################################################################################################################
function toupper() {
	declare -u TOUPPER=${*}
	echo -e "${TOUPPER}"
}
function tolower() {
	declare -l TOLOWER=${*}
	echo -e "${TOLOWER}"
}
function toupperA() { tr '[:lower:]' '[:upper:]' <<<"$1"; }
function tolowerA() { tr '[:upper:]' '[:lower:]' <<<"$1"; }
function sh_linecount() { awk 'END {print NR}' "$1"; }
function strzero() { printf "%0*d" "$2" "$1"; }
export -f strzero
function DOT() { printf "%s" "${blue}:: ${reset}"; }
function info_msg() { printf "%s" "\033[1m$*\n\033[m"; }
function sizeof_du() { du -bs $1 | cut -f1; }
function lenarray() { sh_linecount <<<"$(printf "%s\n" "$*")"; }
function arraylen() {
	local new=("$@")
	echo "${#new[*]}"
}

function sh_diahora() {
	DIAHORA=$(date +"%d%m%Y-%T" | sed 's/://g')
	printf "%s\n" "$DIAHORA"
}

function fmtplus() {
	printf "${bold}${yellow}%03d/%03d${reset}" "$ncounter" "$ncounter"
	return $?
}

function fmt() {
	printf "%s" "${pink}($ncount:$njobs_alien/$ntotalpkg:$ntotalfindpkgs)${reset}"
	return $?
}
export -f fmt

function print() {
	[[ "$printyeah" = '1' ]] && echo -e "$@"
}

function conf() {
	read -p "$1 [Y/n]"
	[[ ${REPLY^} == "" ]] && return $true
	[[ ${REPLY^} == N ]] && return $false || return $true
}

function readconf() {
	if [[ $LC_DEFAULT -eq 0 ]]; then
		read -r -p "$* [S/n]"
	else
		read -r -p "$* [Y/n]"
	fi
	[[ ${REPLY^} == "" ]] && return 0
	[[ ${REPLY^} == N ]] && return 1 || return 0
}

function confok() {
	read -p "$1 [Y/n]"
	[[ ${REPLY^} == "" ]] && return $true
	[[ ${REPLY^} == N ]] && return $false || return $true
}

function confno() {
	read -p "$1 [N/y]"
	[[ ${REPLY^} == "" ]] && return 0
	[[ ${REPLY^} == N ]] && return 0 || return 1
}

#function die() {
#	local msg=$1
#	[[ $# -ge 2 ]] && evaluate_retval 1
#	shift
#	printf "%-75s\n" "$(DOT)${bold}${red}${msg}${reset}" >&2
#	exit 1
#}

function die() {
	local msg=$1
	local retval="${PIPESTATUS[0]}"
	local pcount=$#

	((pcount >= 2)) && {
		retval=$2
		#		shift
	}
	if [[ $retval -eq 0 ]]; then
		printf " %b %s\\n" "${TICK}" "${msg}"
	else
		printf " %b %s\\n" "${CROSS}" "${msg}"
		exit 1
	fi
}

sh_setLogPrefix() {
	COL_NC='\e[0m' # No Color
	COL_LIGHT_GREEN='\e[1;32m'
	COL_LIGHT_RED='\e[1;31m'
	TICK="${white}[${COL_LIGHT_GREEN}✓${COL_NC}${white}]"
	CROSS="${white}[${COL_LIGHT_RED}✗${COL_NC}${white}]"
	INFO="[i]"
	# shellcheck disable=SC2034
	DONE="${COL_LIGHT_GREEN} done!${COL_NC}"
	OVER="\\r\\033[K"
	NORMAL="${reset}"
	SUCCESS="${green}"
	WARNING="${yellow}"
	FAILURE="${red}"
	INFO="${cyan}"
	BRACKET="${blue}"
	BMPREFIX="     "
	DOTPREFIX="  ${blue}::${reset} "
	#  SUCCESS_PREFIX="${SUCCESS}  ↑  ${NORMAL}"
	SUCCESS_PREFIX=" $TICK "
	SUCCESS_SUFFIX="${BRACKET}[${SUCCESS}  OK  ${BRACKET}]${NORMAL}"
	#  FAILURE_PREFIX="${FAILURE}  ↓  ${NORMAL}"
	FAILURE_PREFIX=" $CROSS "
	FAILURE_SUFFIX="${BRACKET}[${FAILURE} FAIL ${BRACKET}]${NORMAL}"
	WARNING_PREFIX="${WARNING}  W  ${NORMAL}"
	WARNING_SUFFIX="${BRACKET}[${WARNING} WARN ${BRACKET}]${NORMAL}"
	SKIP_PREFIX="${INFO}  S  ${NORMAL}"
	SKIP_SUFFIX="${BRACKET}[${INFO} SKIP ${BRACKET}]${NORMAL}"
	WAIT_PREFIX="${WARNING}  R  ${NORMAL}"
	WAIT_SUFFIX="${BRACKET}[${WARNING} WAIT ${BRACKET}]${NORMAL}"
}

function replicate() {
	local Var
	printf -v Var %"$2s" " "
	echo "${Var// /$1}"
}

function timespec() {
	STAMP="$(date +"%b %d %T %:z") $(hostname)"
	echo "$STAMP"
	return 0
}

function unfmt() {
	local last_msg="$*"
	logmessage="${last_msg/${bold}${yellow}/}"
	logmessage="${logmessage/${reset}/}"
	echo "$logmessage"
}

function log_info_msg() {
	last_msg="$*"

	if ! ((quiet)); then
		echo -n -e "${BMPREFIX}${*}"
	fi
	return 0
}

function log_wait_msg() {
	printf "${BMPREFIX}${*}"
	printf "${CURS_ZERO}${WAIT_PREFIX}${SET_COL}${WAIT_SUFFIX}\n"
	return 0
}

evaluate_retval() {
	local error_value="$?"
	local error_fatal="$2"
	local cmsgdie="$3"

	[[ -z "$error_fatal" ]] && error_fatal=$true

	if [[ $# -gt 0 ]]; then
		error_value="$1"
	fi

	if [[ "${error_value}" = 0 ]]; then
		log_success_msg ''
	else
		log_failure_msg ''
	fi

	if ((error_value)); then
		if ((error_fatal)); then
			[[ -z "$cmsgdie" ]] && die "${cmsg_InstalacaoAbortada[$LC_DEFAULT]}..." || die "$cmsgdie"
		else
			log_error "${cmsg_Error_not_fatal[LC_DEFAULT]} $BOOTLOG"
		fi
	fi
	return "${error_value}"
}

log_failure_msg() {
	if ((verbose)); then
		echo -n -e "${BMPREFIX}${*}"
		echo -e "${CURS_ZERO}${FAILURE_PREFIX}${SET_COL}${FAILURE_SUFFIX}"
	fi
	logmessage=${last_msg/$bold$red$green$yellow/}
	printf "%s\n" "$(timespec) [ FAIL ]${logmessage}" 2>&1 | tee -i -a "$BOOTLOG" >"$LOGGER"
	replicate "#" "100" | tee -i -a "$BOOTLOG" >"$LOGGER"
	return 0
}

function log_failure_msg2() {
	printf "%s" "${BMPREFIX}${*}"
	printf "%s\n" "${CURS_ZERO}${FAILURE_PREFIX}${SET_COL}${FAILURE_SUFFIX}"
	return 0
}

log_success_msg() {
	if ((verbose)); then
		echo -n -e "${BMPREFIX}${*}"
		echo -e "${CURS_ZERO}${SUCCESS_PREFIX}${SET_COL}${SUCCESS_SUFFIX}"
	fi
	logmessage=$(unfmt "$last_msg")
	printf "%s\n" "$(timespec) [  OK  ]${logmessage}" 2>&1 | tee -i -a "$BOOTLOG" >"$LOGGER"
	replicate "#" "100" | tee -i -a "$BOOTLOG" >"$LOGGER"
	return 0
}

#function log_success_msg2() {
#	printf "%s" "${BMPREFIX}$*"
#	printf "%s\n" "${CURS_ZERO}${SUCCESS_PREFIX}${SET_COL}${SUCCESS_SUFFIX}"
#	return 0
#}

function log_success_msg2() {
	#echo -n -e "${BMPREFIX}${@}"
	#echo -e "${CURS_ZERO}${SUCCESS_PREFIX}${SET_COL}${SUCCESS_SUFFIX}"
	printf "${BMPREFIX}${@}"
	printf "${CURS_ZERO}${SUCCESS_PREFIX}${SET_COL}${SUCCESS_SUFFIX}\n"
	#echo " OK" >> ${BOOTLOG}
	return 0
}

function sh_adel() {
	local arr=("$@")
	local new=()
	local nfiles="${#arr[*]}"

	if ((nfiles)); then
		#		new=($(uniq -u <<< "$(printf '%s\n' "${arr[@]}")"))
		mapfile -t new <<<"$(uniq -u <<<"$(printf '%s\n' "${arr[@]}")")"
	fi
	printf '%s\n' "${new[@]}"
	return 0
}

function debug() {
	whiptail \
		--fb \
		--clear \
		--backtitle "[debug]$0" \
		--title "[debug]$0" \
		--yesno "${*}\n" \
		0 40
	result=$?
	if ((result)); then
		exit
	fi
	return $result
}
export -f debug

function info() {
	dialog \
		--backtitle "\n$*\n" \
		--title "[info]$0" \
		--yesno "${*}\n" \
		0 0
	result=$?
	if ((result)); then
		exit
	fi
	return $result
}
export -f info

function sh_checkroot() {
	local str="root user check"
	if [[ "$(id -u)" != "0" ]]; then
		((verbose >= 2)) && log_msg $true "${str} - $USER"
		die "${red} error: you cannot perform this operation unless you are root."
	fi
	((verbose >= 2)) && log_msg $false "${str}"
	return 0
}

function sh_toBytes() {
	local ent mut num fra sai

	ent=${1^^}
	[[ $ent = "" || $ent = '0' ]] && ent=0B
	mut=${ent//[^BKMGT]/}
	num=${ent//[^[:digit:]]/}
	ent=${ent//$mut/}
	fra=${ent//[^,.]/}
	fra=${fra:+${ent//*[,.]/}}
	ent=0BKMGT
	ent=${ent//$mut*/}
	#mut=$((${#ent}-1))
	((mut = ${#ent} - 1, sai = num * 1024 ** mut))
	((ent = ${#sai} - ${#fra}))
	echo ${sai:0:$ent}
}

function human_to_bytes() {
	local size="$1"
	[[ -z "$size" ]] && size="0"
	local lastletter=${size:0-1}
	local count=0
	local upper=${lastletter^^}

	size=${size/$lastletter/$upper}
	LC_ALL=C numfmt --from=iec "$size"
	return "$?"
}
export -f human_to_bytes

function human_to_size() {
	human_to_bytes "$1"
	return "$?"
}
export human_to_size

function size_to_human() {
	local size="$1"
	[[ -z "$size" ]] && size="0"
	LC_ALL=C numfmt --to=si "$size"
	return "$?"
}
export -f size_to_human

function log_err() {
	local msg=$1
	local retval="${PIPESTATUS[0]}"
	local pcount=$#

	((pcount >= 2)) && {
		retval=$2
		shift
	}
	if ((verbose)); then
		[[ $retval -eq 0 ]] && printf " %b %s\\n" "${TICK}" "${msg}" || printf " %b %s\\n" "${CROSS}" "${msg}"
	fi
}
export -f log_err

function log_msg() {
	local retval="${PIPESTATUS[0]}"
	local pcount=$#

	((pcount >= 2)) && {
		retval=$1
		shift
	}
	[[ $retval -eq 0 ]] && printf " %b %s\\n" "${TICK}" "${*}" || printf " %b %s\\n" "${CROSS}" "${*}"
}
export -f log_msg

sh_setvarcolors() {
	if tput setaf 1 &>/dev/null; then
		export bold=$(tput bold)
		export reset=$(tput sgr0)
		export rst=$(tput sgr0)
		export rs=$(tput sgr0)
		export black=$(tput bold)$(tput setaf 0)
		export red=$(tput bold)$(tput setaf 196)
		export green=$(tput bold)$(tput setaf 2)
		export yellow=$(tput bold)$(tput setaf 3)
		export blue=$(tput setaf 33)
		export cyan=$(tput setaf 37)
		export orange=$(tput setaf 166)
		export purple=$(tput setaf 125)
		export violet=$(tput setaf 61)
		export pink=$(tput setaf 129)
		export white=$(tput bold)$(tput setaf 7)
	else
		export bold=''
		export reset="\e[0m"
		export rst="\e[0m"
		export rs="\e[0m"
		export reset="\e[0m"
		export blue="\e[1;34m"
		export cyan="\e[1;36m"
		export green="\e[1;32m"
		export orange="\e[1;33m"
		export purple="\e[1;35m"
		export red="\e[1;31m"
		export violet="\e[1;35m"
		export white="\e[1;37m"
		export yellow="\e[1;33m"
		export pink="\033[35;1m"
		export black="\e[1;30m"
	fi
}

function sh_unsetvarcolors() {
	unset bold reset rst rs blue cyan green orange
	unset purple red violet white yellow pink black
}

function sh_touchconf() {
	[[ -d "${SYSCONFDIR}" ]] || mkdir -p "${SYSCONFDIR}" >/dev/null 2>&-
	cat >"$SYSCONFDIR/fetch.conf" <<-'_EOF_'
		######################################################################
		# Generated with fetch    - https://chililinux.com
		# fetch.conf
		######################################################################
		# extension of packages: chili=chi.zst, mazonos=mz
		#PKG_EXT='mz'       # http://mazonos.com
		PKG_EXT='chi.zst'  # https://chililinux.com | https://chilios.com.br | https://github.com/vcatafesta/ChiliOS

		# packages hosted on GITHUB repository: yes='1', not='0'
		GITSITE='0'

		# distro hosting website/packages
		#PKG_SITE='https://github.com/vcatafesta/ChiliOS/tree/master'  # for use set GITSITE=1
		PKG_SITE='https://chililinux.com'                                           # for use set GITSITE=0
		#PKG_SITE='https://chilios.com.br'                                           # for use set GITSITE=0
		#PKG_SITE='https://chililinux.org'                                          # for use set GITSITE=0
		#PKG_SITE='http://localhost'                                                   # for use set GITSITE=0
		#PKG_SITE='http://mazonos.com'                                                # for use set GITSITE=0

		#not needed change
		PKG_RAW='https://raw.githubusercontent.com/vcatafesta/ChiliOS/master'

		# configuration for generation new packages
		MAINTAINER='Vilmar Catafesta <vcatafesta@gmail.com>'
		GPG_SIGN='0'
		REWRITE_SIGN='1'
		CREATE_SHA256='0'
		DESC_BUILD='1'
		URL='https://www.linuxfromscratch.org/lfs/view/stable/'
		LICENSE='GPL2'
		LFS_VERSION='12.0'
		LFS_INIT='SYSTEMD'
		ARCH='x86_64'
		DISTRO='chili'
		LOCALDIR='/github/ChiliOS'
		PKGCORE="$LOCALDIR/packages/core"
		CACHEDIR='/var/cache/fetch'
		ALIEN_CACHE_DIR='/var/cache/pacman/pkg'
		IGNOREPKG=('glibc' 'file')

		#end
	_EOF_
}

function clinesplit() {
	printf "%s%s%s%s%s%s%s%s" \
		"${aPKGSPLIT[$PKG_BASE]}$SEP" \
		"${aPKGSPLIT[$PKG_VERSION]}$SEP" \
		"${aPKGSPLIT[$PKG_BUILD]}$SEP" \
		"${aPKGSPLIT[$PKG_FULLNAME]}$SEP" \
		"${aPKGSPLIT[$PKG_PKG_FOLDER_DIR]}/${aPKGSPLIT[$PKG_FULLNAME]}$SEP" \
		"${aPKGSPLIT[$PKG_BASE_VERSION]}$SEP" \
		"${aPKGSPLIT[$PKG_SIZE]}$SEP" \
		"${aPKGSPLIT[$PKG_FOLDER_DIR]}"
}
export -f clinesplit

function clineascan() {
	printf "%s\n" "${aPKGARRAY[0]}$SEP${aPKGARRAY[1]}$SEP${aPKGARRAY[2]}$SEP${aPKGARRAY[3]}$SEP${aPKGARRAY[4]}$SEP${aPKGARRAY[5]}$SEP${aPKGARRAY[6]}"
}
export -f clineascan

function clineinstallascan() {
	printf "%s" "${aPKGARRAY[5]}  $(size_to_human "${aPKGARRAY[6]}")"
}
export -f clineinstallascan

function sh_arraypkgfullVET() {
	OLDIFS=$IFS
	local file_list_packages="$1"
	[[ $# -eq 0 ]] && file_list_packages="$CACHEDIR_SEARCH/$PACKAGES_SPLIT"

	public_len_count_pkg=0

	declare -ga public_pkg_base
	declare -ga public_pkg_version
	declare -ga public_pkg_build
	declare -ga public_pkg_fullname
	declare -ga public_pkg_dirfullname
	declare -ga public_pkg_base_version
	declare -ga public_pkg_size
	declare -ga public_pkg_site
	local ind=0

	((verbose >= 2)) && log_msg "Checking packages"

	while IFS=, read -r public_pkg_base[$ind] \
		public_pkg_version[$ind] \
		public_pkg_build[$ind] \
		public_pkg_fullname[$ind] \
		public_pkg_dirfullname[$ind] \
		public_pkg_base_version[$ind] public_pkg_size[$ind] \
		public_pkg_site[$ind]; do
		((ind++))
	done <"$file_list_packages"
	public_len_count_pkg=${#public_pkg_base[*]}
	IFS=$OLDIFS
	return 0
}

function sh_arraypkgfullIFS() {
	OLDIFS=$IFS
	local file_list_packages="$1"
	[[ $# -eq 0 ]] && file_list_packages="$CACHEDIR_SEARCH/$PACKAGES_SPLIT"

	public_len_count_pkg=0
	export -ga public_pkg_base
	export -ga public_pkg_version
	export -ga public_pkg_build
	export -ga public_pkg_fullname
	export -ga public_pkg_dirfullname
	export -ga public_pkg_base_version
	export -ga public_pkg_size
	export -ga public_pkg_site

	((verbose >= 2)) && log_msg "Checking packages"

	while IFS=, read -r fld1 fld2 fld3 fld4 fld5 fld6 fld7 fld8; do
		public_pkg_base+=("${fld1}")
		public_pkg_version+=("${fld2}")
		public_pkg_build+=("${fld3}")
		public_pkg_fullname+=("${fld4}")
		public_pkg_dirfullname+=("${fld5}")
		public_pkg_base_version+=("${fld6}")
		public_pkg_size+=("${fld7}")
		public_pkg_site+=("${fld8}")
	done <"$file_list_packages"

	public_len_count_pkg=${#public_pkg_base[*]}
	IFS=$OLDIFS
	return 0
}

function sh_arraypkgfull() {
	local file_list_packages="$1"
	[[ $# -eq 0 ]] && file_list_packages="$CACHEDIR_SEARCH/$PACKAGES_SPLIT"
	((verbose >= 2)) && log_msg "Checking packages"

	#	public_pkg_base=($(        awk -F"$SEP" '{ print $1 }' "$file_list_packages"))
	#	public_pkg_version=($(     awk -F"$SEP" '{ print $2 }' "$file_list_packages"))
	#	public_pkg_build=($(       awk -F"$SEP" '{ print $3 }' "$file_list_packages"))
	#	public_pkg_fullname=($(    awk -F"$SEP" '{ print $4 }' "$file_list_packages"))
	#	public_pkg_dirfullname=($( awk -F"$SEP" '{ print $5 }' "$file_list_packages"))
	#	public_pkg_base_version=($(awk -F"$SEP" '{ print $6 }' "$file_list_packages"))
	#	public_pkg_size=($(        awk -F"$SEP" '{ print $7 }' "$file_list_packages"))
	#	public_pkg_site=($(        awk -F"$SEP" '{ print $8 }' "$file_list_packages"))

	mapfile -t public_pkg_base <<<"$(awk -F"$SEP" '{ print $1 }' "$file_list_packages")"
	mapfile -t public_pkg_version <<<"$(awk -F"$SEP" '{ print $2 }' "$file_list_packages")"
	mapfile -t public_pkg_build <<<"$(awk -F"$SEP" '{ print $3 }' "$file_list_packages")"
	mapfile -t public_pkg_fullname <<<"$(awk -F"$SEP" '{ print $4 }' "$file_list_packages")"
	mapfile -t public_pkg_dirfullname <<<"$(awk -F"$SEP" '{ print $5 }' "$file_list_packages")"
	mapfile -t public_pkg_base_version <<<"$(awk -F"$SEP" '{ print $6 }' "$file_list_packages")"
	mapfile -t public_pkg_size <<<"$(awk -F"$SEP" '{ print $7 }' "$file_list_packages")"
	mapfile -t public_pkg_site <<<"$(awk -F"$SEP" '{ print $8 }' "$file_list_packages")"

	export public_pkg_base
	export public_pkg_version
	export public_pkg_build
	export public_pkg_fullname
	export public_pkg_dirfullname
	export public_pkg_base_version
	export public_pkg_size
	export public_pkg_site

	public_len_count_pkg="${#public_pkg_base[*]}"
	return 0
}
export sh_arraypkgfull

function callback() {
	local IFS=,
	eval linha"$1="\("$2"\)
}
export -f callback

function sh_arraypkgfullMapfile() {
	local acampo=()
	local file_list_packages=$1
	[[ $# -eq 0 ]] && file_list_packages="$CACHEDIR_SEARCH/$PACKAGES_SPLIT"
	public_len_count_pkg=0

	((verbose >= 2)) && log_msg "Checking packages"
	#	foo() { echo "|$2|"; }; mapfile -t -d, -n7 -c1 -C 'foo' <"$file_list_packages"
	#	public_pkg_base=${public_pkg_base[@]//,*}

	#	callback() {
	#		local IFS=,
	#		eval linha$1=\($2\)
	#	}
	mapfile -t -c1 -C callback <"$file_list_packages"
	#declare -p linha{0..2}
	#L=1;	C=4; eval echo "\${linha$L[C]}"

	acampo=(base version build fullname dirfullname base_version size site)

	for i in {0..5386}; do
		for j in ${!acampo[*]}; do
			eval public_pkg_"${acampo[j]}"+=\("\${linha${i}[j]}"\)
		done
	done

	#	for i in {0..5386}
	#	do
	#		#  eval echo "\${linha$i[6]}"
	#		#  eval val="\${linha$i[6]}"
	#		#  pkg_size+=("$val")
	#		eval public_pkg_base+=("\${linha$i[0]}")
	#		eval public_pkg_version+=("\${linha$i[1]}")
	#		eval public_pkg_build+=("\${linha$i[2]}")
	#		eval public_pkg_fullname+=("\${linha$i[3]}")
	#		eval public_pkg_dirfullname+=("\${linha$i[4]}")
	#		eval public_pkg_base_version+=("\${linha$i[5]}")
	#		eval public_pkg_size+=("\${linha$i[6]}")
	#		eval public_pkg_site+=("\${linha$i[7]}")
	#	done

	public_len_count_pkg=${#public_pkg_base[*]}
	return 0
}
export -f sh_arraypkgfullMapfile

function sh_ascanpkg() {
	#	local pkgsearch="^$1$"
	local pkgsearch="$1"
	local pos="$2"
	local indice
	local d
	aPKGARRAY=()

	indice=$(awk -F"$SEP" -v var="^$pkgsearch$" -v field=$((++pos)) '$field ~ var { print NR}' "$CACHEDIR_SEARCH/$PACKAGES_SPLIT")
	#	case $pos in
	#		0) indice=$(awk -F$SEP -v var="$pkgsearch" -v field=1 '$'"field"' ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
	#		0) indice=$(awk -F$SEP -v var="$pkgsearch" -v field=$((++pos)) '$field ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
	#		0) indice=$(awk -F$SEP -v var="$pkgsearch" '$1 ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
	#		1) indice=$(awk -F$SEP -v var="$pkgsearch" '$2 ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
	#		2) indice=$(awk -F$SEP -v var="$pkgsearch" '$3 ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
	#		3) indice=$(awk -F$SEP -v var="$pkgsearch" '$4 ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
	#		4) indice=$(awk -F$SEP -v var="$pkgsearch" '$5 ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
	#		5) indice=$(awk -F$SEP -v var="$pkgsearch" '$6 ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
	#		6) indice=$(awk -F$SEP -v var="$pkgsearch" '$7 ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
	#		7) indice=$(awk -F$SEP -v var="$pkgsearch" '$8 ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
	#	esac

	if [[ -z $indice || "${indice//[0-9]/}" != "" ]]; then
		return 1
	fi

	#indice=$(printf "%d %d %d %d %d" "$indice") # corrigir bug do retorno do indice pelo awk quando varios pacotes mesmo nome
	indice=${indice%% *}
	((--indice))

	aPKGARRAY=("${public_pkg_base[$indice]}"
		"${public_pkg_version[$indice]}"
		"${public_pkg_build[$indice]}"
		"${public_pkg_fullname[$indice]}"
		"${public_pkg_dirfullname[$indice]}"
		"${public_pkg_base_version[$indice]}"
		"${public_pkg_size[$indice]}"
		"${public_pkg_site[$indice]}"
	)
	strstatus=''
	if grep -q ^"$pkgsearch$SEP" "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"; then
		strstatus='[installed]'
	fi
	return 0
}
export -f sh_ascanpkg

function sh_ascanpkgGrep() {
	local pkgsearch="$1"
	local pos="$2"
	local indice=0
	aPKGARRAY=()

	case $pos in
	0) indice=$(grep -Po -n -m 1 "^$pkgsearch$" <<<"$(printf '%s\n' "${public_pkg_base[@]}")") ;;
	1) indice=$(grep -Po -n -m 1 "^$pkgsearch$" <<<"$(printf '%s\n' "${public_pkg_version[@]}")") ;;
	2) indice=$(grep -Po -n -m 1 "^$pkgsearch$" <<<"$(printf '%s\n' "${public_pkg_build[@]}")") ;;
	3) indice=$(grep -Po -n -m 1 "^$pkgsearch$" <<<"$(printf '%s\n' "${public_pkg_fullname[@]}")") ;;
	4) indice=$(grep -Po -n -m 1 "^$pkgsearch$" <<<"$(printf '%s\n' "${public_pkg_dirfullname[@]}")") ;;
	5) indice=$(grep -Po -n -m 1 "^$pkgsearch$" <<<"$(printf '%s\n' "${public_pkg_base_version[@]}")") ;;
	6) indice=$(grep -Po -n -m 1 "^$pkgsearch$" <<<"$(printf '%s\n' "${public_pkg_size[@]}")") ;;
	7) indice=$(grep -Po -n -m 1 "^$pkgsearch$" <<<"$(printf '%s\n' "${public_pkg_site[@]}")") ;;
	esac

	if [[ -z $indice ]]; then
		return 1
	fi
	indice="${indice%%:*}"
	((--indice))
	aPKGARRAY=("${public_pkg_base[$indice]}"
		"${public_pkg_version[$indice]}"
		"${public_pkg_build[$indice]}"
		"${public_pkg_fullname[$indice]}"
		"${public_pkg_dirfullname[$indice]}"
		"${public_pkg_base_version[$indice]}"
		"${public_pkg_size[$indice]}"
		"${public_pkg_site[$indice]}"
	)
	return 0
}
export -f sh_ascanpkgGrep

function sh_ascanpkgGrep2() {
	local pkgsearch="$1"
	local pos="$2"
	local indice=0
	aPKGARRAY=()

	case $pos in
	0) indice=$(printf "%s\n" "${public_pkg_base[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1) ;;
	1) indice=$(printf "%s\n" "${public_pkg_version[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1) ;;
	2) indice=$(printf "%s\n" "${public_pkg_build[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1) ;;
	3) indice=$(printf "%s\n" "${public_pkg_fullname[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1) ;;
	4) indice=$(printf "%s\n" "${public_pkg_dirfullname[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1) ;;
	5) indice=$(printf "%s\n" "${public_pkg_base_version[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1) ;;
	6) indice=$(printf "%s\n" "${public_pkg_size[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1) ;;
	7) indice=$(printf "%s\n" "${public_pkg_site[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1) ;;
	esac

	if [[ -z $indice ]]; then
		return 1
	fi

	((--indice))
	aPKGARRAY=("${public_pkg_base[$indice]}"
		"${public_pkg_version[$indice]}"
		"${public_pkg_build[$indice]}"
		"${public_pkg_fullname[$indice]}"
		"${public_pkg_dirfullname[$indice]}"
		"${public_pkg_base_version[$indice]}"
		"${public_pkg_size[$indice]}"
		"${public_pkg_site[$indice]}"
	)
	return 0
}
export -f sh_ascanpkgGrep2

function sh_cabec() {
	printf "(${pink}%04d)${green} sts package%47sversion%8s%11ssize fullbasename\n" "$1"
}
export -f sh_cabec

function sh_write() {
	local pkgsearch="$1"
	local pos="$2"
	local pkgCheckNumber="$3"
	local status="$4"
	local clisting="$5"
	local strstatus=''
	local LSCAN=$true

	[[ "$pos" = '-1' ]] && LSCAN=$false
	((LSCAN)) && sh_ascanpkg "$pkgsearch" "$pos"
	[[ -z "$status" ]] && status=' A '
	[[ "$clisting" == 'N' ]] && return 0
	[[ "$status" = ' I ' ]] && strstatus='installed'

	if ((verbose >= 2)); then
		if grep -q ^"$pkgsearch$SEP" "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"; then
			strstatus='installed'
			[[ "$status" != 'dep' ]] && status=' I '
		else
			strstatus='         '
			[[ "$status" != 'dep' ]] && status=' N '
		fi

		if [[ "$status" = 'dep' ]]; then
			if ! ((LDEPS)); then
				return
			fi
		fi

		printf "${green}%s(%04d) ${cyan}%-3s ${orange}%-43s$cyan $strstatus ${reset}%-15s${red}%15s ${reset}%s\n" \
			"" \
			"$pkgCheckNumber" \
			"$status" \
			"${aPKGARRAY[0]}" \
			"${aPKGARRAY[1]}" \
			"$(size_to_human "${aPKGARRAY[6]}")" \
			"${aPKGARRAY[3]}"
	else
		log_msg "[$pkgCheckNumber]${orange}${aPKGARRAY[0]}" # resumido
	fi
	return 0
}
export -f sh_write

function sh_footer() {
	local pkgCheckNumber=$1
	log_msg "${green}($pkgCheckNumber)${reset} package(s) found."
}
export -f sh_footer

# -La
function sh_list() {
	local param="$*"
	local nfiles
	local s x y
	local status=' A '
	local SEARCH_CUT='-f1'
	local pkg
	local aout
	local cListSearch

	LLIST=$true
	((verbose >= 2)) && log_msg "Reading package lists in the repository"
	if (($#)); then
		for s in "${param[@]}"; do
			cListSearch+="$s "
		done
	fi

	if [[ -z "$cListSearch" ]]; then
		#		if (( LALL )); then
		# 			pkg="${public_pkg_base[@]}"
		# 			aout="${public_pkg_base_version[@]}"
		pkg=("${public_pkg_base[@]}")
		aout=("${public_pkg_base_version[@]}")
		#		else
		#			log_msg $ERR_ERROR "${red}error${reset}: nenhum alvo definido (use -h para obter ajuda)"
		#			return 1
		#		fi
	else
		for x in ${cListSearch}; do
			((LEXACT)) && y="^$x$SEP" || y="$x"
			if tmp=$(grep "$y" "$CACHEDIR_SEARCH/$PACKAGES_SPLIT"); then
				pkg+=("$(cut -d"$SEP" -f1 <<<"$tmp")); aout+=($(cut -d"$SEP" -f5 <<<"$tmp")")
			else
				log_msg $ERR_ERROR "${red}error${reset}: alvo não encontrado: $x"
			fi
		done
	fi

	if ! nfiles=$(arraylen "${pkg[@]}"); then
		return 1
	fi

	sh_writetable "${pkg[*]}" '0' "$nfiles"
	return $?
}
export -f sh_list

# -Li
function sh_listinstalled() {
	local param="$*"

	((verbose >= 2)) && log_msg "Listing installed packages"
	LLIST=$true
	LDEPS=$false
	SPLITPOS='0'

	[[ -z "${param}" ]] && LALL=$true || LALL=$false
	sh_listpkgdisp "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" "$param"
}
export -f sh_listinstalled

# -Li
function sh_listpkgdisp() {
	local file_list_package="$1"
	shift
	local file_list_installed="$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"
	local param="$*"
	local s
	local i
	local SEARCH_CUT="-f5"
	local nstatus=0
	local pgk_grep
	local ncontapkg=0
	local aBidi=()

	[[ -e $file_list_installed ]] || printf '' >"${file_list_installed}"

	#TODO: verificar necessidade
	#sh_arraypkgfull "$file_list_package"
	#TODO: verificar necessidade

	public_ntotal_pkg_installed=$(sh_linecount "$file_list_installed")
	public_ntotal_pkg_listed=$public_ntotal_pkg_installed
	public_pkg=()
	public_pkg_deps=()
	public_ListSearch=("$param")
	public_pkg_not_found=()

	if [[ -z "$SPLITPOS" ]]; then
		SPLITPOS='4'
		SEARCH_CUT='-f5'
		AWK_CUT='$5'
	elif [[ "$SPLITPOS" == "0" ]]; then
		SEARCH_CUT='-f1'
		AWK_CUT='$1'
	elif [[ "$SPLITPOS" == "4" ]]; then
		SEARCH_CUT='-f5'
		AWK_CUT='$5'
	elif [[ "$SPLITPOS" == "5" ]]; then
		SEARCH_CUT='-f6'
		AWK_CUT='$6'
	fi

	if ((LALL)) || [[ -z "$param" ]]; then
		if ((LALL)); then
			mapfile -t public_pkg < <(awk -F$SEP '{print '"$AWK_CUT"'}' "$file_list_package")
		else
			die "${red}error${reset}: nenhum alvo definido (use -h para obter ajuda)"
		fi
	else
		for x in ${public_ListSearch[@]}; do
			if ((LEXACT)); then
				pkg_grep=$(grep ^"$x$SEP" "$file_list_package" | cut -d"$SEP" "$SEARCH_CUT")
			else
				pkg_grep=$(grep "$x" "$file_list_package" | cut -d"$SEP" "$SEARCH_CUT")
			fi

			if [[ -n "$pkg_grep" ]]; then
				for n in ${pkg_grep[@]}; do
					public_pkg+=("$n")
				done
			else
				if ! ((LSKIPERROR)); then
					if ((LREMOVE)); then
						log_msg $ERR_ERROR "${red}error: ${orange}$x ${reset}target was ${red}NOT INSTALLED. ${reset}Use the ${yellow}${0##*/} -Sr ${reset}option to rebuild installed packages."
					else
						log_msg $ERR_ERROR "${red}error: ${orange}$x ${reset}target was ${red}NOT found. ${reset}Use the ${yellow}-Ss ${reset}option to search. "
					fi
					exit 1
				else
					log_msg $ERR_ERROR "${red}error${reset}: ${orange}${x} ${reset}target was ${red}NOT ${reset}found. ${yellow}Skipping"
				fi
				public_pkg_not_found+=("$x")
			fi

			if ! ((LREMOVE)); then
				if ! ((LSEARCHONLY)); then
					pkginstalled=$(grep ^"$x""$SEP" "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" | cut -d"$SEP" "$SEARCH_CUT")
					if [[ -n "$pkginstalled" && "${pkginstalled##*/}" = "${pkg_grep##*/}" ]]; then
						log_msg $ERR_ERROR "${yellow}atenção${reset}: ${orange}${pkginstalled##*/} ${reset}está atualizado -- reinstalando."
					fi
				fi
			fi
		done
	fi

	public_ntotal_pkg_listed=$(arraylen "${public_pkg[@]}")
	if ((public_ntotal_pkg_listed)); then
		nstatus=$public_ntotal_pkg_listed
		if ! ((LREMOVE)); then
			if ((LDEPS)); then
				sh_getdeps $LDEPS || return 1
				public_pkg+=("${public_pkg_deps[@]}")
			fi
		fi
		#sanitize
		public_pkg=("$(sh_adel "${public_pkg[@]}")")
		public_ntotal_pkg_listed=$(lenarray "${public_pkg[@]}")
		if ((LSHOW)); then
			sh_writetable "${public_pkg[@]}" '0' "$public_ntotal_pkg_listed" "$nstatus"
		fi
		return 0
	fi
	return 1
}
export -f sh_listpkgdisp

function sh_writetable() {
	#	local arr=($1)
	local arr
	local campo="$2"
	local nfiles=$3
	local nstatus=$4
	local status
	mapfile -t arr <<<"$(printf "%s\n" "$*:1")"

	if ((nfiles)); then
		if ((verbose >= 2)); then
			sh_cabec "$nfiles"
			pkgNumber=0

			for i in ${arr[@]}; do
				if ((verbose >= 2)); then
					[[ -n "$nstatus" ]] && ((pkgNumber > nstatus)) && status='dep' || status=' S '
					#					if   grep -q ^"$i$SEP" "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT";
					#					then status=' I '
					#					else status=' A '
					#					fi
				fi

				if [[ "$status" = 'dep' ]]; then
					if ! ((LDEPS)); then
						continue
					fi
				fi
				((LLIST)) && sh_write "$i" "$campo" $((++pkgNumber)) "$status"
			done
		else
			if ((LTABLE)); then
				for i in ${arr[@]}; do
					if sh_ascanpkg "$i" "$campo"; then
						repo=${aPKGARRAY[4]%%/*}
						printf "%-70s\t%s\t%15s\n" \
							"${bold}${pink}$repo/${white}${aPKGARRAY[0]}-${black}${aPKGARRAY[1]}" \
							"${red}$(size_to_human "${aPKGARRAY[6]}")" \
							"${cyan}$strstatus"
					fi
				done
				printf "%s\n" "${reset}Packages ($nfiles)"
			else
				#				printf "${bold}${black}%s\n${reset}Packages ($nfiles)\n" ${arr[*]}
				printf "${black}%s " "${arr[*]}"
				printf "${reset}\n%s\n" "Packages ($nfiles)"
				printf "\t%s\n" "${yellow}TIP: ${red}usar a opção --table ou --verbose para mais detalhes"
			fi
			return 0
		fi
		printf "${yellow}(%05d) %s\n" "$nfiles" "${cyan}packages listed${reset}"
	fi
	return 0
}
export -f sh_writetable

function sh_checknet() {
	# have internet?
	if curl --insecure "$SITE" >/dev/null 2>&-; then
		((verbose >= 2)) && log_msg $ERR_OK "${cyan}Testing internet from ${SITE}"
		return 0
	fi
	((verbose >= 2)) && log_msg $ERR_ERROR "Testing internet from ${SITE} - No route to server ($SITE) - ABORTED."
	return 1
}
export -f sh_checknet

function sh_cdroot() {
	cd - >/dev/null 2>&-
}
export -f sh_cdroot

function sh_selfupdate() {
	local param="$*"

	if ! ((LAUTO)) || ! ((LFORCE)); then
		echo
		conf "Update ${0##*/} from internet?"
		LAUTO=$?
	fi

	if ((LAUTO)) || ((LFORCE)); then
		local link="$PKG_RAW/updater/src/fetch"
		local tmp_dir_full="/tmp/${APP}"
		local tmp_dir="/tmp/${APP}/src"

		#internet?
		sh_checknet || return 1

		log_msg "Ok, let's do it..."
		#Ok, Puxe o arquivo do repositorio agora!
		[[ -d "${tmp_dir_full}" ]] && rm -r "${tmp_dir_full}"
		[[ -d "${tmp_dir}" ]] || mkdir -p "${tmp_dir}"
		pushd "${tmp_dir}" >/dev/null 2>&- || return 1
		log_info_msg "${cyan}Clonando $link"
		curl --insecure --silent --remote-name "${link}"
		evaluate_retval

		log_info_msg "${cyan}Permission and Copy archives"
		chmod +x "${tmp_dir}/fetch"
		evaluate_retval

		log_info_msg "${cyan}Copying file ${yellow}fetch ${red}to ${yellow}${0}"
		cp "${tmp_dir}/fetch" "$0"
		evaluate_retval

		log_info_msg "${cyan}Removing temporary files"
		[[ -d "${tmp_dir_full}" ]] && rm -r "${tmp_dir_full}"
		evaluate_retval
		log_info_msg "${violet}${0##*/} updated successfully, enjoy!"
		evaluate_retval
		exit 0
	fi
	sh_cdroot
	return 1
}

function sh_clean() {
	local param="$*"
	local lRetval=$false
	local nfiles

	nfiles=$(find "$CACHEDIR_ARCHIVES" -type f -iname "*.$PKG_EXT" -type f | wc -l)
	if ! ((nfiles)); then
		printf '' >|"$CACHEDIR_SEARCH/$PACKAGES_IN_CACHE"
		log_msg "${yellow}($nfiles) ${cyan}find packages in cache"
		return $lRetval
	fi

	if ! ((LAUTO)); then
		printf '%s\n' "Pacotes a serem mantidos:"
		printf '%s\n' "      Todos os pacotes instalados localmente"
		printf "\n"
		printf '%s\n' "Cache directory: $CACHEDIR_ARCHIVES/"
		conf "${blue}:: ${reset}Do you want to remove all packages from the cache?"
		LAUTO=$?
	fi

	if ((LAUTO)); then
		log_msg "${pink}Deleting downloaded package files"
		if [[ -d "$CACHEDIR_ARCHIVES" ]]; then
			rm -f "$CACHEDIR_ARCHIVES/*.$PKG_EXT*"
		else
			mkdir -p "$CACHEDIR_ARCHIVES"
		fi
		printf '' >|"$CACHEDIR_SEARCH/$PACKAGES_IN_CACHE"
		log_success_msg2 "${yellow}($nfiles) ${cyan}packages deleted"
		lRetval=$true
	fi
	sh_cdroot
	return $lRetval
}

function sh_checkdir() {
	local i
	local -a aDir
	aDir+=("$CACHEDIR_ARCHIVES")
	aDir+=("$CACHEDIR_SEARCH")
	aDir+=("$CACHEDIR_LIST")
	aDir+=("$CACHEDIR_DESC")
	aDir+=("$CACHEDIR_REMO")

	((verbose >= 2)) && log_msg "Checking job directories"

	for i in ${aDir[@]}; do
		((verbose >= 2)) && log_info_msg "$i"
		if [[ -d "$i" ]]; then
			((verbose >= 2)) && evaluate_retval
		else
			mkdir -p "$i" >/dev/null 2>&-
			((verbose >= 2)) && evaluate_retval
		fi
	done
	[[ -e "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" ]] || printf '' >|"$CACHEDIR_SEARCH/$PACKAGES_SPLIT"
	[[ -e "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" ]] || printf '' >|"$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"

	return $?
}

# -Sy
function sh_updaterepo() {
	local response

	verbose=2
	if ((LSELF)); then
		sh_selfupdate "$@"
		return $?
	fi

	local nfilesInReposit
	local nfilesInstalled
	local response
	local dw=("$FOLDERS_METAPACKAGES"
		"$METAPACKAGES"
		"$PACKAGES_SPLIT"
	)
	#internet?
	sh_checknet || return 1
	if response=$(curl --compressed -s -w "%{http_code}\n" -o /dev/null -k --url "${SITE}/repo/") && [[ $response -eq 404 ]]; then
		log_msg $ERR_ERROR "${red}error${reset}: $response Not Found ${orange}==> $SITE/repo/"
		return 1
	fi

	pushd "$CACHEDIR_SEARCH/" >/dev/null 2>&- || return 1
	sh_backup

	for i in ${dw[@]}; do
		rm -f "$CACHEDIR_SEARCH/$i"
	done
	log_msg "${pink}Cleaning up ${CACHEDIR_SEARCH}/${reset}"

	log_msg "${pink}Updating file packages from ${SITE}/repo/${reset}"
	curl --silent --insecure -O "$SITE/repo/${dw[0]}" -O "${SITE}/repo/${dw[1]}" -O "${SITE}/repo/${dw[2]}"
	sh_cleaning
	unset FOLDER_TEMP

	nfilesInReposit=$(sh_linecount "$CACHEDIR_SEARCH/$PACKAGES_SPLIT")
	nfilesInstalled=$(sh_linecount "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT")
	log_msg "${cyan}All list packages updated!${reset}"
	log_msg "${blue}($(strzero "$nfilesInReposit" 5)) packages in the repository${reset}"
	log_msg "${green}($(strzero "$nfilesInstalled" 5)) installed packages${reset}"
	echo
	msg "${reset}Use: # ${0##*/} --help for helping${reset}"
	popd >/dev/null 2>&- || return 1
}

# Função para processar uma pasta
process_folder_update() {
	Folders="$1"
	FOLDER_TEMP="$TMP_DIR_FOLDERS/$Folders"
	if response=$(curl --compressed -k -s -w "%{http_code}\n" --url "$SITE/packages/$Folders/" --output "$FOLDER_TEMP") && [[ "$response" = "404" ]]; then
		log_msg $ERR_ERROR "${red}error${reset}: $response Not Found ${orange}==> $SITE/packages/$Folders/"
		exit 1
	fi
	mapfile -t SizePkgInFolders < <(sed -nE "s/$SED_RE/\9/p" "$FOLDER_TEMP")

	if [[ "$Folders" != "meta" ]]; then
		if ((CHILI_OS)); then
			mapfile -t PackagesInFolders < <(sed -nE "s/$SED_RE/\1-\2-\5\6/p" "$FOLDER_TEMP")
		else
			mapfile -t PackagesInFolders < <(sed -nE "s/$SED_RE/\1-\2\6/p" "$FOLDER_TEMP")
		fi
		count=0
		for pkgInFolder in "${PackagesInFolders[@]}"; do
			if [[ -n "$pkgInFolder" ]]; then
				sh_splitpkg "$pkgInFolder"
				pkg_size=$(human_to_bytes "${SizePkgInFolders[$count]}")
				echo "${aPKGSPLIT[$PKG_BASE]}$SEP${aPKGSPLIT[$PKG_VERSION]}$SEP${aPKGSPLIT[$PKG_BUILD]}$SEP${aPKGSPLIT[$PKG_FULLNAME]}$SEP${Folders}/${pkgInFolder}$SEP${aPKGSPLIT[$PKG_BASE_VERSION]}$SEP${pkg_size}" >>"$CACHEDIR_SEARCH/$PACKAGES_SPLIT"
				((++count))
			fi
		done
	else
		mapfile -t MetaPkgInFolders <<<"$(lynx -listonly -nonumbers -dump "$SITE/packages/$Folders/" | grep -Po '.*\/\K.*')"
		count=0
		for MetaInFolder in "${MetaPkgInFolders[@]}"; do
			echo "$Folders/$MetaInFolder" >>"$FOLDERS_METAPACKAGES"
			echo "$MetaInFolder" >>"$METAPACKAGES"
			((++count))
		done
	fi
	log_msg "Updating... ${red}$(strzero "$count" 5)${blue} packages in ${yellow}$Folders"
}
# Exporta a função para uso com o parallel
export -f process_folder_update

# -Syy
function sh_update() {
	local response
	local Folders
	local FoldersInRepo
	local PackagesInFolders
	local MetaPkgInFolders
	local MetaInFolder
	local cstrvalue
	local response
	local count
	local nfilesInReposit
	local nfilesInstalled
	local nfilesInCache
	local oldverbose=$verbose
	local dw=("$CACHEDIR_SEARCH/$PACKAGES_SPLIT"
		"$CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES"
		"$CACHEDIR_SEARCH/$METAPACKAGES"
	)

	verbose=2
	if ((LSELF)); then
		sh_selfupdate "$@"
		return $?
	fi

	#internet?
	sh_checknet || return 1

	if response=$(curl --compressed -s -w "%{http_code}\n" -o /dev/null -k --url "$SITE/packages/") && [[ "$response" = "404" ]]; then
		log_msg $ERR_ERROR "${red}error${reset}: $response Not Found $orange==> $SITE/packages/"
		exit 1
	fi

	pushd "$CACHEDIR_SEARCH/" >/dev/null 2>&- || return 1
	sh_backup

	for i in ${dw[@]}; do
		printf '' >|"$i"
	done
	log_msg "${pink}Cleaning up $CACHEDIR_SEARCH/"

	mapfile -t FoldersInRepo <<<"$(lynx -listonly -nonumbers -dump -justify "$SITE/packages/" | grep -Po '.*packages\/\K.*?(?=\/)')"
	log_msg "${pink}Updating folders from $SITE"

	log_msg "${pink}Synchronizing package databases from $SITE/packages/"
	#	spinner & SPINNERPID=$!

	: <<'comment'
	for Folders in "${FoldersInRepo[@]}"; do
		FOLDER_TEMP="$TMP_DIR_FOLDERS/$Folders"
		if response=$(curl --compressed -k -s -w "%{http_code}\n" --url "$SITE/packages/$Folders/" --output "$FOLDER_TEMP") && [[ "$response" = "404" ]]; then
			log_msg $ERR_ERROR "${red}error${reset}: $response Not Found ${orange}==> $SITE/packages/$Folders/"
			exit 1
		fi
		mapfile -t SizePkgInFolders < <(sed -nE "s/$SED_RE/\9/p" "$FOLDER_TEMP")

		if [[ "$Folders" != "meta" ]]; then
			if ((CHILI_OS)); then
				mapfile -t PackagesInFolders < <(sed -nE "s/$SED_RE/\1-\2-\5\6/p" "$FOLDER_TEMP")
			else
				mapfile -t PackagesInFolders < <(sed -nE "s/$SED_RE/\1-\2\6/p" "$FOLDER_TEMP")
			fi
			count=0
			for pkgInFolder in "${PackagesInFolders[@]}"; do
				if [[ -n "$pkgInFolder" ]]; then
					sh_splitpkg "$pkgInFolder"
					pkg_size=$(human_to_bytes "${SizePkgInFolders[$count]}")
					echo "${aPKGSPLIT[$PKG_BASE]}$SEP${aPKGSPLIT[$PKG_VERSION]}$SEP${aPKGSPLIT[$PKG_BUILD]}$SEP${aPKGSPLIT[$PKG_FULLNAME]}$SEP${Folders}/${pkgInFolder}$SEP${aPKGSPLIT[$PKG_BASE_VERSION]}$SEP${pkg_size}" >>"$CACHEDIR_SEARCH/$PACKAGES_SPLIT"
					((++count))
				fi
			done
		else
			mapfile -t MetaPkgInFolders <<<"$(lynx -listonly -nonumbers -dump "$SITE/packages/$Folders/" | grep -Po '.*\/\K.*')"
			count=0
			for MetaInFolder in "${MetaPkgInFolders[@]}"; do
				echo "$Folders/$MetaInFolder" >>"$FOLDERS_METAPACKAGES"
				echo "$MetaInFolder" >>"$METAPACKAGES"
				((++count))
			done
		fi
		log_msg "Updating... ${red}$(strzero "$count" 5)${blue} packages in ${yellow}$Folders"
	done
comment

	# Lista de pastas a serem processadas (substitua pela sua própria lista)
	#	dw=("folder1" "folder2" "folder3")

	# Processa as pastas em paralelo

	parallel --gnu --jobs $MAX_PARALLEL process_folder_update ::: "${FoldersInRepo[@]}" &
#	for Folders in "${FoldersInRepo[@]}"; do
#		parallel --gnu --jobs $MAX_PARALLEL process_folder_update ::: "$Folders" &
#	done
	wait

	#	{ kill $SPINNERPID; wait $SPINNERPID 2>/dev/null; echo ;}

#	LLIST=$true ; sh_recreatefilepackagesinstalled
	verbose=$oldverbose
	sh_pkgincache
	sh_cleaning
	unset FOLDER_TEMP

	nfilesInReposit=$(sh_linecount "$CACHEDIR_SEARCH/$PACKAGES_SPLIT")
	nfilesInstalled=$(sh_linecount "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT")
	nfilesInCache=$(sh_linecount "$CACHEDIR_SEARCH/$PACKAGES_IN_CACHE")
	log_msg "${pink}All list packages updated!"
	log_msg "${red}$(strzero "$nfilesInReposit" 5) ${bold}${green}packages in the repository"
	log_msg "${red}$(strzero "$nfilesInstalled" 5) ${bold}${green}installed packages"
	log_msg "${red}$(strzero "$nfilesInCache" 5) ${bold}${green}packages in cache $CACHEDIR_ARCHIVES"
	echo
	msg "${reset}Use: # ${0##*/} --help for helping${reset}"
	popd >/dev/null 2>&- || return 1
}

function sh_updateMazon() {
	local nfilesInReposit
	local nfilesInstalled
	local nfilesInCache
	local HTTP_SERVER
	local response
	local Folders
	local count
	local dw=("$CACHEDIR_SEARCH/$PACKAGES_SPLIT" "$CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES" "$CACHEDIR_SEARCH/$METAPACKAGES")

	((LSELF)) && {
		sh_selfupdate "$@"
		return $?
	}
	sh_checknet || return 1
	if response=$(curl --compressed -s -w "%{http_code}\n" -o /dev/null -k --url "${SITE}/packages/") && [[ "$response" -eq 404 ]]; then
		log_msg $ERR_ERROR "${red}error${reset}: $response Not Found ${orange}==> $SITE/packages/"
		exit 1
	fi

	pushd "$CACHEDIR_SEARCH/" >/dev/null 2>&- || return 1
	sh_backup

	log_msg "${pink}Cleaning up ${CACHEDIR_SEARCH}/${reset}"
	for i in ${dw[@]}; do
		printf '' >|"$i"
	done
	HTTP_SERVER="$(string_alltrim "$(curl --compressed -s -k --head -w '%{http_code}\n' --url "${SITE}" | grep '^[Ss]erver' | awk '{print $2}')" | cut -d/ -f1)"

	log_msg "${pink}Updating folders from ${SITE}${reset}"
	case ${HTTP_SERVER} in
	Apache | nginx) mapfile -t FoldersInRepo <<<"$(curl --compressed -k -s --url "${SITE}/packages/" | grep -Po '>[[:alnum:]]*/' | sed 's/>//g;s/\///g' | tee "$CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES")" ;;
	LiteSpeed | cloudflare) mapfile -t FoldersInRepo <<<"$(curl --compressed -k -s --url "${SITE}/packages/" | grep -Po 'packages\/[a-z]+' | sed 's/packages\///g' | tee "$CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES")" ;;
	GitHub.com) mapfile -t FoldersInRepo <<<"$(curl --compressed -k -s --url "$SITE/packages/" | grep /packages/ | sed 's/<[^>]*>//g;s/ //g' | tee "$CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES")" ;;
	esac

	log_msg "${pink}Synchronizing package databases from ${SITE}${reset}"
	#spinner & SPINNERPID=$!

	: <<'comment'
	for Folders in ${FoldersInRepo[@]}; do
		FOLDER_TEMP="$TMP_DIR_FOLDERS/$Folders"
		response=$(curl --compressed --insecure -s -w "%{http_code}\n" -k --url "$SITE/packages/$Folders/" --output "$FOLDER_TEMP")
		case ${HTTP_SERVER} in
		Apache | nginx)
			if [[ $Folders != "meta" ]]; then
				mapfile -t PackagesInFolders < <(grep -Eo '>'"$PKG_RE"'<' "$FOLDER_TEMP" | sed 's/>//g; s/<//g')
			else
				mapfile -t MetaPkgInFolders < <(grep -E '.meta\"' "$FOLDER_TEMP" | cut -d'"' -f2)
			fi
			mapfile -t SizePkgInFolders < <(grep -E "$GREP_RE" "$FOLDER_TEMP" | awk '{print $5}')
			;;
		LiteSpeed | GitHub.com | cloudflare)
			if [[ $Folders != "meta" ]]; then
				mapfile -t PackagesInFolders <<<"$(sed 's/^.*href="//' "$FOLDER_TEMP" | sed 's/".*$//' | sed 's/\// /g' | grep -E ".${PKG_EXT}$" | awk '{print $NF}')"
			else
				mafile -t MetaPkgInFolders <<<"$(sed 's/^.*href="//' "$FOLDER_TEMP" | sed 's/".*$//' | sed 's/\// /g' | grep -E ".meta$" | awk '{print $NF}')"
			fi
#			mapfile -t SizePkgInFolders < <(grep -E "$GREP_RE $FOLDER_TEMP" | awk '{print $9}' | cut -d'"' -f2)
			;;
		esac

		count=0
		if [[ $Folders != "meta" ]]; then
			for pkgInFolder in "${PackagesInFolders[@]}"; do
				sh_splitpkg "$pkgInFolder"
				pkg_size="${SizePkgInFolders[$count]}"
				echo "${aPKGSPLIT[$PKG_BASE]}$SEP${aPKGSPLIT[$PKG_VERSION]}$SEP${aPKGSPLIT[$PKG_BUILD]}$SEP${aPKGSPLIT[$PKG_FULLNAME]}$SEP${Folders}/${pkgInFolder}$SEP${aPKGSPLIT[$PKG_BASE_VERSION]}$SEP${pkg_size}" >>"$CACHEDIR_SEARCH"/"$PACKAGES_SPLIT"
				((count++))
			done
		else
			for MetaInFolder in "${MetaPkgInFolders[@]}"; do
				echo "${Folders}/${MetaInFolder}" >>"$FOLDERS_METAPACKAGES"
				echo "${MetaInFolder}" >>"$METAPACKAGES"
				((count++))
			done
		fi
		cstrvalue=$(strzero "$count" 5)
		log_success_msg2 "  Updating... (${blue}${cstrvalue}${reset}) packages in ${Folders}"
	done
comment

	# Função para processar uma pasta
	process_folder() {
		Folders="$1"
		FOLDER_TEMP="$TMP_DIR_FOLDERS/$Folders"
		response=$(curl --compressed --insecure -s -w "%{http_code}\n" -k --url "$SITE/packages/$Folders/" --output "$FOLDER_TEMP")

		case ${HTTP_SERVER} in
		Apache | nginx)
			if [[ $Folders != "meta" ]]; then
				mapfile -t PackagesInFolders < <(grep -Eo '>'"$PKG_RE"'<' "$FOLDER_TEMP" | sed 's/>//g; s/<//g')
			else
				mapfile -t MetaPkgInFolders < <(grep -E '.meta\"' "$FOLDER_TEMP" | cut -d'"' -f2)
			fi
			mapfile -t SizePkgInFolders < <(grep -E "$GREP_RE" "$FOLDER_TEMP" | awk '{print $5}')
			;;
		LiteSpeed | GitHub.com | cloudflare)
			if [[ $Folders != "meta" ]]; then
				mapfile -t PackagesInFolders <<<"$(sed 's/^.*href="//' "$FOLDER_TEMP" | sed 's/".*$//' | sed 's/\// /g' | grep -E ".${PKG_EXT}$" | awk '{print $NF}')"
			else
				mapfile -t MetaPkgInFolders <<<"$(sed 's/^.*href="//' "$FOLDER_TEMP" | sed 's/".*$//' | sed 's/\// /g' | grep -E ".meta$" | awk '{print $NF}')"
			fi
			mapfile -t SizePkgInFolders < <(grep -E "$GREP_RE $FOLDER_TEMP" | awk '{print $9}' | cut -d'"' -f2)
			;;
		esac

		count=0
		if [[ $Folders != "meta" ]]; then
			for pkgInFolder in "${PackagesInFolders[@]}"; do
				sh_splitpkg "$pkgInFolder"
				pkg_size="${SizePkgInFolders[$count]}"
				echo "${aPKGSPLIT[$PKG_BASE]}$SEP${aPKGSPLIT[$PKG_VERSION]}$SEP${aPKGSPLIT[$PKG_BUILD]}$SEP${aPKGSPLIT[$PKG_FULLNAME]}$SEP${Folders}/${pkgInFolder}$SEP${aPKGSPLIT[$PKG_BASE_VERSION]}$SEP${pkg_size}"
				((count++))
			done
		else
			for MetaInFolder in "${MetaPkgInFolders[@]}"; do
				echo "${Folders}/${MetaInFolder}" >>"$FOLDERS_METAPACKAGES"
				echo "${MetaInFolder}" >>"$METAPACKAGES"
				((count++))
			done
		fi
		cstrvalue=$(strzero "$count" 5)
		log_success_msg2 "  Updating... (${blue}${cstrvalue}${reset}) packages in ${Folders}"
	}

	# Obtém a lista de pastas a serem processadas (substitua por sua própria lista)
	#	FoldersInRepo=("folder1" "folder2" "folder3")

	# Processa as pastas em paralelo
	export -f process_folder
	parallel --gnu --jobs $MAX_PARALLEL process_folder ::: "${FoldersInRepo[@]}" &
	wait

	#	{ kill $SPINNERPID; wait $SPINNERPID 2>/dev/null; echo ;}

#	LLIST=$true ; sh_recreatefilepackagesinstalled
	sh_pkgincache
	sh_cleaning
	unset FOLDER_TEMP

	nfilesInReposit=$(wc -l <"$CACHEDIR_SEARCH/$PACKAGES_SPLIT")
	nfilesInstalled=$(wc -l <"$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT")
	nfilesInCache=$(wc -l <"$CACHEDIR_SEARCH/$PACKAGES_IN_CACHE")
	log_msg "${cyan}All list packages updated!${reset}"
	log_msg "${blue}($(strzero "$nfilesInReposit" 5)) packages in the repository${reset}"
	log_msg "${green}($(strzero "$nfilesInstalled" 5)) installed packages${reset}"
	log_msg "${green}($(strzero "$nfilesInCache" 5)) packages in cache $CACHEDIR_ARCHIVES${reset}"
	echo
	log_msg "${reset}Use: # ${0##*/} --help for helping${reset}"
	popd >/dev/null 2>&- || return 1
}

function sh_filesincache() {
	local -i nfilesincache
	local item
	local pkg_base
	local cline
	local aCacheFullname

	((verbose >= 2)) && log_msg "Recreating IN CACHE packages list"
	printf '' >|"$CACHEDIR_SEARCH/$PACKAGES_IN_CACHE"
	mapfile -t aCacheFullname < <(find "$CACHEDIR_ARCHIVES/" -iname "*.$PKG_EXT" -type f | sort)
	nfilesincache="${#aCacheFullname[*]}"

	if ((nfilesincache)); then
		nfilesincache=0
		#   	for item in ${aCacheFullname[*]}; do
		for item in "${aCacheFullname[@]}"; do
			((++nfilesincache))
			sh_splitpkg "$item"
			pkg_base="${aPKGSPLIT[$PKG_BASE]}"
			aCache+=("$pkg_base")
			cline=$(clinesplit)
			echo "$cline" >>"$CACHEDIR_SEARCH/$PACKAGES_IN_CACHE"
			#			(( verbose >= 2 )) && sh_write "$pkg_base" "0" "$nfilesincache"
		done
	fi
	#	(( verbose >= 2 )) && printf "${yellow}(%05d) %s\n" "$nfilesincache" "${cyan}packages IN CACHE $CACHEDIR_ARCHIVES"
	return 0
}

# -Pi
function sh_pkgincache() {
	local lfind=$false
	local nfilesoutcache=0
	local nfilesincache=0
	local aPkgOut
	local aPkgIn
	local x
	local y
	local indice=0

	((verbose >= 2)) && log_msg "Ok, let's do it..."
	((verbose >= 2)) && log_msg "Wait, doing some calculations..."
	sh_filesincache

	nfilesincache="${#aCache[*]}"
	sh_writetable "${aCache[*]}" '0' "$nfilesincache"

	: <<'comment'
#	for y in ${public_pkg_base[*]};do
	for y in "${public_pkg_base[@]}";do
		if ! ascan "$y" "${aCache[@]}"; then
			((++nfilesoutcache))
  		   aPkgOut+=("${public_pkg_base_version[$indice]}")
		else
			((++nfilesincache))
			(( verbose >= 2 )) && sh_write "$y" "0" "$nfilesincache"
			aPkgIn+=("${public_pkg_base_version[$indice]}")
		fi
		((++indice))
	done
	sh_writetable "${aPkgIn[*]}" '5' "$nfilesincache"
comment

	if ((verbose >= 2)); then
		printf "${yellow}(%05d) %s\n" "$nfilesincache" "${cyan}packages in cache"
		printf "${yellow}(%05d) %s\n" "$nfilesoutcache" "${cyan}packages OUT CACHE $CACHEDIR_ARCHIVES"
		printf "${yellow}(%05d) %s\n" "$public_len_count_pkg" "${cyan}packages in the repository${reset}"
	fi
	return 0
}

function ascan() {
	local e match="$1"
	shift
	for e; do [[ "$e" == "$match" ]] && return 0; done
	return 1
}

# -Po
function sh_pkgoutcache() {
	local lfind=$false
	local nfilesoutcache=0
	local nfilesincache=0
	local aPkgOut
	local aPkgIn
	local x
	local y
	local indice=0

	((verbose >= 2)) && log_msg "Ok, let's do it..."
	((verbose >= 2)) && log_msg "Wait, doing some calculations..."
	sh_filesincache

	#	for y in ${public_pkg_base[*]};do
	for y in "${public_pkg_base[@]}"; do
		if ! ascan "$y" "${aCache[@]}"; then
			((++nfilesoutcache))
			((verbose >= 2)) && sh_write "$y" "0" "$nfilesoutcache"
			#			aPkgOut+=("$y")
			aPkgOut+=("${public_pkg_base_version[$indice]}")
		else
			((++nfilesincache))
			#			aPkgIn+=("$y")
			aPkgIn+=("${public_pkg_base_version[$indice]}")
		fi
		((++indice))
	done

	sh_writetable "${aPkgOut[*]}" '5' "$nfilesoutcache"

	if ((verbose >= 2)); then
		printf "${yellow}(%05d) %s\n" "$nfilesincache" "${cyan}packages in cache"
		printf "${yellow}(%05d) %s\n" "$nfilesoutcache" "${cyan}packages OUT CACHE $CACHEDIR_ARCHIVES"
		printf "${yellow}(%05d) %s\n" "$public_len_count_pkg" "${cyan}packages in the repository${reset}"
	fi
	return 0
}

sh_CatAndSizePkg() {
	local cpacote="$1"
	local LSHOW="$2"
	local lresult=$ERR_OK

	if [[ -e "$cpacote" ]]; then
		source "$cpacote"
		if ((LSHOW)); then
			printf '%s\n' "${cyan}BaseName     : ${yellow}${aPKGSPLIT[$PKG_FOLDER_DIR]}/${aPKGSPLIT[$PKG_FULLNAME]}"
			printf '%s\n' "${cyan}Name         : ${yellow}${pkgname}"
			printf '%s\n' "${cyan}Version      : ${yellow}${version}"
			printf '%s\n' "${cyan}Build        : ${yellow}${build}"
			printf '%s\n' "${cyan}Description  : ${yellow}${desc}"
			printf '%s\n' "${cyan}Architecture : ${yellow}${arch}"
			printf '%s\n' "${cyan}URL          : ${yellow}${url}"
			printf '%s\n' "${cyan}Licenses     : ${yellow}${license}"
			printf '%s\n' "${cyan}Dependencies : ${yellow}${depend}"
			printf '%s\n' "${cyan}Dependencies : ${yellow}${dep}"
			printf '%s\n' "${cyan}Size         : ${yellow}$(size_to_human "$size")"
			printf '%s\n' "${cyan}Packer       : ${yellow}${maintainer}"
			printf '%s\n' "${cyan}Distro       : ${yellow}${distro}"
			printf '%s\n' "${cyan}Init         : ${yellow}${lfs_init}"
			printf '%s\n' "${cyan}LSB          : ${yellow}${lfs_version}"
			printf '%s\n' "${reset}"
		fi
		unset pkgname version build desc arch url license depend dep size mainteiner distro lfs_init lfs_version
	else
		lresult=$ERR_ERROR
	fi
	return $lresult
}

sh_ShortCatPkg() {
	local cpacote="$1"
	local LSHOW=$2
	local lresult=$ERR_OK
	local cpackage="${aPKGSPLIT[$PKG_BASE]}"
	local SEARCH_CUT='-f5'
	local pkginstalled=

	if [[ -e "$cpacote" ]]; then
		source "$cpacote"
		if ((LSHOW)); then
			pkginstalled=$(grep ^"$cpackage$SEP" "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" | cut -d"$SEP" "$SEARCH_CUT")
			if [[ -z "$pkginstalled" ]]; then
				printf "%s  %s %s\n" "${pink}${aPKGSPLIT[$PKG_FOLDER_DIR]}/${yellow}${aPKGSPLIT[$PKG_BASE]}" "${green}${aPKGSPLIT[$PKG_VERSION]}" "${white}${desc::40}"
			else
				printf "%s  %s %s\n" "${pink}${aPKGSPLIT[$PKG_FOLDER_DIR]}/${yellow}${aPKGSPLIT[$PKG_BASE]}" "${green}${aPKGSPLIT[$PKG_VERSION]}" "${cyan}[installed] ${white}${desc::40}"
			fi
			printf '%s' "${reset}"
		fi
		unset pkgname version desc arch url license depend dep size maintainer distro lfs_init lfs_version
	else
		lresult=$ERR_ERROR
	fi
	return $lresult
}

# -Qi
function sh_show() {
	local param="$*"
	local saveverbose=$verbose
	local ntotal_pkg_listed
	local cpacote
	local lresult=$ERR_ERROR

	((verbose >= 2)) && log_msg "Reading package list..."
	verbose=0
	LDEPS=$false
	LEXACT=$true
	sh_listpkgdisp "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" "$param"
	ntotal_pkg_listed="$public_ntotal_pkg_listed"
	verbose=$saveverbose

	if ((ntotal_pkg_listed)); then
		for i in ${public_pkg[@]}; do
			sh_splitpkg "$i"
			cpacote="$CACHEDIR_ARCHIVES/${aPKGSPLIT[1]}.desc"

			if ((LFORCE)) || ! [[ -e "$cpacote" ]]; then
				if ! sh_wgetdesc "$i"; then
					continue
				fi
			fi
			sh_CatAndSizePkg "$cpacote" $true
		done
		lresult=$ERR_OK
	fi
	return $lresult
}

# -Ss
function sh_search() {
	local param="$*"
	local saveverbose=$verbose
	local ntotal_pkg_listed
	local cpacote
	local lresult=$ERR_ERROR

	((verbose >= 2)) && log_msg "Reading package list..."
	verbose=0
	LDEPS=$false
	#	LEXACT=$true
	sh_listpkgdisp "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" "$param"
	ntotal_pkg_listed="$public_ntotal_pkg_listed"
	verbose=$saveverbose

	if ((ntotal_pkg_listed)); then
		for i in ${public_pkg[@]}; do
			sh_splitpkg "$i"
			cpacote="$CACHEDIR_ARCHIVES/${aPKGSPLIT[1]}.desc"

			if ((LFORCE)) || ! [[ -e "$cpacote" ]]; then
				if ! sh_wgetdesc "$i"; then
					continue
				fi
			fi
			sh_ShortCatPkg "$cpacote" $true
		done
		lresult=$ERR_OK
	fi
	return $lresult
}

# -R
sh_remove() {
	#	local param="$@"
	local param="$*"
	local x
	local cPkgFullFilename
	local ntotal_pkg_listed

	LDEPS=$false
	LEXACT=$true
	LREMOVE=$true
	sh_listpkgdisp "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" "$param"
	ntotal_pkg_listed="$public_ntotal_pkg_listed"

	if ((ntotal_pkg_listed)); then
		if ! ((LAUTO)); then
			echo
			confno "${blue}::${reset} Remove package(s)?"
			LAUTO=$?
		fi

		if ((LAUTO)); then
			for cPkgFullFilename in ${public_pkg[@]}; do
				sh_splitpkg "$cPkgFullFilename"
				sh_doremove "${aPKGSPLIT[$PKG_BASE_VERSION]}" "$cPkgFullFilename"
			done
		fi
	else
		echo
		#log_msg $ERR_ERROR "${red}error${reset}:${orange}${public_ListSearch} ${reset}not installed."
		return $ERR_ERROR
	fi
	return $ERR_OK
}

sh_doremove() {
	local cPkgBaseVersion="$1"
	local cPkgFullFilename="$2"

	log_wait_msg "Wait, Removing package ${orange}$cPkgFullFilename"
	if sh_removepkg "$cPkgBaseVersion" "$cPkgFullFilename"; then
		if ((LLIST)); then
			log_success_msg2 "${green}$cPkgFullFilename${reset} Done. Removal of the package successfully completed"
		fi
		return $ERR_OK
	fi
	return $ERR_ERROR
}

sh_removepkg() {
	local cPkgBaseVersion="$1"
	local cPkgFullFilename="$2"

	sh_pre_remove "$cPkgBaseVersion" || return $ERR_ERROR
	#	sh_splitpkg "$cPkgFullFilename"  || return $ERR_ERROR
	if sed -i '/'"$cPkgBaseVersion"'/d' "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"; then
		return $ERR_OK
	fi
	return $ERR_ERROR
}

sh_remove_now() {
	local cPkgBaseVersion="${1/%.${PKG_EXT}/}"
	local thefile

	pushd "/" >/dev/null 2>&- || return 1

	if [[ -e "${CACHEDIR_REMO}/${cPkgBaseVersion}.rm" ]]; then
		sed -E "/rm[[:space:]]+\-(rf|fr)/d" "${CACHEDIR_REMO}/${cPkgBaseVersion}.rm" >/dev/null 2>&-
		bash "${CACHEDIR_REMO}/${cPkgBaseVersion}.rm"
		rm "${CACHEDIR_REMO}/${cPkgBaseVersion}.rm" >/dev/null 2>&-
	fi

	while IFS= read -r thefile; do
		if [[ -f "$thefile" ]]; then
			rm "$thefile" >/dev/null 2>&- && print "Delete\t${thefile}"
		fi
		if [[ -L "$thefile" ]]; then
			unlink "$thefile" >/dev/null 2>&-
		fi
		if [[ -d "$thefile" ]] && [[ -z "$(ls -A "$thefile")" ]]; then
			rmdir -p "${thefile}" >/dev/null 2>&-
		fi
	done <"${CACHEDIR_LIST}/${cPkgBaseVersion}.list"

	popd >/dev/null 2>&- || return 1
	IFS=$SAVEIFS

	if ! rm "$CACHEDIR_DESC/$cPkgBaseVersion.desc" >/dev/null 2>&-; then {
		log_msg $ERR_ERROR "Error, It was not possible remove $CACHEDIR_DESC/$cPkgBaseVersion.desc"
		return 1
	}; fi
	if ! rm "$CACHEDIR_LIST/$cPkgBaseVersion.list" >/dev/null 2>&-; then {
		log_msg $ERR_ERROR "Error, It was not possible remove $CACHEDIR_LIST/$cPkgBaseVersion.list"
		return 1
	}; fi
	return $ERR_OK
}

sh_pre_remove() {
	local cPkgBaseVersion="$1"
	local cExtList="$cPkgBaseVersion.list"

	if [[ -e "$CACHEDIR_LIST/$cExtList" ]]; then
		sh_remove_now "$cPkgBaseVersion"
		return $ERR_OK
	else
		log_msg $ERR_ERROR "Error, file not found: ${red}$CACHEDIR_LIST/$cExtList"
		return $ERR_ERROR
	fi
}

# -Sw
function sh_download() {
	local param="$*"
	local error_value=0
	local nFilesDownloaded=0

	LDEPS=$false
	LEXACT=$true
	sh_listpkgdisp "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" "$param"
	local ntotal_pkg_listed="${public_ntotal_pkg_listed}"

	#	sh_checknet || return 1

	if [[ -n "${public_pkg[*]}" ]]; then
		pushd "$CACHEDIR_ARCHIVES/" >/dev/null 2>&- || return 1

		for i in ${public_pkg[@]}; do
			sh_splitpkg "$i"
			local cfullname="${aPKGSPLIT[$PKG_FULLNAME]}"
			if test -e "$CACHEDIR_ARCHIVES/$cfullname"; then
				if ! ((LFORCE)); then
					log_msg $ERR_ERROR "${orange}${i##*/} ${reset}Package is already downloaded. Use the -f option to force download."
					popd >/dev/null 2>&- || return 1
					return 1
				fi
			fi
			sh_wgetdesc "$i"
			if sh_wgetfull "$i"; then
				((++nFilesDownloaded))
			fi
		done
		msg "${cyan}($nFilesDownloaded) package(s) downloaded."
		popd >/dev/null 2>&- || return 1
	fi
}

function sh_sanitize_deps() {
	local arr=("${@:1}")
	local cdep

	for i in ${arr[@]}; do
		cdep="${i%%=*}"
		cdep="${cdep%%.so*}"
		cdep="${cdep#lib}"
	done
	return 0
}

sh_getdeps() {
	local ncontadep=0
	local arr
	local pkgNumber=0
	local cfullfilename
	local x
	local LDEPS=$1
	local ndep

	GETDEPS=()
	deps=()

	((verbose >= 2)) && log_msg "Solving dependencies"

	for i in ${public_pkg[@]}; do
		sh_splitpkg "$i"
		cbase="${aPKGSPLIT[PKG_BASE]}"
		cfullfilename="${aPKGSPLIT[PKG_FULLNAME]}"
		[[ -e "$CACHEDIR_ARCHIVES/$cfullfilename.desc" ]] || sh_wgetdesc || return 1
		source "$CACHEDIR_ARCHIVES/$cfullfilename.desc"
		if ((LDEPS)); then
			deps+=("${dep[*]}")
			deps+=("$(grep ^depend "$CACHEDIR_ARCHIVES/$cfullfilename.desc" | awk -F"'" '{print $2}')")
		fi
	done

	#sanitize deps
	deps=("$(sh_adel "${deps[*]}")")
	adeps=${deps[*]}
	deps=()

	for i in ${adeps[@]}; do
		cdep="${i%%=*}"
		cdep="${cdep%%.so*}"
		cdep="${cdep%%>=*}"
		cdep=$(grep -Po '^([a-z]+[-|_]?[a-z]+)' <<<"$i")

		if ! sh_ascanpkg "$cdep" "0"; then
			cdep="${cdep#lib}"
			if ! sh_ascanpkg "$cdep" "0"; then
				continue
			fi
		fi
		deps+=("$cdep")
	done
	deps=("$(sh_adel "${deps[*]}")")

	for i in ${deps[@]}; do
		((++ncontadep))
		pkgdep=$(grep ^"$i$SEP" "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" | awk -F"$SEP" '{print $5}')
		if [[ -z "$pkgdep" ]]; then
			if ((verbose)); then
				printf "${red}%s(%04d) ${orange}%-40s ${reset}%-40s\n" "     " "$ncontadep" "${i}" "CUIDADO! Dependency not found in the database. ${reset}Use: # fetch -Syy to update with the repository${reset}"
			fi
		else
			GETDEPS+=("$pkgdep")
			pkginstalled=$(grep ^"$i$SEP" "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" | awk -F"$SEP" '{print $5}')
			#	  		if [[ -z "$pkginstalled" ]]; then
			#				#GETDEPS+=("$pkgdep")
			#				echo
			#	  		fi
		fi
	done
	# 	public_pkg_deps+=$GETDEPS
	# 	public_pkg_deps+=${GETDEPS[*]}
	public_pkg_deps+=("${GETDEPS[@]}")
	return $?
}

sh_splitarray() {
	local str=("$1")
	local pos="$2"
	local sep="${3:-'|'}"
	local array

	[[ $# -eq 3 && "$pos" = "|" && "$sep" =~ ^[0-9]+$ ]] && {
		sep="$2"
		pos="$3"
	}
	[[ $# -eq 2 && "$pos" = "$sep" ]] && {
		sep="$pos"
		pos=0
	}
	[[ $# -eq 1 || ! "$pos" =~ ^[0-9]+$ ]] && { pos=0; }

	#  IFS="$sep" read -r -a array <<< "$str"
	IFS="$sep" read -r -a array <<<"${str[@]}"
	echo "${array[pos]}"
}

sh_splitpkg() {
	file=$1
	declare -gA APKGSPLIT=()
	aPKGSPLIT=()
	pkg_folder_dir=${file%/*} #remove arquivo deixando somente o diretorio/repo
	pkg_fullname=${file##*/}  #remove diretorio deixando somente nome do pacote

	[[ "$pkg_folder_dir" == "$pkg_fullname" ]] && pkg_folder_dir="localhost"
	if [[ "$pkg_fullname" =~ $PKG_RE ]]; then
		pkg_fullname="${BASH_REMATCH[0]}"
		pkg_base="${BASH_REMATCH[1]}"
		pkg_version_build="${BASH_REMATCH[2]}"
		pkg_version="${BASH_REMATCH[3]}"
		pkg_build="${BASH_REMATCH[4]}"
		pkg_arch="${BASH_REMATCH[5]}"
		pkg_base_version="${pkg_base}-${pkg_version_build}"

		: <<'comment'
		#debug "$pkg_base \n $pkg_version_build \n $pkg_version \n $pkg_build \n $pkg_arch \n $pkg_base_version \n"
		debug   " file            : $file\n" \
		        "pkg_folder_dir  : $pkg_folder_dir\n" \
			 	  "pkg_fullname    : $pkg_fullname\n" \
			 	  "pkg_arch        : $pkg_arch\n" \
			 	  "pkg_base        : $pkg_base\n" \
				  "pkg_base_version: $pkg_base_version\n" \
				  "pkg_version     : $pkg_version\n" \
				  "pkg_build       : $pkg_build"
comment
		APKGSPLIT+=(["$pkg_base"]="pkg_folder_dir|$pkg_fullname|$pkg_arch|$pkg_base|$pkg_base_version|$pkg_version-$pkg_build|$pkg_build")
		aPKGSPLIT=("$pkg_folder_dir"
			"$pkg_fullname"
			"$pkg_arch"
			"$pkg_base"
			"$pkg_base_version"
			"$pkg_version-$pkg_build"
			"$pkg_build"
		)
		return 0
	fi
	return 1
}
export -f sh_splitpkg

sh_splitpkgIFS() {
	local file=$1
	local pkg_folder_dir
	local pkg_fullname
	local pkg_arch
	local pkg_base
	local pkg_base_version
	local pkg_version
	local pkg_build
	local pkg_str
	local nconta=0
	local char='-'
	local var
	local re

	aPKGSPLIT=()
	pkg_folder_dir="${file%/*}"             #remove arquivo deixando somente o diretorio/repo
	pkg_fullname="${file##*/}"              #remove diretorio deixando somente nome do pacote
	pkg_arch="${pkg_fullname%."$PKG_EXT"*}" #remove extensao pacote (chi.zst/mz)
	pkg_arch="${pkg_arch%.arch1*}"          #remove extensao pacote (chi.zst/mz)
	pkg_arch="${pkg_arch##*-}"              #remove do começo até o ultimo -

	pkg_str="${pkg_fullname%-any."$PKG_EXT"*}" #remove extensao pacote (chi.zst/mz)
	pkg_str="${pkg_str%."$PKG_EXT"*}"          #remove extensao pacote (chi.zst/mz)
	pkg_str="${pkg_str%-x86_64*}"              #remove extensao pacote (chi.zst/mz)
	pkg_str="${pkg_str%."$PKG_EXT"*}"          #remove extensao pacote (chi.zst/mz)

	IFS='-'
	read -ra ADDR <<<"$pkg_str" # str is read into an array as tokens separated by IFS
	for var in "${ADDR[@]}"; do # access each element of array
		re='^[a-zA-Z]'
		if [[ "$var" =~ $re ]]; then
			pkg_base="$pkg_base${var}$char"
		else
			((nconta++))
			[[ $nconta -eq 1 ]] && pkg_version=$var || pkg_build=$var
		fi
	done
	IFS=$SAVEIFS
	pkg_base=${pkg_base%-*}
	pkg_base_version="${pkg_base}-${pkg_version}-${pkg_build}"
	[[ $pkg_folder = "" ]] && pkg_folder=$pkg_fullname

	aPKGSPLIT=("$pkg_folder_dir"
		"$pkg_fullname"
		"$pkg_arch"
		"$pkg_base"
		"$pkg_base_version"
		"$pkg_version-$pkg_build"
		"$pkg_build"
	)

	#	aPKGLIST=${aPKGSPLIT[*]}
	#	arr=(${aPKGSPLIT[*]})
	return $?
}

sh_splitpkgawk() {
	file=$1
	aPKGSPLIT=()

	pkg_folder_dir="${file%/*}" #remove arquivo deixando somente o diretorio/repo
	pkg_fullname="${file##*/}"  #remove diretorio deixando somente nome do pacote

	#	arr=($(echo "$pkg_fullname" | awk 'match($0, /(.+)-(([^-]+)-([0-9]+))-([^.]+)\.chi\.zst/, array) {
	#			print array[0]
	#			print array[1]
	#			print array[2]
	#		   print array[3]
	#		   print array[4]
	#   		print array[5]
	#    		print array[6]
	#			}'))
	mapfile -t arr < <(echo "$pkg_fullname" | awk 'match($0, /(.+)-(([^-]+)-([0-9]+))-([^.]+)\.chi\.zst/, array) {
			print array[0]
			print array[1]
			print array[2]
		   print array[3]
		   print array[4]
    		print array[5]
    		print array[6]
			}')

	pkg_fullname="${arr[0]}"
	pkg_base="${arr[1]}"
	pkg_version_build="${arr[2]}"
	pkg_version="${arr[3]}"
	pkg_build="${arr[4]}"
	pkg_arch="${arr[5]}"
	pkg_base_version="${arr[0]}-${arr[4]}"

	aPKGSPLIT=("$pkg_folder_dir"
		"$pkg_fullname"
		"$pkg_arch"
		"$pkg_base"
		"$pkg_base_version"
		"$pkg_version-$pkg_build"
		"$pkg_build"
	)
	return $?
}

# -S
function sh_install() {
	local param="$*"
	local loldverbose=$verbose
	local ntotal_pkg_listed=0

	SPLITPOS='4'
	#	LTABLE=$true
	LEXACT=$true
	sh_listpkgdisp "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" "$param" || return 1
	ntotal_pkg_listed=$public_ntotal_pkg_listed
	verbose=$loldverbose

	if ((ntotal_pkg_listed)); then
		[[ -d $CACHEDIR_ARCHIVES/ ]] || mkdir -p "$CACHEDIR_ARCHIVES/"
		cd "$CACHEDIR_ARCHIVES/" || return 1

		if ! ((LAUTO)); then
			if ! readconf "${blue}:: ${reset}Continuar a instalação?"; then
				return
			fi
		fi
		LFORCE=$true
		sh_installdownload || return 1
		sh_installdoinstallpkg
	fi
	sh_cdroot
}

function sh_installdownload() {
	local cfullfilename
	local cpacote
	local cpacotebase

	sh_checknet || return 1
	for i in ${public_pkg[@]}; do
		sh_splitpkg "$i"
		cfullfilename=${aPKGSPLIT[PKG_FULLNAME]}
		cpacote=${aPKGSPLIT[PKG_FULLNAME]}
		cpacotebase=${aPKGSPLIT[PKG_BASE]}

		[[ -e "$CACHEDIR_ARCHIVES/$cpacote" ]] || sh_wgetpartial "$i"
		local error_value=$?

		if [ ${error_value} -ne 0 ]; then
			log_msg $ERR_ERROR "ERROR: Downloading ${orange}${cfullfilename}"
			log_wait_msg "Reiniciando download ${orange}${cfullfilename}"
			sh_wgetfull
			local error_value=$?
			if [ ${error_value} -ne 0 ]; then
				log_msg $ERR_ERROR "${red}fatal error downloading ${orange}${cfullfilename}${reset}"
				exit 1
			fi
		fi
	done
}

function sh_wgetresponse() {
	local i="$1"
	local cfile="${i##*/}"
	local cfullfilename="$CACHEDIR_ARCHIVES/$cfile"
	local lresult
	local response

	((verbose >= 2)) && log_info_msg "${DOT}${cyan}Fetching package ${cRaw}/packages/${orange}${i}"
	response=$(curl -s -w "%{http_code}\n" -k -O "${cRaw}/packages/$i")
	lresult=$?
	((verbose >= 2)) && evaluate_retval $lresult

	if ! [[ $response -eq 200 ]]; then
		rm -f "$cfullfilename" >/dev/null 2>&-
		if ! ((LSKIPERROR)); then
			log_msg $ERR_ERROR "${red}response curl error: $response ${reset}NOT FOUND file ${orange}${cfile} ${reset}at $SITE/packages/ - Use the ${yellow}--skiperror ${reset}option to skip install."
		else
			log_msg $ERR_ERROR "${red}response curl error: $response ${reset}NOT FOUND file ${orange}${cfile} ${reset}at $SITE/packages/"
		fi
		return 1
	fi
	return 0
}

function sh_wgetpartial() {
	local cfullfilename="$1"
	local cRaw

	[[ -z "$cpacote" ]] && cpacote="${cfullfilename##*/}"
	((GITSITE)) && cRaw="$RAW" || cRaw="$SITE"

	sh_wgetresponse "$i.desc" || return 1
	sh_wgetresponse "$i" || return 1
}

function sh_wgetdesc() {
	local cfullfilename="$1"
	local cRaw
	local nretval=1

	((GITSITE)) && cRaw="$RAW" || cRaw="$SITE"
	pushd "$CACHEDIR_ARCHIVES/" >/dev/null 2>&-
	sh_wgetresponse "$i.desc"
	nretval=$?
	popd >/dev/null 2>&-
	return $nretval
}

function sh_wgetfull() {
	local cfullfilename="$1"
	local cRaw
	local nretval

	((GITSITE)) && cRaw="$RAW" || cRaw="$SITE"
	sh_wgetresponse "$i"
	nretval=$?
	return $nretval
}

function sh_installdoinstallpkg() {
	local LINSTALLED=$false
	local cpacoteinstalled

	for i in ${public_pkg[@]}; do
		sh_splitpkg "$i"
		local cfullfilename=${aPKGSPLIT[PKG_FULLNAME]}
		local cpacote=${aPKGSPLIT[PKG_FULLNAME]}
		local cpacotebase=${aPKGSPLIT[PKG_BASE]}
		local cBaseVersion=${aPKGSPLIT[$PKG_BASE_VERSION]}

		case "$cpacotebase" in
		gcc)
			log_msg $ERR_ERROR "Skipping package: $cpacotebase"
			continue
			;;
		gcc-libs)
			log_msg $ERR_ERROR "Skipping package: $cpacotebase"
			continue
			;;
		glibc)
			log_msg $ERR_ERROR "Skipping package: $cpacotebase"
			continue
			;;
		file)
			log_msg $ERR_ERROR "Skipping package: $cpacotebase"
			continue
			;;
		flac)
			log_msg $ERR_ERROR "Skipping package: $cpacotebase"
			continue
			;;
		esac

		cpacoteinstalled=$(grep ^"$cpacotebase$SEP" "${CACHEDIR_SEARCH}/$PACKAGES_INSTALLED_SPLIT" | cut -d"$SEP" -f6)
		[[ "$cpacoteinstalled" == "$cBaseVersion" ]] && LINSTALLED=$true || LINSTALLED=$false
		if ((LINSTALLED)) && ! ((LFORCE)); then
			log_msg "$ERR_ERROR" "${orange}${cBaseVersion} ${reset}Package is already installed. Use the -f option to force reinstallation."
			continue
		fi
		sh_installpkg "$cpacote"
		local error_value=$?
		if ! ((error_value)); then
			log_msg "${green}${cpacote} ${reset}Done. Package installation successfully."
		fi
	done
}

sh_listmeta() {
	#	local param="$@"
	local param="$*"
	local cListSearch=$param
	local x
	local arr
	public_ntotal_pkg_meta=0

	LLIST=$true
	if ((verbose >= 2)); then
		log_msg "Reading meta package lists in the repository..."
	fi

	if ((LALL)) || [[ -z "$cListSearch" ]]; then
		if ((LALL)); then
			metapkg=$(cat "$CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES")
		else
			log_msg $ERR_ERROR "${red}error${reset}: nenhum alvo definido (use -h para obter ajuda)"
			exit 1
		fi
	else
		for x in $cListSearch; do
			if ((LEXACT)); then
				cfile="$(grep "\/$x.meta$" "$CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES")"
			else
				cfile="$(grep "$x" "$CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES")"
			fi
			metapkg+="$cfile"

			if [[ -z $cfile ]]; then
				if ! ((LSKIPERROR)); then
					log_msg $ERR_ERROR "${red}error${reset}: ${orange}${x} ${reset}target was ${red}NOT ${reset}found. Use the ${yellow}--skiperror ${reset}option to force install. "
					exit 1
				else
					log_msg $ERR_ERROR "${red}error${reset}: ${orange}${x} ${reset}target was ${red}NOT ${reset}found. ${yellow}Skipping"
				fi
			fi
		done
	fi

	arr=("${metapkg[*]}")
	public_ntotal_pkg_meta=${#arr[*]}

	if ((public_ntotal_pkg_meta)); then
		if ((verbose >= 2)); then
			log_msg "Listing... Done"
		fi
		for i in $metapkg; do
			((LLIST)) && log_success_msg2 "${blue}FOUND ${orange}$i"
		done
		((LLIST)) && log_success_msg2 "($public_ntotal_pkg_meta) meta package(s) found."
	else
		log_msg $ERR_ERROR "${red}error: ${reset}target not found : ${orange}${param}"
	fi
	return "$public_ntotal_pkg_meta"
}

sh_installmeta() {
	#	local param="$@"
	local param="$*"
	local pkgInMeta=()
	local cmetapackage

	sh_listmeta "$param"
	public_ntotal_pkg_meta=$?

	if ((public_ntotal_pkg_meta)); then
		if ! ((LAUTO)); then
			if ! readconf "${blue}:: ${reset}Continue installation ?"; then
				return
			fi
			LAUTO=$true
		fi

		pushd "$CACHEDIR_ARCHIVES/" >/dev/null 2>&- || return 1
		for cmetafile in $metapkg; do
			cmetapackage=$(echo "$cmetafile" | cut -d/ -f2)

			if ! ((GITSITE)); then
				curl --silent -k -O "$SITE/packages/$cmetafile"
			else
				curl --silent -k -O "$RAW/packages/$cmetafile"
			fi
			pkgInMeta+=("$(cat "$CACHEDIR_ARCHIVES/$cmetapackage")")
		done

		popd >/dev/null 2>&- || return 1
		param="${pkgInMeta[*]}"

		#		[[ $verbose -eq 0 ]] && (( verbose=1 ))
		verbose=0
		sh_listpkgdisp "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" "$param"
		local ntotal_pkg_listed=${public_ntotal_pkg_listed}

		if [[ $public_pkg != "" ]]; then
			[[ -d "$CACHEDIR_ARCHIVES/" ]] || mkdir -p "$CACHEDIR_ARCHIVES/"
			cd "$CACHEDIR_ARCHIVES/" || return 1

			if ! ((LAUTO)); then
				if ! readconf "${blue}:: ${reset}Continue installation ?"; then
					return
				fi
			fi
			sh_installdownload
			sh_installdoinstallpkg
		fi
		sh_cdroot
	fi
}

sh_recreateFilesFromArch() {
	local arch_path="/var/lib/pacman/local"
	local item
	local nfiles
	local aCache

	((verbose >= 2)) && log_msg "Fixing packages installed by pacman"
	pushd "$arch_path" >/dev/null 2>&- || return 1
	mapfile -t aCache < <(printf '%s\n' *)
	nfiles=$(lenarray "${aCache[*]}")
	popd >/dev/null 2>&- || return 1

	if ((nfiles)); then
		#   	for item in $aCache; do
		for item in "${aCache[@]}"; do
			[[ "$item" == "ALPM_DB_VERSION" || $item == ',,,,' || -z $item ]] && continue
			[[ -f "$CACHEDIR_DESC/$item.desc" ]] || printf '' >|"$CACHEDIR_DESC/$item.desc"
			grep -v '^%FILES%' $arch_path/$item/files > $CACHEDIR_LIST/$item.list
		done
		return 0
	fi
	return 1
}
export -f sh_recreateFilesFromArch

# -Sr
function sh_recreatefilepackagesinstalled() {
	local ext='list'
	local re="(.+)-(([^-]+)-([0-9]))+[.]($ext)$"
	local item
	local package
	local pkgNumber=0
	local nfiles
	local aCache
	local lresult=1
	local cbase

	((verbose > 1)) && log_msg "$(gettext "Recriando lista de pacotes instalados")"
	sh_recreateFilesFromArch
	((verbose > 1)) && log_msg "$(gettext "Lendo listas de pacotes instalados")"

	printf '' >|"$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"
#	mapfile -t aCache < <(printf '%s\n' "$CACHEDIR_DESC"/* | awk -F "$re" 'list[$1]++')
	mapfile -t aCache < <(printf '%s\n' "$CACHEDIR_LIST"/* | awk -F "$re" 'list[$1]++')
	#2	aCache=$(grep -Po "$re" < <(printf '%s\n' $CACHEDIR_DESC/*) )
	#1	aCache=$(find $CACHEDIR_DESC/ -regextype posix-egrep -regex "$re" -type f | sort -V)
	nfiles=$(arraylen "${aCache[@]}")
	pkgnumber=0

	if ((nfiles)); then
		((verbose > 1)) && log_msg "$(gettext "Verificando pacotes instalados")"
		((verbose > 1)) && sh_cabec "$nfiles"

		for item in "${aCache[@]}"; do
			[[ -z "$item" ]] && continue
			package=${item##*/}
			package=${package%.$ext*}
			status=' I '
			clisting='N'
			#			LTABLE=$true
			((LTABLE)) && verbose=2
			((verbose > 1)) && clisting=''

			if sh_ascanpkg "$package" '5'; then
				cbase="${aPKGARRAY[0]}"
				clineascan >>"$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"
				((++pkgNumber))
				if ((verbose > 1)); then
					sh_write "$cbase" '-1' $((pkgNumber)) "$status" "$clisting"
					printf " %b ${pink}(%d)${reset} %-100s\r" "${TICK}" "$((nfiles - pkgNumber))" "$cbase"
				else
					cline="$(sh_write "$cbase" '-1' $((pkgNumber)) "$status" "$clisting")"
					if [[ -n "$cline" ]]; then
						printf " %b ${pink}(%d)${reset} %-200s\r" "${TICK}" "$((nfiles - pkgNumber))" "$cline"
					fi
				fi
			else
				log_err "${yellow}AVISO ${cyan}$(gettext "pacote") $package $(gettext "não encontrado")" "$?"
			fi
		done
		lresult=0
	fi
	log_msg "${yellow}($nfiles) ${cyan}$(gettext "pacotes encontrados")"
	log_msg "${yellow}($((nfiles-pkgNumber))) ${cyan}$(gettext "pacotes antigos removidos manualmente?")"
	log_msg "${yellow}($pkgNumber) ${cyan}$(gettext "pacotes instalados/listados - (usar -Sr --verbose ou --table para listar)")"
	return $lresult
}

: <<'comment'
# -Sr
function sh_recreatefilepackagesinstalled() {
	local re='(.+)-(([^-]+)-([0-9]))+[.](desc)$'
	local item
	local package
	local pkgNumber=0
	local nfiles
	local aCache
	local lresult=1
	local cbase

	# Função para processar um pacote
	process_package_recreate() {
		item="$1"
		[[ -z "$item" ]] && return
		package=${item##*/}
		package=${package%.desc*}
		status=' I '
		clisting='N'
		((LTABLE)) && verbose=2
		((verbose > 1)) && clisting=''

		if sh_ascanpkg "$package" '5'; then
			cbase="${aPKGARRAY[0]}"
			clineascan >>"$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"
			if ((verbose > 1)); then
				sh_write "$cbase" '-1' $((pkgNumber)) "$status" "$clisting"
				printf " %b ${pink}(%d)${reset} %-100s\r" "${TICK}" "$((nfiles - pkgNumber))" "$cbase"
			else
				cline="$(sh_write "$cbase" '-1' $((pkgNumber)) "$status" "$clisting")"
				if [[ -n "$cline" ]]; then
					printf " %b ${pink}(%d)${reset} %-200s\r" "${TICK}" "$((nfiles - pkgNumber))" "$cline"
				fi
			fi
		else
			log_err "${yellow}AVISO ${cyan}pacote $package não encontrado" "$?"
		fi
	}
	# Exporta a função para uso com o parallel
	export -f process_package_recreate

	((verbose > 1)) && log_msg "$(gettext "Recriando lista de pacotes instalados")"
	sh_recreateFilesFromArch
	((verbose > 1)) && log_msg "$(gettext "Lendo listas de pacotes instalados")"

	printf '' >|"$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"

	# Lista de arquivos de descrição de pacotes
#	aCache=("$CACHEDIR_DESC"/*)
	mapfile -t aCache < <(printf '%s\n' "$CACHEDIR_DESC"/* | awk -F "$re" 'list[$1]++')
	nfiles="${#aCache[@]}"
	pkgNumber=0

	if ((nfiles)); then
		# Processa os pacotes em paralelo
		parallel --gnu --jobs $MAX_PARALLEL process_package_recreate ::: "${aCache[@]}" &
		wait

		log_msg "${yellow}($nfiles) ${cyan}pacotes encontrados         - (pacotes antigos removidos manualmente?)"
		log_msg "${yellow}($pkgNumber) ${cyan}pacotes instalados/listados - (usar -Sr --verbose ou --table para listar)"
		lresult=0
	fi
	return $lresult
}
comment

# -Qq
sh_totalpackagesinstalled() {
	if ((verbose >= 2)); then
		awk -F "," '{print $1}' "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"
	else
		sh_linecount "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"
	fi
}

sh_listforinstall() {
	#	local param="$@"
	local param="$*"
	local pkgNumber=0
	local s
	local LLIST=$true
	local LEXACT=$false
	local LALL=$false
	local LDEPS=$true
	local ncontapkg=0
	local cListSearch
	local arr

	[[ -e "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" ]] || printf '' >"$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"
	public_ntotal_pkg_installed=$(sh_linecount "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT")
	public_ntotal_pkg_listed="$public_ntotal_pkg_installed"
	public_pkg=()

	for s in "${param[@]}"; do
		cListSearch+="$s "
	done

	if ((LALL)) || [[ -z "$cListSearch" ]]; then
		if ((LALL)); then
			public_pkg=("$(grep ^ "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" | cut -d"$SEP" -f5)")
		else
			log_msg $ERR_ERROR "${red}error${reset}: nenhum alvo definido (use -h para obter ajuda)"
			exit 1
		fi
	else
		for x in $cListSearch; do
			if ((LEXACT)); then
				if [[ "$SPLITPOS" == "0" ]]; then
					#					public_pkg="$public_pkg $(grep ^"$x": "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" | cut -d"$SEP" -f1)"
					public_pkg+=("$(grep ^"$x": "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" | cut -d"$SEP" -f1)")
				else
					#					public_pkg="$public_pkg $(grep ^"$x": "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" | cut -d"$SEP" -f5)"
					public_pkg+=("$(grep ^"$x": "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" | cut -d"$SEP" -f5)")
				fi
			else
				if [[ "$SPLITPOS" == "0" ]]; then
					#					public_pkg="$public_pkg $(grep "$x" "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" | cut -d"$SEP" -f1)"
					public_pkg+=("$(grep "$x" "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" | cut -d"$SEP" -f1)")
				else
					#					public_pkg="$public_pkg $(grep "$x" "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" | cut -d"$SEP" -f5)"
					public_pkg+=("$(grep "$x" "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" | cut -d"$SEP" -f5)")
				fi
			fi
		done
	fi

	if ((LLIST)); then
		arr=("${public_pkg[*]}")
		ncontapkg=${#arr[*]}
		if [[ "${#public_pkg}" -gt 0 ]]; then # pacote?
			pkgNumber=0
			sh_getdeps $LDEPS
			arr=("${public_pkg[*]}")
			ncontapkg=${#arr[*]}
			public_ntotal_pkg_listed=$ncontapkg
		else
			log_msg "($pkgNumber) package(s) found."
			echo
			echo -e "${reset}Use: # ${APP} -Sy - to update with the repository${reset}"
		fi
	else
		pkgNumber=0
		for i in ${public_pkg[@]}; do
			((pkgNumber++))
		done
		public_ntotal_pkg_listed="$pkgNumber"
	fi
	sh_cdroot
	return $pkgNumber
}

sh_list_archives_directories() {
	local packname="${1}.list"
	local LIST_CLEAN_DIRECTORIES

	sed -i "
        s/^\.\///g
        s/^\///g
        s|\/$||g
        /^\./d
        /^ *$/d
        /^bin$/d
        /^info$/d
        /^boot$/d
        /^dev$/d
        /^etc$/d
        /^home$/d
        /^lib$/d
        /^lib64$/d
        /^media$/d
        /^mnt$/d
        /^opt$/d
        /^proc$/d
        /^root$/d
        /^run$/d
        /^sbin$/d
        /^srv$/d
        /^sys$/d
        /^tmp$/d
        /^usr$/d
        /^var$/d
        /^info\/pos\.sh$/d
        /^info\/pre\.sh$/d
        /^info\/desc/d
        /info\/rm.sh/d
        /^var\/lib\/banana\/list\/.*\.list/d
        /^var\/lib$/d
        /^var\/lib\/banana/d
        /^var\/lib\/banana\/list/d
        /^var\/lib\/banana\/remove/d
	" "${CACHEDIR_LIST}/${packname}"

	LIST_CLEAN_DIRECTORIES=(
		'var'
		'lib'
		'media'
		'usr'
		'usr/share'
		'srv'
	)

	while read -r view; do
		if [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[0]}/(cache|lib|local|lock|log|mail|opt|run|spool|tmp)$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^$view$/d" "${CACHEDIR_LIST}/${packname}"
		elif [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[1]}/(lib64)$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^$view$/d" "${CACHEDIR_LIST}/${packname}"
		elif [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[2]}/(cdrom|floppy)$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^$view$/d" "${CACHEDIR_LIST}/${packname}"
		elif [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[3]}/(bin|etc|lib|lib\/(pkgconfig)|local|share|doc|include|libexec|sbin|src)$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^$view$/d" "${CACHEDIR_LIST}/${packname}"
		elif [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[4]}/(keymaps|fonts|pixmaps|applications|doc|man|man\/man[[:digit:]]+|man\/.{2})$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^$view$/d" "${CACHEDIR_LIST}/${packname}"
		elif [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[5]}/(www|httpd)$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^${view}$/d" "${CACHEDIR_LIST}/${packname}"
		fi
	done <"$CACHEDIR_LIST/$packname"
}

sh_manage_scripts_and_archives() {

	#	sh_splitpkg "${1}"
	local packname=${aPKGSPLIT[$PKG_BASE_VERSION]}
	local dir_desc="${CACHEDIR_LIST/list/desc}"

	if ! [[ -e "/tmp/info/desc" ]]; then
		log_msg $ERR_ERROR "ERROR! /info/desc does not exist. ABORT!"
		return 1
	fi

#	pushd "/tmp/info/" >/dev/null 2>&- || return 1
	if ! mv '/tmp/info/desc' "$CACHEDIR_DESC/${packname}.desc"; then
		log_msg $ERR_ERROR "ERROR! could not move desc to /${dir_desc}/${packname}.desc"
		return 1
	fi

	if [[ -e "/tmp/info/pos.sh" ]]; then
		log_msg "running pos.sh hook"
		bash "/tmp/info/pos.sh"
	fi

	if [[ -e "/tmp/info/.INSTALL" ]]; then
		source /tmp/info/.INSTALL >/dev/null 2>&-
		log_msg "running post_install hook"
		post_install >/dev/null 2>&-
		log_msg "running post_upgrade hook"
		post_upgrade >/dev/null 2>&-
	fi

	if [[ -e "/tmp/info/rm.sh" ]]; then
		if ! mv '/tmp/info/rm.sh' "$CACHEDIR_REMO/${packname}.rm"; then
			log_msg $ERR_ERROR "ERROR! could not move rm.sh to $CACHEDIR_REMO/${packname}.rm"
			return 1
		fi
	fi

#	popd >/dev/null 2>&- || return 1
	[[ -d "/info/" ]] && rm -r "/info/"
	[[ -d '/tmp/info/' ]] && rm -r "/tmp/info/"
	[[ -e '/.BUILDINFO' ]] && rm "/.BUILDINFO"
	[[ -e '/.MTREE' ]] && rm "/.MTREE"
	[[ -e '/.PKGINFO' ]] && rm "/.PKGINFO"
	[[ -e '/.INSTALL' ]] && rm "/.INSTALL"
	return 0
}

sh_create_list() {
	local packname="$1"

	if ! tar --use-compress-program=zstd --force-local --list --file "$packname" >"${CACHEDIR_LIST}/${name_version_build}.list"; then
		log_msg $ERR_ERROR "ERROR! Can not create ${CACHEDIR_LIST}/${name_version_build}.list"
		return 1
	fi
	return 0
}

sh_input_null_parameter() {
	local arr
	local cpkg="$1"

	if [[ -z "$cpkg" ]]; then
		cpkg=$(echo "$PWD" | sed 's/\// /g' | awk '{print $NF}' | sed 's/-/_/g' | sed 's/\(.*\)_/\1 /' | sed 's/ /-/g')
		arr=("$cpkg")
		[[ ${#arr[*]} -gt 2 ]] && cpkg="${arr[0]}_${arr[1]} ${arr[2]}"
		cpkg=${cpkg}-${DESC_BUILD}
	fi
	sh_info "INPUT_NULL" "$cpkg"
	return 0
}

sh_name_format_pkg() {
	local packname="$1"

	re="\b${PKG_EXT}\b"
	if ! [[ "$packname" =~ .*\.${re}$ ]]; then
		log_msg $ERR_ERROR "ERROR Package need finish .${PKG_EXT}"
		return 1
	fi
	return 0
}

sh_doinstallpkg() {
	(
		local packname="$1"
		local name_version_build
		local PRE_SH='info/pre.sh'
		local POS_SH='info/pos.sh'
		local INSTALL_SH='info/.INSTALL'

		tar --dereference \
			--force-local \
			--use-compress-program=zstd \
			--extract \
			--preserve-permissions \
			--touch \
			--file "${packname}" -C "/tmp/" "./${DESCME}" "./${PRE_SH}" "./${POS_SH}" "./${INSTALL_SH}" >/dev/null 2>&-

		if [[ ! -e "/tmp/${DESCME}" ]]; then
			log_msg $ERR_ERROR "${red}ERROR! ${reset}I could not untar the file: ${orange}${packname}.desc${reset}"
			return 1
		fi
		source "/tmp/${DESCME}" || log_msg $ERR_ERROR "ERROR! could not load /tmp/${DESCME}. Archive not exist. ABORT!"

		if [[ -e "/tmp/${PRE_SH}" ]]; then
			log_msg "running pre.sh hook"
			bash "/tmp/${PRE_SH}"
		fi

		if [[ -e "/tmp/${INSTALL_SH}" ]]; then
			log_msg "running .INSTALL hook"
			bash "/tmp/${INSTALL_SH}"
		fi

		#name_version_build="${pkgname}-${version}-${build}"
		sh_splitpkg "$packname"
		name_version_build=${aPKGSPLIT[$PKG_BASE_VERSION]}
		tar --dereference \
			--force-local \
			--use-compress-program=zstd \
			--extract \
			--preserve-permissions \
			--touch \
			--file "${packname}" -C / | tee -a "$CACHEDIR_LIST/$name_version_build.list" || return 1

		sh_create_list "$1" || return 1
		sh_manage_scripts_and_archives "${packname}" || return 1
		sh_list_archives_directories "${name_version_build}"
	)
	return "$?"
}

# -Sl/-U
sh_initinstallpkg() {
	#	local param="$@"
	local param="$*"
	local pkg
	local package
	local arr
	local nfiles

	if ! ((LALL)); then
		#		test $# -lt 1 && die "${red}erro${reset}: nenhum alvo definido (use -h para obter ajuda)" $true
		test $# -lt 1 && die "${red}erro${reset}: nenhum alvo definido (use -h para obter ajuda)" $true
	fi

	shopt -s nullglob # enable suppress error message of a command
	if ((LALL)); then
		pkg="$pkg $(find "$PWD/" "$CACHEDIR_ARCHIVES/" -type f -iname "*.$PKG_EXT")"
	else
		for s in "${param[@]}"; do
			cfile=$(echo "$s" | sed 's/\// /g' | awk '{print $NF}')
			pkg="$pkg $(find "$PWD/" "$CACHEDIR_ARCHIVES/" -type f -iname "*.$PKG_EXT" | grep "$cfile")"
		done
	fi

	pkgCheckNumber=0
	LLIST=$true
	arr=("${pkg[*]}")
	nfiles=${#arr[*]}

	if ((nfiles)); then # pacote?
		for i in $pkg; do
			((LLIST)) && log_success_msg2 "${blue}FOUND local package ${orange}$i"
			((pkgCheckNumber++))
		done

		if ((pkgCheckNumber)); then
			if ! ((LAUTO)); then
				conf "$(DOT)continue installation?"
				LAUTO=$?
			fi
		fi

		if ((LAUTO)); then
			for package in $pkg; do
				log_success_msg2 "${blue}Installing local package ${orange}$package"
				sh_installpkg "$package"
			done
		fi
	else
		msg "${orange}$param ${red}NOT FOUND ${reset}local package in ${orange}${CACHEDIR_ARCHIVES}${reset}"
		msg "${orange}$param ${red}NOT FOUND ${reset}local package in ${orange}${PWD} ${reset}"
		printf '%s\n' "${reset}Use: ${0##*/} -Sy to update with the repository${reset}"
	fi
	shopt -u nullglob # disable suppress error message of a command
}

sh_installpkg() {
	local cfileinstalled
	local fullname
	local package

	while [[ -n "$1" ]]; do
		fullname="$1"
		package="${fullname##*/}" ## tira o path
		sh_doinstallpkg "$fullname" || return $ERR_ERROR
		sh_splitpkg "$fullname" || return $ERR_ERROR
		cfileinstalled=${aPKGSPLIT[$PKG_BASE_VERSION]}
		cline=$(clinesplit)
		sed -i '/'"$cfileinstalled"'/d' "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" || return $ERR_ERROR
		echo "${cline}" >>"$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"
		shift
	done
	return $ERR_OK
}

sh_sign_gpg() {
	local package=$1
	local sig='sig'

	#Pacote existe?
	if [[ ! -e "${package}.${PKG_EXT}" ]]; then
		printf '%s\n' "${red}[ERRO]${end} Unable to sign package. ${package}.${PKG_EXT}"
		printf '%s\n' "Reason: Package not found."
		printf '%s\n' "For security reasons, do not pass the package on to third parties."
		return 1
	fi

	[ "$REWRITE_SIGN" = "1" ] && rm -f "../$package.$PKG_EXT.$sig"
	[ "$REWRITE_SIGN" = "1" ] && rm -f "$package.$PKG_EXT.$sig"

	if which gpg >/dev/null 2>&-; then
		#Gerando Assinatura no pacote
		gpg --detach-sign --pinentry-mode loopback "${package}.${PKG_EXT}" >/dev/null 2>&- ||
			gpg --detach-sign "${package}.${PKG_EXT}" || return 1
		echo -e "${blue}[Create]${end} Your ${sig} on:   ../${package}.${PKG_EXT}.${sig}"
	fi
	return 0
}

sh_verify_on() {
	local package=$1
	local dir_info='info'
	local info_desc='desc'

	if [[ ! -d "$dir_info" ]]; then
		log_msg $ERR_ERROR "${red}[ERROR!]${end} ${pink}${dir_info}${end} directory\n"
		log_msg $ERR_ERROR "It's necessary your package have the DIRECTORY ${pink}info${end}."
		log_msg $ERR_ERROR "${pink}${dir_info}${end} its a directory store important archives."
		log_msg $ERR_ERROR "For more information use -h, --help."
		exit 77
	elif [[ ! -e "${dir_info}/${info_desc}" ]]; then
		log_msg $ERR_ERROR "${red}[ERROR!]${end} ${pink}${info_desc}${end} archive\n"
		log_msg $ERR_ERROR "It's necessary your package have the ARCHIVE ${pink}desc${end} inside of directory '${dir_info}'."
		log_msg $ERR_ERROR "${pink}${info_desc}${end} have informations of your package."
		log_msg $ERR_ERROR "For more information use -h, --help."
		exit 1
	else
		source "$dir_info/$info_desc"

		if [[ -z "$maintainer" ]]; then
			log_msg $ERR_ERROR "Check ${pink}${info_desc}${end}, VARIABLE ${blue}maintainer${end} null"
			log_msg $ERR_ERROR "Enter the name of the package maintainer into variable maintainer."
			#exit 1
		elif [[ -z "$pkgname" ]]; then
			log_msg $ERR_ERROR "Check ${pink}${info_desc}${end}, VARIABLE ${blue}pkgname${end} null"
			log_msg $ERR_ERROR "Enter the name of the package into variable pkgname."
			#exit 1
		elif [[ -z "$version" ]]; then
			log_msg $ERR_ERROR "Check ${pink}${info_desc}${end}, VARIABLE ${blue}version${end} null"
			log_msg $ERR_ERROR "Enter a version of software into variable version."
			#exit 1
		elif [[ -z "$build" ]]; then
			log_msg $ERR_ERROR "Check ${pink}${info_desc}${end}, VARIABLE ${blue}build${end} null"
			log_msg $ERR_ERROR "Enter the build number of package."
			#exit 1
		elif [[ -z "$desc" ]]; then
			log_msg $ERR_ERROR "Check ${pink}${info_desc}${end}, VARIABLE ${blue}desc${end} null"
			log_msg $ERR_ERROR "Detail a small description into variable desc."
			#exit 1
		elif [[ -z "$url" ]]; then
			log_msg $ERR_ERROR "Check ${pink}${info_desc}${end}, VARIABLE ${blue}url${end} null"
			log_msg $ERR_ERROR "Enter a url of project/software into variable url."
			#exit 1
		fi
	fi

	for check_script in 'pre.sh' 'pos.sh' 'rm.sh'; do
		if [[ -e "${dir_info}/${check_script}" ]]; then
			if _GREP 'rm[[:space:]]+\-(rf|fr)' "${dir_info}/${check_script}" >/dev/null 2>&-; then
				log_msg $ERR_ERROR "${red}ERROR ${reset}${PWD}/${dir_info}/$check_script contain command rm -rf. ABORTED NOW."
				return 1
			fi
		fi
	done
	return "$?"
}

sh_create_pkg() {
	local package=$1
	local ext_desc='desc'

	if tar --force-local --use-compress-program="zstd --ultra" --create --file ../"$package" .; then
		cp "$DESCME" ../"$package.$ext_desc" >/dev/null 2>&-
		pushd .. >/dev/null 2>&- || return 1
		if ((CREATE_SHA256)); then
			sha256sum "$package" >"$package".sha256
		fi
		if ((GPG_SIGN)); then
			sh_sign_gpg "$package" || return 1
			popd >/dev/null 2>&- || return 1
		else
			return 0
		fi
	fi
	evaluate_retval
}


sh_generate_desc() {
	local i
	local DESC_PACKNAME=$1
	local DESC_VERSION=$2
	local DESC_BUILD=$3
	local field_pkgver=$4
	local field_pkgrel=$5

	DESC="${DESC//\'/}"							# Remove todas as ocorrências de apóstrofe
	public_pkgdesc="${public_pkgdesc//\'/}"		# Remove todas as ocorrências de apóstrofe
	[[ ! -d "info" ]] && mkdir info >/dev/null 2>&-

	if [ -e info/desc ]; then
		if ! ((LFORCE)); then
			if ((verbose >= 2)); then
				((ncount++))
				log_msg "$(fmt)${orange} info/desc ${reset}already exist. Skipping... Use the -f option to force recreate."
			fi
			return
		else
			if ((verbose >= 2)); then
				((ncount++))
				log_msg "$(fmt)${orange} info/desc ${reset}already exist. Rewriting"
			fi
		fi
	fi
	[[ -z "$SIZE"    ]] && SIZE=$(sizeof_du .)
	[[ -z "$public_url" ]] && public_url="$URL"
	[[ -z "$public_pkgdesc" ]] && public_pkgdesc="$DESC"
	[[ -z "$public_license" ]] && public_license="$LICENSE"
	[[ -z "$public_arch"    ]] && public_arch="$ARCH"
	[[ -z "$public_source"  ]] && public_source=""
	[[ -z "$public_validpgpkeys"  ]] && public_validpgpkeys=""
	[[ -z "$public_sha256sums"  ]] && public_sha256sums=""

	cat >"info/desc" <<-EOF
		######################################################################
		# Generated with fetch    - https://chililinux.com
		# Generated with alienpkg - https://chililinux.com
		######################################################################
		maintainer='$MAINTAINER'
		pkgname='$DESC_PACKNAME'
		version='$DESC_VERSION'
		build='$DESC_BUILD'
		pkgver='$field_pkgver'
		pkgrel='$field_pkgrel'
		lfs_version='$LFS_VERSION'
		lfs_init='$LFS_INIT'
		arch='$public_arch'
		distro='$DISTRO'
		desc="$public_pkgdesc"
		pkgdesc="$public_pkgdesc"
		size='$SIZE'
		license=(${public_license[@]})
		url='$public_url'
		source=(${public_source[@]})
		validpgpkeys=(${public_validpgpkeys[@]})
		sha256sums=(${public_sha256sums[@]})
		dep=(${public_deps[@]})
		depends=(${public_depends[@]})
	EOF

	for i in ${deps[@]}; do
		echo depend="'$i'" >>"$DESCME"
	done
	return 0
}

sh_generatepkg() {
	#	local param="$@"
	local param="$*"

	if [[ ${#param} -eq 0 ]]; then # run standalone
		LAUTO=$true
		LLIST=$false
		pkg="${PWD##*/}.$PKG_EXT"
	else
		for s in "${param[@]}"; do
			pkg="$s"
			continue
		done
	fi

	((verbose >= 1)) && {
		((++ncount))
		log_msg "$(fmt) Generating info for package $pkg"
	}
	[[ ! -e "info/desc" ]] && LFORCE=$true

	if ((LAUTO)) || ((LFORCE)); then
		if [[ -z "$DESC_PACKNAME" ]]; then
			sh_splitpkg "$pkg"
			field_pkgname="${aPKGSPLIT[$PKG_BASE]}"
			field_pkgver="${aPKGSPLIT[$PKG_VERSION]}"
			field_version="${aPKGSPLIT[$PKG_VERSION]}"
			field_pkgrel="${aPKGSPLIT[$PKG_BUILD]}"
			field_build="${aPKGSPLIT[$PKG_BUILD]}"
		else
			field_pkgname="${DESC_PACKNAME}"
			field_pkgver="${DESC_VERSION}"
			field_version="${DESC_VERSION}"
			field_pkgrel="${DESC_BUILD}"
			field_build="${DESC_BUILD}"
		fi
		[[ -z "$field_build" ]] && field_build="$DESC_BUILD"
		[[ -z "$DESC" ]] && DESC="$field_pkgname-$field_version"

		sh_generate_desc "$field_pkgname" "$field_version" "$field_build" "${field_pkgver::-2}" "$field_pkgrel" || return $ERR_ERROR
	fi
	return $ERR_OK
}

# -C # -c
sh_createpkg() {
	#  local param="$@"
	local param="$*"
	local s
	local pkg

	for s in "${param[@]}"; do pkg="$s"; done
	[[ -z "$pkg" ]] && pkg=$(echo "$PWD" | sed 's/\// /g' | awk '{print $NF}')
	((verbose >= 1)) && {
	((++ncount))
		log_msg "$(fmt) Building package $pkg"
	}

	pkg="$pkg.$PKG_EXT"
	sh_generatepkg "$pkg"
	sh_name_format_pkg "$pkg" || exit 1
	sh_verify_on "$pkg" || exit 1
	sh_create_pkg "$pkg" || exit 1
	((verbose >= 1)) && {
	((++ncount))
		log_msg "$(fmt) Generating package ${yellow}$pkg"
	}
}

# -Sa
sh_alienpkg_main() {
	sh_alienpkg_initvars "$*"
	sh_alienpkg_exec "$*"
}

sh_alienpkg_initvars() {
	BUILDDIR="${PKGCORE:=${CACHEDIR}/archives}"
	[[ -n "${BUILDDIR}" ]] || BUILDDIR="${CACHEDIR}/archives" >/dev/null 2>&-
	[[ -d "${BUILDDIR}" ]] || mkdir -p "${BUILDDIR}" >/dev/null 2>&-
}

function sh_alienpkg_exec() {
	local param="$*"
	local pkg
	local package
	local LFORCELOCAL
	local string
	local ntotalpkg=0
	local ntotalfindpkgs=0
	local arraypkg
	local npackagesprocessed=0
	local firstletter
	local FilteredPackage
	local destpkgGIT
	local destpkgCORE
	export deps

	if [[ -z "$param" ]]; then
		LALL=$true
	else
		LALL=$false
		for s in "${param[@]}"; do string+="$s"; done
	fi

	if ((LALL)); then
		if ! ((LTIME)); then
			mapfile -t pkg < <(find "$ALIEN_CACHE_DIR/" -regextype posix-egrep -regex "$RE_ALIEN" -type f)
		else
			mapfile -t pkg < <(find "$ALIEN_CACHE_DIR/" -regextype posix-egrep -regex "$RE_ALIEN" -type f -mtime "$mtime")
		fi
	else

		for str in $string; do
			if ! ((LTIME)); then
				if ((LEXACT)); then
					pkg+=("$(find "$ALIEN_CACHE_DIR/" -regextype posix-egrep -regex "$ALIEN_CACHE_DIR/$str$RE_ALIEN" -type f)")
				else
					pkg+=("$(find "$ALIEN_CACHE_DIR"/ -iname "*$str*" -regextype posix-egrep -regex "$RE_ALIEN" -type f)")
				fi
			else
				pkg+=("$(find "$ALIEN_CACHE_DIR"/ -iname "*$str*" -regextype posix-egrep -regex "$RE_ALIEN" -type f -mtime "$mtime")")
			fi
		done
	fi

	ntotalpkg=${#pkg[*]}
	ntotalfindpkgs=$ntotalpkg
	LFORCELOCAL=$LFORCE

	if ((ntotalpkg)); then # package found?
		for package in ${pkg[@]}; do
			ncount=0
			pkgtar=${package##*/}          #remove diretorio deixando somente nome do pacote
			pkgtar=${pkgtar%%.pkg.tar.zst} #remove .tar.zst ext
			pkgtar=${pkgtar%%.pkg.tar.xz}  #remove .tar.xz ext
			pkgtar=${pkgtar%%.spkg.tar.xz} #remove .tar.xz ext from venom
			! ((CHILI_OS)) && pkgtar=${pkgtar%%-any}
			! ((CHILI_OS)) && pkgtar=${pkgtar%%-x86_64}
			cPacoteSemExt=${pkgtar%%.*}       # https://elmord.org/blog/?entry=20121227-manipulando-strings-bash
			cPacoteSemExt=${cPacoteSemExt%-*} # https://elmord.org/blog/?entry=20121227-manipulando-strings-bash

			if ! ((LFORCELOCAL)); then
				firstletter=${pkgtar::1}
				FilteredPackage=$pkgtar.$PKG_EXT
				destpkgGIT="${LOCALDIR}/packages/${firstletter}/${FilteredPackage}"
				destpkgCORE="${LOCALDIR}/packages/core/${FilteredPackage}"

				if [[ -e "$destpkgGIT" || -e "$destpkgCORE" ]]; then
					((verbose >= 2)) && {
						((++ncount))
						log_msg $ERR_ERROR "$(fmt) ${orange}$FilteredPackage ${reset}Package already exist in ${green}$LOCALDIR/packages/$firstletter/${reset} Use the -f option to force rebuild."
					}
					((--ntotalpkg))
					continue
				fi
			fi

			destdir="$BUILDDIR/$pkgtar"
			((verbose >= 1)) && {
				log_msg "$(gettext "Criando pacote") ${red}#$ntotalpkg ${black}de ${red}#$ntotalfindpkgs"
				((++ncount))
				log_msg "$(fmt) Creating directory $destdir"
			}
			mkdir -p "$destdir" >/dev/null 2>&-

			((verbose >= 1)) && {
				((++ncount))
				log_msg "$(fmt) Unpacking package $package at $destdir"
			}
			tar --use-compress-program=zstd --force-local --extract --file "$package" -C "$destdir" >/dev/null 2>&-

			case $package in
			luit-[0-9]*) sed -i -e "/D_XOPEN/s/5/6/" configure ;;
			esac

			sed -i 's/ = /="/g' "$destdir/.PKGINFO" >/dev/null 2>&-
			sed -i 's/$/"/g' "$destdir/.PKGINFO" >/dev/null 2>&-
			source "$destdir/.PKGINFO" >/dev/null 2>&-

			export DESC_BUILD="${pkgtar: -1}"
			export URL="$url"
			export LICENSE="$license"
			export ARCH="$arch"
			export SIZE="$size"
			export DESC="$pkgdesc"
			export DEP="$depend"
			export DESC_PACKNAME="$pkgname"
			export DESC_VERSION="$pkgver"
			export DESC_BUILD="${pkgver: -1}"

			if [[ -e "$destdir"/.PKGINFO ]]; then
				deps=$(grep ^depend "$destdir"/.PKGINFO | awk -F'"' '{print $2}')
			else
				deps=(${depends[@]})
			fi
			pushd "$destdir" >/dev/null 2>&- || return 1
			rm -f "$destdir"/.BUILDINFO "$destdir"/.MTREE "$destdir"/.PKGINFO >/dev/null 2>&-

#			((++ncount))
			sh_createpkg "$pkgtar"
			((verbose >= 1)) && echo
			((--ntotalpkg))
			((++npackagesprocessed))
		done

		((verbose >= 1)) && log_msg "Total alien packages found     : $ntotalfindpkgs"
		((verbose >= 1)) && log_msg "Total alien packages processed : $npackagesprocessed  ${green}Use the --force option to force rebuild."

		if ! ((LKEEP)); then
			((++ncount))
			#			(( verbose >= 1 )) && log_msg "Verifying candidate packages files for pruning"
			#			removeoldpkgchili $cPacoteSemExt
			#			fetchpack -q -c "$LOCALDIR/packages/" -m /tmp/ "$cPacoteSemExt"
			#			fetchpack_init -k1 -r
		fi
	else
		log_msg $ERR_ERROR "${red}error: ${orange}$x ${reset}package target ${yellow}${param} ${reset}was ${red}NOT ${reset}found in ${yellow}${ALIEN_CACHE_DIR} ${reset}for import"
	fi
	unset size ntotalpkg
	popd >/dev/null 2>&- || return 1
}

sh_alienpkg_pkgsize() {
	size="$(du -sk --apparent-size)"
	size="$((${size%%[^0-9]*} * 1024))"
}

sh_alienpkg_logo() {
	cat <<-'EOF'
		       _ _                  _
		  __ _| (_) ___ _ __  _ __ | | ____ _
		 / _` | | |/ _ \ '_ \| '_ \| |/ / _` |
		| (_| | | |  __/ | | | |_) |   < (_| |
		 \__,_|_|_|\___|_| |_| .__/|_|\_\__, |
		                     |_|        |___/
	EOF
	sh_version
}

sh_upgrade() {
	#	local param="$@"
	local param="$*"
	local LLIST=$false
	local count=0
	local s
	local item
	local cBaseInstalled cBaseVersionInstalled cVersionInstalled
	local cBase cBaseVersion cVersion
	local ntotalconfered
	local pkgrepo
	local ntotal_pkg_listed

	((verbose > 1)) || verbose=0
	LDEPS=$false
	LEXACT=$true
	LLIST=$false
	sh_listpkgdisp "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" "$param"

	local ntotal_pkg_listed=${public_ntotal_pkg_listed}

	for i in ${public_pkg[@]}; do
		sh_splitpkg "$i"
		cBaseInstalled="${aPKGSPLIT[PKG_BASE]}"
		cBaseVersionInstalled="${aPKGSPLIT[PKG_BASE_VERSION]}"
		cVersionInstalled="${aPKGSPLIT[PKG_VERSION]}"
		pkgrepo=$(grep ^"$cBaseInstalled$SEP" "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" | cut -d"$SEP" -f4)
		count=0
		((ntotalconfered++))

		if [[ "${#pkgrepo}" -gt 0 ]]; then # pacote?
			for cPkg in ${pkgrepo}; do
				sh_splitpkg "$cPkg"
				cBase="${aPKGSPLIT[PKG_BASE]}"
				cBaseVersion="${aPKGSPLIT[PKG_BASE_VERSION]}"
				cVersion="${aPKGSPLIT[PKG_VERSION]}"

				case "$cBase" in
				Python) continue ;;
				gtk+) continue ;;
				esac

				if [[ "$cBaseInstalled" == "$cBase" ]]; then
					((count++))
					if [[ "$(vercmp "$cBaseVersionInstalled" "$cBaseVersion")" -lt 0 ]]; then
						log_success_msg2 "[$ntotalconfered/$ntotal_pkg_listed]${orange}${cBase} ${reset}is being updated to newest version ($cVersion)."
						sh_doremove "$cBaseVersionInstalled" "OFF"
						LAUTO=$true
						LFORCE=$true
						LDEPS=$false
						sh_install "$cBase"
					elif [[ "$cBaseVersionInstalled" = "$cBaseVersion" ]]; then
						if ((LFORCE)); then
							LAUTO=$true
							LFORCE=$true
							LDEPS=$false
							sh_install "$cBase"
							continue
						else
							log_success_msg2 "[$ntotalconfered/$ntotal_pkg_listed]${orange}${cBase} ${reset}is already the newest version ${green}($cVersionInstalled)${reset}. Use the -f option to force reinstallation."
							continue
						fi
					else
						if ((LFORCE)); then
							LAUTO=$true
							LFORCE=$true
							LDEPS=$false
							sh_install "$cBase"
						else
							log_success_msg2 "[$ntotalconfered/$ntotal_pkg_listed]${orange}${cBase} ${reset}is already the newest version ($cVersionInstalled)."
						fi
						if ((count > 1)); then
							log_warning_msg "${orange}${cBaseInstalled} ${red}WARNING!! there is more than one release of the package in the repo!"
						fi
					fi
				else
					log_warning_msg "[$ntotalconfered/$ntotal_pkg_listed]${orange}${cBase} ${reset}not installed."
				fi
			done
		else
			log_warning_msg "[$ntotalconfered/$ntotal_pkg_listed]${orange}${cBaseInstalled} ${red}WARNING!! package not in repo! Use 'fetch update' to update the database"
		fi
	done

	if [[ "${#public_pkg}" -le 1 ]]; then # nenhum pacote?
		log_warning_msg "$orange$param$cyan package not installed"
		echo
		if conf "${blue}:: ${reset}Install Pakages(s)?"; then
			LAUTO=$true
			LFORCE=$true
			LDEPS=$false
			sh_install "$param"
		fi
	fi
	sh_cdroot
}

checkDependencies() {
	local d
	local errorFound=0
	declare -a missing

	for d in "${DEPENDENCIES[@]}"; do
		[[ -n $(command -v "$d") ]] && { :; } || {
			log_msg "ERROR: Could not find command ${cyan}'$d'${reset}"
			missing+=("$d")
			errorFound=1
		}
	done
	if ((errorFound)); then
		echo "${yellow}---------------IMPOSSIBLE TO CONTINUE---------------"
		echo "${black}This script needs the commands listed above"
		echo "Install them and/or make sure they are in your \$PATH"
		echo "${yellow}---------------IMPOSSIBLE TO CONTINUE---------------"
		exit 1
	fi
}

sh_cleaning() {
	log_msg "${pink}Cleaning temporary files${reset}"
	rm -rf "${TMP_DIR_ROOT:?}"/ >/dev/null 2>&-
}

sh_backup() {
	if ((verbose >= 2)); then
		log_msg "${pink}Making backup: $CACHEDIR_SEARCH/${reset}"
	fi
	mkdir -p "$TMP_DIR_BACKUP" >/dev/null 2>&-
	mkdir -p "$TMP_DIR_FOLDERS" >/dev/null 2>&-
	cp -f "$CACHEDIR_SEARCH/*" "$TMP_DIR_BACKUP/" >/dev/null 2>&-
}

sh_version() {
	orange=$(tput setaf 166)
	printf "%s\n" "${orange}${0##*/} v${_VERSION_}"
}

#figlet
logo() {
	cat <<-'EOF'
		  __      _       _
		 / _| ___| |_ ___| |__     Copyright (c) 2019-2022 Vilmar Catafesta <vcatafesta@gmail.com>
		| |_ / _ \ __/ __| '_ \    Copyright (c) 2019-2022 Chili GNU/Linux Development Team <root@chililinux.com>
		|  _|  __/ || (__| | | |
		|_|  \___|\__\___|_| |_|   Este programa pode ser redistribuído livremente
		                           sob os termos da Licença Pública Geral GNU.
	EOF
	sh_version
}

fetchpack_configure() {
	#  fetchpack - A flexible cache cleaning utility in ChiliOS
	#########################################################################
	declare -a cachedirs=() candidates=() cmdopts=() candesc=()
	declare -i delete=0 dryrun=0 move=0 totalsaved=0 pkgcount=0
	declare -i verbose=0 ctime=0 QUIET=0
	declare delim=$'\n'
	declare keep=1
	declare movedir=
	declare USE_COLOR='y'
	# Expand to nothing if there are no matches
	shopt -s nullglob
	shopt -s extglob
}

fetchpack_main() {
	local nfiles=0
	local pkg
	local pkgInAll
	local pkg_base
	local candidates=()
	local cachedir
	local re="$FETCH_RE"

	if ((QUIET)); then
		verbose=0
	else
		if ((verbose)); then
			if ((dryrun)); then
				log_msg "${white}running mode => ${green}DRY-RUN"
			elif ((delete)); then
				log_msg "${white}running mode => ${red}DELETE"
			elif ((move)); then
				log_msg "${white}running mode => ${yellow}MOVE"
			fi
		fi
	fi

	for cachedir in "${cachedirs[@]}"; do
		[[ -d $cachedir ]] || {
			log_msg $ERR_ERROR "${red}Error: cachedir '$cachedir' does not exist or is not a directory -- skipping"
			continue
		}
		pushd "$cachedir" &>/dev/null || die "Error: failed to chdir to $cachedir"

		if [ $# -lt 1 ]; then
			AllOldPackages=$(find "$PWD" -type f -iname "*.$PKG_EXT" | sort -Vr | awk -F "$re" 'lista[$1]++')
		else
			AllOldPackages=$(find "$PWD" -type f -iname "*.$PKG_EXT" | grep "$1" | sort -Vr | awk -F "$re" 'lista[$1]++')
		fi

		while read -r pkgInAll; do
			pkg_base="$pkgInAll"
			[[ -z "$pkg_base" ]] && continue
			((++pkgNumber))

			if ((verbose >= 3)); then
				printf "  $(DOT)${white}candidate package ${purple}(%04d) ${green}%s\n" "$pkgNumber" "$pkg_base"
			fi
			[[ -e "$pkgInAll" ]] && candidates+=("$pkgInAll")
			[[ -e "$pkgInAll.desc" ]] && candesc+=("$pkgInAll.desc")
		done <<<"$AllOldPackages" #done < <(printf '%s\n' "$AllOldPackages") #done <<< $(printf '%s\n' "$AllOldPackages")
		popd >/dev/null 2>&1
	done

	if ((!${#candidates[*]})); then
		log_msg "${green}NO candidates packages found for pruning"
		return 1
	fi

	if ((verbose >= 2)); then
		pkgNumber=0
		while read -r pkg; do
			((++pkgNumber))
			printf "  $(DOT)${white}found package ${purple}(%04d) ${green}%42s\n" "$pkgNumber" "$pkg"
		done <<<"$(printf '%s\n' "${candidates[@]}")"
		#done < <(printf '%s\n' "${candidates[@]}") #done <<< "${candidates[@]}"
	fi

	ncandidates=${#candidates[*]}
	ncandesc=${#candesc[*]}
	pkgcount=$((ncandidates + ncandesc))

	((ncandidates)) && totalsaved=$(printf '%s\0' "${candidates[@]}" | xargs -0 stat -c %s | awk '{ sum += $1 } END { print sum }')
	((ncandesc)) && totalsaved+=$(printf '%s\0' "${candesc[@]}" | xargs -0 stat -c %s | awk '{ sum += $1 } END { print sum }')
	set -o errexit # Exit immediately if a pipeline returns non-zero.

	if ((delete)); then
		((verbose)) && cmdopts+=(-v)
		cmdopts+=(-f)
		((ncandidates)) && printf '%s\0' "${candidates[@]}" | runcmd xargs -0 rm "${cmdopts[@]}"
		((ncandesc)) && printf '%s\0' "${candesc[@]}" | runcmd xargs -0 rm "${cmdopts[@]}"
	elif ((move)); then
		((verbose)) && cmdopts+=(-v)
		cmdopts+=(-f)
		((ncandidates)) && printf '%s\0' "${candidates[@]}" | runcmd xargs -0 mv "${cmdopts[@]}" -t "$movedir"
		((ncandesc)) && printf '%s\0' "${candesc[@]}" | runcmd xargs -0 mv "${cmdopts[@]}" -t "$movedir"
	elif ((verbose)); then
		((ncandidates)) && printf '%s\0' "${candidates[@]}" | xargs -0 printf "  $(DOT)%s\n" "${cmdopts[@]}"
		((ncandesc)) && printf '%s\0' "${candesc[@]}" | xargs -0 printf "  $(DOT)%s\n" "${cmdopts[@]}"
	fi

	if ((!QUIET)); then
		if ((dryrun)); then
			msg "${yellow}finish dry-run (packages found: $ncandidates with .desc) (disk space saved: %s)" "$(size_to_human "$totalsaved")"
		else
			msg "(packages found: $ncandidates with .desc) (disk space saved: %s)" "$(size_to_human "$totalsaved")"
		fi
	fi
	return 0
}

fetchpack_usage() {
	cat <<-EOF
		${cyan}Usage: ${yellow}fetch -Sc <operation> [options] [targets...]${reset}

		  Operations:
		${red}     -d, --dryrun          ${reset}perform a dry run, only finding candidate packages.
		${red}     -m, --move <dir>      ${reset}move candidate packages to "dir".
		${red}     -r, --remove          ${reset}remove candidate packages.

		  Options:
		${red}     -c, --cachedir <dir>  ${reset}scan "dir" for packages. can be used more than once.
		                           (default: read from /etc/fetch/fetch.conf).
		${red}     -k, --keep <num>      ${reset}keep "num" of each package in the cache (default: 1).
		${red}     -f, --force           ${reset}apply force to mv(1) and rm(1) operations.
		${red}     -h, --help            ${reset}display this help message and exit.
		${red}         --nocolor         ${reset}remove color from output.
		${red}     -q, --quiet           ${reset}quiet output.
		${red}     -v, --verbose         ${reset}increase verbosity. specify up to 3 times ([-v][-vv][-vvv]).

		${cyan}most common use: ${yellow}fetch -Sc -k1 -r -v${reset}
	EOF
}

function parseopts() {
	local shortopts=$1
	local opt
	local optarg
	local i
	local -a longopts=()
	local -a unused_argv=()

	shift
	while [[ $1 && $1 != '--' ]]; do
		longopts+=("$1")
		shift
	done
	shift

	longoptmatch() {
		local o longmatch=()
		for o in "${longopts[@]}"; do
			if [[ ${o%:} = "$1" ]]; then
				longmatch=("$o")
				break
			fi
			[[ ${o%:} = "$1"* ]] && longmatch+=("$o")
		done

		case ${#longmatch[*]} in
		1)
			# success, override with opt and return arg req (0 == none, 1 == required)
			opt=${longmatch%:}
			#				if [[ $longmatch = *: ]]; then
			if [[ "${longmatch[*]}" = *: ]]; then
				return 1
			else
				return 0
			fi
			;;
		0)
			# fail, no match found
			return 255
			;;
		*)
			# fail, ambiguous match
			#				printf "${0##*/}: $(gettext "option '%s' is ambiguous; possibilities:")" "--$1"
			printf "%s %s\n" "${0##*/}: $(gettext "option '%s' is ambiguous; possibilities:")" "--$1"
			printf " '%s'" "${longmatch[@]%:}"
			printf '\n'
			return 254
			;;
		esac >&2
	}

	while (($#)); do
		case $1 in
		--) # explicit end of options
			shift
			break
			;;
		-[!-]*) # short option
			for ((i = 1; i < ${#1}; i++)); do
				opt=${1:i:1}

				# option doesn't exist
				if [[ $shortopts != *$opt* ]]; then
					printf "${0##*/}: $(gettext "invalid option") -- '%s'\n" "$opt" >&2
					OPTRET=(--)
					return 1
				fi

				OPTRET+=("-$opt")
				# option requires optarg
				if [[ $shortopts = *$opt:* ]]; then
					# if we're not at the end of the option chunk, the rest is the optarg
					if ((i < ${#1} - 1)); then
						OPTRET+=("${1:i+1}")
						break
					# if we're at the end, grab the the next positional, if it exists
					elif ((i == ${#1} - 1)) && [[ $2 ]]; then
						OPTRET+=("$2")
						shift
						break
					# parse failure
					else
						#							printf "${0##*/}: $(gettext "option requires an argument") -- '%s'\n" "$opt" >&2
						printf "%s %s\n" "${0##*/}: $(gettext "option requires an argument") -- '%s'" "$opt"
						OPTRET=(--)
						return 1
					fi
				fi
			done
			;;
		--?*=* | --?*) # long option
			IFS='=' read -r opt optarg <<<"${1#--}"
			longoptmatch "$opt"
			case $? in
			0)
				# parse failure
				if [[ $optarg ]]; then
					#							printf "${0##*/}: $(gettext "option '%s' does not allow an argument")\n" "--$opt" >&2
					printf "%s %s\n" "${0##*/}: $(gettext "option '%s' does not allow an argument")" "--$opt"
					OPTRET=(--)
					return 1
				# --longopt
				else
					OPTRET+=("--$opt")
				fi
				;;
			1)
				# --longopt=optarg
				if [[ $optarg ]]; then
					OPTRET+=("--$opt" "$optarg")
				# --longopt optarg
				elif [[ $2 ]]; then
					OPTRET+=("--$opt" "$2")
					shift
				# parse failure
				else
					#							printf "${0##*/}: $(gettext "option '%s' requires an argument")\n" "--$opt" >&2
					printf "%s%s\n" "${0##*/}: $(gettext "option '%s' requires an argument")" "--$opt"
					OPTRET=(--)
					return 1
				fi
				;;
			254)
				# ambiguous option -- error was reported for us by longoptmatch()
				OPTRET=(--)
				return 1
				;;
			255)
				# parse failure
				printf "${0##*/}: $(gettext "invalid option") '--%s'\n" "$opt" >&2
				OPTRET=(--)
				return 1
				;;
			esac
			;;
		*) # non-option arg encountered, add it as a parameter
			unused_argv+=("$1")
			;;
		esac
		shift
	done

	# add end-of-opt terminator and any leftover positional parameters
	OPTRET+=('--' "${unused_argv[@]}" "$@")
	unset longoptmatch
	return 0
}

function runcmd() {
	if ((EUID != 0)); then
		msg "Privilege escalation required"
		if sudo -v &>/dev/null && sudo -l &>/dev/null; then
			sudo "$@"
		else
			die 'Unable to escalate privileges using sudo'
		fi
	else
		"$@"
	fi
}

function msg() {
	local mesg=$1
	shift
	printf "%s\n" "${green}  =>${reset}${bold} ${mesg}${reset}" "$*"
}

fetchpack_init() {
	#	sh_checkroot
	#	checkDependencies
	fetchpack_configure

	OPT_SHORT=':a:c:dfhi:k:m:qrsuVvzt:'
	OPT_LONG=('arch:' 'cachedir:' 'dryrun' 'force' 'help' 'ignore:' 'keep:' 'move:' 'nocolor' 'quiet' 'remove' 'uninstalled' 'version' 'verbose' 'null' 'ctime:')

	if ! parseopts "$OPT_SHORT" "${OPT_LONG[@]}" -- "$@"; then
		return 1
	fi
	set -- "${OPTRET[@]}"
	unset OPT_SHORT OPT_LONG OPTRET

	while :; do
		case $1 in
		-t | --ctime)
			ctime="$2"
			: echo "$ctime"
			shift
			;;
		-c | --cachedir)
			cachedirs+=("$2")
			shift
			;;
		-d | --dryrun)
			dryrun=1
			;;
		-f | --force)
			cmdopts=(-f)
			;;
		-h | --help)
			fetchpack_usage
			return
			;;
		-m | --move)
			move=1 movedir=$2
			shift
			;;
		--nocolor)
			sh_unsetvarcolors
			USE_COLOR='n'
			;;
		-q | --quiet)
			sh_unsetvarcolors
			QUIET=1
			;;
		-r | --remove)
			delete=1
			;;
		-V | --version)
			logo
			return
			;;
		-v | --verbose)
			((++verbose))
			;;
		--)
			shift
			break 2
			;;
		esac
		shift
	done

	# check if messages are to be printed using color
	if [[ -t 2 && $USE_COLOR != "n" ]]; then
		sh_setvarcolors
	fi

	# setting default cachedirs
	if [[ -z "${cachedirs[*]}" ]]; then
		[[ -n "$LOCALDIR" ]] && cachedirs=("$LOCALDIR")
		cachedirs+=("/var/cache/fetch/archives")
	fi

	# sanity checks
	case $((dryrun + delete + move)) in
	0) die "no operation specified (use -Sc -h for help)" ;;
	[^1]) die "only one operation may be used at a time" ;;
	esac

	[[ $movedir && ! -d $movedir ]] && die "destination directory '$movedir' does not exist or is not a directory!"

	if ((move || delete)); then
		# make it an absolute path since we're about to chdir
		[[ $movedir && ${movedir:0:1} != '/' ]] && movedir=$PWD/$movedir
		#		[[ $movedir && ! -w $movedir ]] && needsroot=1
	fi

	fetchpack_main "$@"
}

usage() {
	tput sgr0 # reset colors
	bold=$(tput bold)
	reset=$(tput sgr0)
	red=$(tput setaf 124)
	yellow=$(tput setaf 136)
	pink=$(tput setaf 129)

	cat <<-EOF
		${cyan}Most used commands:
		${red}  -h,  help           ${reset}- display this help and exit
		${red}  -Sy, update         ${reset}- update list packages in the repository online. Need Internet
		${red}  -S,  install        ${reset}- install packages
		${red}  -Ss, search         ${reset}- search for packages
		${red}  -Su, upgrade        ${reset}- upgrade packages
		${red}  -Sw, download       ${reset}- only download the binary package into cache directory
		${red}  -Sr, recreate       ${reset}- recreate database installed packages
		${red}  -Sa, alienpkg       ${reset}- import package from ArchLinux
		${red}  -Sg, generate       ${reset}- generate info package from source
		${red}  -C,  create         ${reset}- build package
		${red}  -Sl, local          ${reset}- install local package
		${red}  -U, local           ${reset}- install local package
		${red}  -Sc, clean          ${reset}- erase downloaded packages files
		${red}  -Sm, meta           ${reset}- install meta packages
		${red}  -R,  remove         ${reset}- remove packages
		${red}  -La, list-avaiable  ${reset}- list avaiable packages based on package names
		${red}  -Lc, list-cache     ${reset}- list downloaded packages in cache
		${red}  -Li, list-installed ${reset}- list installed packages
		${red}  -Po, out-cache      ${reset}- list packages out-cache
		${red}  -Pi, in-cache       ${reset}- list downloaded packages in cache
		${red}  -Qi, show           ${reset}- show package details
		${red}  -Qq, total          ${reset}- total packages installed
		${red}  -V,  version        ${reset}- output version information and exit
		${red}  --nocolor           ${reset}- remove color from output
		${red}  --table             ${reset}- output in columns
		${red}  --verbose           ${reset}- verbose output
		${cyan}ex:
		  ${reset}fetch ${pink}-Sy ${reset} self ${yellow}=> Update self fetch via internet
		  ${reset}fetch ${pink}-Sy ${reset}      ${yellow}=> Update database
		  ${reset}fetch ${pink}-Syy${reset}      ${yellow}=> Force update database
		  ${reset}fetch ${pink}-S  ${reset}<package> [<...>] [--all] [--noconfirm] [--force] [--nodeps]
		  ${reset}fetch ${pink}-R  ${reset}<package> [<...>] [--all] [--noconfirm] [--force]
		  ${reset}fetch ${pink}-Su ${reset}[<package>] [<...>] [--all] [--nonconfirm] [--force]
		  ${reset}fetch ${pink}-Ss ${reset}<package> [<...>] [--noconfirm] [--force] [--exact] [--nodeps]
		  ${reset}fetch ${pink}-Li ${reset}[<package>] [<...>] [--all] [--exact]
		  ${reset}fetch ${pink}-Sw ${reset}[<package>] [<...>] [--all] [--noconfirm] [--force]
		  ${reset}fetch ${pink}-Qi ${reset}[<package> [<...>]]
		  ${reset}fetch ${pink}-C  ${reset}[<packname-version-build>]
		  ${reset}fetch ${pink}-Sm ${reset}<xorg> [--noconfirm] [--force]
		  ${reset}fetch ${pink}-Sa ${reset}<package> [<...>] [--all] [--noconfirm] [--force] [--mtime=<n>] [--keep] [--default]
	EOF
}

function sh_parseparam() {
	#	local param="$@"
	local param="$*"
	local s
	local newparam

	export LDEPS=$true
	export LAUTO=$false
	export LFORCE=$false
	verbose=1
	mtime=0
	SPLITPOS='4'
	LLIST=$false
	LEXACT=$false
	LALL=$false
	LSELF=$false
	LKEEP=$false
	LTIME=$false
	LSEARCHONLY=$true
	LSKIPERROR=$false
	LTABLE=$false
	LSHOW=$true

	for s in $param; do
		[[ $(tolower "${s:0:8}") = "--mtime=" ]] && {
			LTIME=$true
			mtime="${s:8}"
			continue
		}
		[[ $(tolower "${s}") = "--default" ]] && {
			LTIME=$true
			LKEEP=$true
			LALL=$true
			continue
		}
		[[ $(tolower "${s}") = "--keep" ]] && {
			LKEEP=$true
			continue
		}
		[[ $(tolower "${s}") = "self" ]] && {
			LSELF=$true
			continue
		}
		[[ $(tolower "${s}") = "--self" ]] && {
			LSELF=$true
			continue
		}
		[[ $(tolower "${s}") = "--nodeps" ]] && {
			LDEPS=$false
			continue
		}
		[[ $(tolower "${s}") = "-y" ]] && {
			LAUTO=$true
			continue
		}
		[[ $(tolower "${s}") = "--auto" ]] && {
			LAUTO=$true
			continue
		}
		[[ $(tolower "${s}") = "--noconfirm" ]] && {
			LAUTO=$true
			continue
		}
		[[ $(tolower "${s}") = "-f" ]] && {
			LFORCE=$true
			continue
		}
		[[ $(tolower "${s}") = "--force" ]] && {
			LFORCE=$true
			continue
		}
		[[ $(tolower "${s}") = "--noverbose" ]] && {
			verbose=0
			continue
		}
		[[ $(tolower "${s}") = "--verbose" ]] && {
			verbose=2
			continue
		}
		[[ $(tolower "${s}") = "--v" ]] && {
			verbose=1
			continue
		}
		[[ $(tolower "${s}") = "--vv" ]] && {
			verbose=2
			continue
		}
		[[ $(tolower "${s}") = "--vvv" ]] && {
			verbose=3
			continue
		}
		[[ $(tolower "${s}") = "-v" ]] && {
			verbose=1
			continue
		}
		[[ $(tolower "${s}") = "-vv" ]] && {
			verbose=2
			continue
		}
		[[ $(tolower "${s}") = "-vvv" ]] && {
			verbose=3
			continue
		}
		[[ $(tolower "${s}") = "-q" ]] && {
			quiet=$true
			verbose=$false
			LTABLE=$false
			continue
		}
		[[ $(tolower "${s}") = "--quiet" ]] && {
			verbose=0
			continue
		}
		[[ $(tolower "${s}") = "off" ]] && {
			LLIST=$false
			continue
		}
		[[ $(tolower "${s}") = "on" ]] && {
			LLIST=$true
			continue
		}
		[[ $(tolower "${s}") = "--exact" ]] && {
			LEXACT=$true
			continue
		}
		[[ $(tolower "${s}") = "all" ]] && {
			LALL=$true
			continue
		}
		[[ $(tolower "${s}") = "--all" ]] && {
			LALL=$true
			continue
		}
		[[ $(tolower "${s}") = "--skiperror" ]] && {
			LSKIPERROR=$true
			continue
		}
		[[ $(tolower "${s}") = "--nocolor" ]] && {
			sh_unsetvarcolors
			continue
		}
		[[ $(tolower "${s}") = "--table" ]] && {
			LTABLE=$true
			continue
		}
		newparam+="$s "
	done
	sh_setLogPrefix
	sh_checkroot "$@"
	#shellcheck disable=SC2086
	init $newparam
}

init() {
	while test $# -gt 0; do
		case "${1}" in
		-Si | -S | install)
			shift
			LSEARCHONLY=$false
			LLIST=$true
			sh_install "$@"
			return
			;;
		-Sl | local | -U)
			shift
			sh_initinstallpkg "$@"
			exit
			;;
		-Sa | alienpkg)
			shift
			sh_alienpkg_main "$@"
			return
			;;
		-Sc | clean)
			shift
			fetchpack_init "$@"
			exit
			;;
		-c | -C | create)
			shift
			sh_createpkg "$@"
			exit
			;;
		-Sg | -g | generate)
			shift
			sh_generatepkg "$@"
			exit
			;;
		-Ss | search)
			shift
			LSHOW=$false
			sh_search "$@"
			exit
			;;
		-Sy | update)
			shift
			sh_updaterepo "$@"
			exit
			;;
		-Syy | refresh)
			shift
			sh_update "$@"
			exit
			;;
		-Sm | --meta | meta)
			shift
			sh_installmeta "$@"
			exit
			;;
		-R | remove)
			shift
			sh_remove "$@"
			exit
			;;
		-Sw | download)
			shift
			sh_download "$@"
			exit
			;;
		-Sr | recreate)
			shift
			LLIST=$true
			sh_recreatefilepackagesinstalled
			exit
			;;
		-Qq | total)
			shift
			sh_totalpackagesinstalled
			exit
			;;
		-L | list)
			shift
			LLIST=$true
			sh_list "$@"
			exit
			;;
		-La | avaiable)
			shift
			LLIST=$true
			sh_list "$@"
			exit
			;;
		-Lc | list-cache)
			shift
			LLIST=$true
			sh_pkgincache "$@"
			exit
			;;
		-Pi | in-cache)
			shift
			LLIST=$true
			sh_pkgincache "$@"
			exit
			;;
		-Li | list-installed)
			shift
			LLIST=$true
			sh_listinstalled "$@"
			exit
			;;
		-Po | out-cache)
			shift
			LLIST=$true
			sh_pkgoutcache "$@"
			exit
			;;
		-Qi | show)
			shift
			sh_show "$@"
			exit
			;;
		-Su | upgrade)
			shift
			sh_upgrade "$@"
			exit
			;;
		-V* | --version | version)
			logo
			exit 0
			;;
		-f* | --force) LFORCE=1 ;;
		-y* | --auto) LAUTO=1 ;;
		-exact | --exact) LEXACT=1 ;;
		-q | --quiet) verbose=0 ;;
		--nocolor) sh_unsetvarcolors ;;
		--table) LTABLE=1 ;;
		-v* | --no-verbose | --verbose)
			((++verbose))
			test "${1:0:5}" = "--no-" && verbose=0
			;;
		-h | --help)
			usage
			exit $(($# ? 0 : 1))
			;;
		*) die "operation not supported: $1 (use -h for help)" ;;
		esac
		shift
	done
}

parsestdin() {
	file=${1--} # POSIX-compliant; ${1:--} can be used either.
	IFS=$'\n'
	while read -r line; do
		echo "$line"
		init -a "$line"
	done </dev/stdin
	#done < <(cat -- "$file")
	#done < <(cat /dev/stdin)
	#done < /dev/stdin
	#done < <(cat "$@")
}

sh_setvarcolors

[[ -z "${1-}" ]] && die "no operation specified (use -h for help)"
[[ "$1" = @(-H|-h|help|-help|--help) ]] && {
	usage
	exit $(($# ? 0 : 1))
}
[[ "$1" = @(-V|-v|version|-version|--version) ]] && {
	logo
	exit $(($# ? 0 : 1))
}

function cleanup() {
	echo
	echo "Interrupt signal received"
	log_msg "${pink}Cleaning...${reset}"
	cp -f "$TMP_DIR_BACKUP/*" "$CACHEDIR_SEARCH"/ >/dev/null 2>&-
	rm -rf "${TMP_DIR_ROOT:?}/" >/dev/null 2>&-
	#	kill -TERM -$$
	exit 1
}
#trap "" 2 				# disable Ctlr+C
#trap    2  	 		# enable Ctlr+C
set -m
trap - INT
trap 'cleanup' 2 # SIGINT SIGTERM SIGTSTP

sh_setLanguage() {
	cmsg_LABEL1[pt_BR]=$(gettext "Usar as setas ↑ e ↓ para navegar.")
	cmsg_LABEL2[pt_BR]=$(gettext "Usar TAB para alternar entre os botões.")
	cmsg_LABEL3[pt_BR]=$(gettext "Usar ENTER ou BARRA DE ESPAÇO para selecionar e aceitar.")
	cmsg_MENU[pt_BR]="${cmsg_LABEL1[pt_BR]}\n${cmsg_LABEL2[pt_BR]}\n${cmsg_LABEL3[pt_BR]}"
}

sh_setEnvironment
checkDependencies
#sh_checkroot "$@"
sh_checkdir
sh_arraypkgfull "$CACHEDIR_SEARCH/$PACKAGES_SPLIT"
sh_parseparam "$@"

: <<'comment'
if [ -p /dev/stdin ]; then
	#for FILE in "$@" /dev/stdin
	for FILE in /dev/stdin
	do
		while IFS= read -r LINE
		do
			#echo "$LINE"
			init "$@" "$LINE"
		done < "$FILE"
	done
else
	# init "$@"
	sh_parseparam "$@"
fi
comment

# vim:set ts=3 sw=3 et:

# CodeBlock?
# Ponteiro=Var ; Var='Valor apontado'
# echo ${!Ponteiro}
